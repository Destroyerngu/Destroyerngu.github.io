<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>删除二叉搜索树中的节点</title>
      <link href="/2022/10/25/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>/2022/10/25/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li><strong>如果此题为删除普通二叉树中的节点呢？</strong></li><li>一般来说，删除节点可分为两个步骤：<ol><li>找到需要删除的节点</li><li>删除此节点</li></ol></li><li>运用<strong>递归三部曲</strong>解此题，主要有以下5种情况<ol><li>没找到删除的节点，遍历到空节点，直接返回</li><li>左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li><li>删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li><li>删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li><li>左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点</li></ol></li></ol><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p><strong>示例</strong>:</p><p><img src="https://img-blog.csdnimg.cn/20201020171048265.png" alt="450.删除二叉搜索树中的节点"></p><p><strong>提示</strong>:</p><ul><li>节点数的范围 [0, 10的4次幂].</li><li>-10的5次幂 &lt;&#x3D; Node.val &lt;&#x3D; 10的5次幂</li><li>节点值唯一</li><li>root 是合法的二叉搜索树</li><li>-10的5次幂 &lt;&#x3D; key &lt;&#x3D; 10的5次幂</li></ul><p>进阶： 要求算法时间复杂度为 O(h)，h 为树的高度。</p><hr><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点 - 力扣（LeetCode）</a>  </p><hr><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一种情况：没找到删除的节点，遍历到空节点直接返回了</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root; </span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">            <span class="comment">// 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">// 内存释放</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> retNode = root-&gt;right;</span><br><span class="line">                <span class="comment">// 内存释放</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> retNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> retNode = root-&gt;left;</span><br><span class="line">                <span class="comment">// 内存释放</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> retNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span></span><br><span class="line">            <span class="comment">// 并返回删除节点右孩子为新的根节点。</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode* cur = root-&gt;right; <span class="comment">// 找右子树最左面的节点</span></span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur-&gt;left = root-&gt;left; <span class="comment">// 把要删除的节点（root）左子树放在cur的左孩子的位置</span></span><br><span class="line">                TreeNode* tmp = root;   <span class="comment">// 把root节点保存一下，下面来删除</span></span><br><span class="line">                root = root-&gt;right;     <span class="comment">// 返回旧root的右孩子作为新root</span></span><br><span class="line">                <span class="keyword">delete</span> tmp;             <span class="comment">// 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的最近公共祖先</title>
      <link href="/2022/10/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>/2022/10/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li><p>最近公共祖先的<strong>定义</strong></p><blockquote><p>对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）</p></blockquote></li></ol><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>例如，给定如下二叉树: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://img-blog.csdnimg.cn/20201016173414722.png" alt="236. 二叉树的最近公共祖先"></p><p>示例 1: 输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p><p>示例 2: 输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p><p><strong>说明</strong>:</p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><p><strong>提示</strong>：</p><ul><li>树中节点数目在范围 [2, 10的5次幂] 内</li><li>-10的9次幂&lt;&#x3D; Node.val &lt;&#x3D; 10的9次幂</li><li>所有 Node.val 互不相同 </li><li>p !&#x3D; q</li><li>p 和 q 均存在于给定的二叉树中</li></ul><hr><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><ol><li>利用回溯，从下往上查找二叉树</li><li>由于是找公共祖先，需要处理中间节点，我们可以通过后序遍历（左右中）（天然的回溯过程），根据左右子树的返回值，来处理中节点的逻辑</li><li>判断一个节点是节点q和节点p的最近公共祖先<ul><li>如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先</li><li><strong>节点本身p(q)，它拥有一个子孙节点q(p)</strong></li></ul></li></ol><hr><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == q || root == p || root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span>  &#123; </span><br><span class="line">            <span class="comment">//  (left == NULL &amp;&amp; right == NULL)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速传递</title>
      <link href="/2022/10/22/%E5%BF%AB%E9%80%9F%E4%BC%A0%E9%80%92/"/>
      <url>/2022/10/22/%E5%BF%AB%E9%80%9F%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<h1 id="快速传递"><a href="#快速传递" class="headerlink" title="快速传递"></a>快速传递</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li>文件传输作为日常生活、工作中需求量较高的一项功能，工作中总会遇到需要将文件从一个设备转移到另一个设备上查看、存储，或者将资料回传的情况。一般大小的文件可以用QQ或者微信的文件传输助手来解决，或者任意一个邮箱也是可以实现的，但如果文件大小过大，传输就有一定问题。</li><li>此篇博客旨在提供<strong>有效途径</strong>去解决上述问题</li><li>强烈推荐直接打开手机<strong>开发者模式</strong>，数据线连接切换到<strong>管理文件</strong>，此时可以使用复制粘贴操作完成（针对手机与电脑传递大文件）</li></ol><hr><h1 id="使用中介软件"><a href="#使用中介软件" class="headerlink" title="使用中介软件"></a>使用中介软件</h1><hr><h1 id="QQ-x2F-微信助手-x2F-邮箱"><a href="#QQ-x2F-微信助手-x2F-邮箱" class="headerlink" title="QQ&#x2F;微信助手&#x2F;邮箱"></a>QQ&#x2F;微信助手&#x2F;邮箱</h1><ol><li>目前有QQ、微信、邮箱。这些主要是手机端与<a href="https://www.zhihu.com/search?q=%E7%BD%91%E9%A1%B5%E7%89%88&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2373926391%7D">网页版</a>之间传输文件，前提是登陆的账号是同一个，传输文件大小限制在2G以下。</li><li>对于上述超过1G的大文件，文件传输速度会变得非常缓慢，更适合1G以下的文件传输，主要是方便。</li><li>由于QQ&#x2F;微信本身的私密性，这种大文件传输方法并不适用于大范围的传输，传播人数受限，因此更适合个人使用，而且邮件发送超过2G也发不出去。所以QQ不能作为大文件传输软件的一种常用渠道使用。</li></ol><hr><h1 id="FileZilla"><a href="#FileZilla" class="headerlink" title="FileZilla"></a>FileZilla</h1><ol><li><p>这是个免费使用的ftp传输<a href="https://www.zhihu.com/search?q=%E5%AE%A2%E6%88%B7%E7%AB%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2373926391%7D">客户端</a>，主要适用于windows系统，mac并不适用。</p></li><li><p>主要原理其实就是传统的ftp局域网传输，只不过与之前需要自己搭建服务器相比，FileZilla提供的客户端要简便许多。操作也很简单，基本上看一遍就能会。</p></li><li><p>比较好的一点是，FileZilla可以实现多个文件的同时收发，速度就要看你所在的网络环境来决定了。</p></li><li><p>有一点不好的是，FileZilla后期的更新与维护还是需要专人来弄，这个也是所有<a href="https://www.zhihu.com/search?q=FTP%E8%BD%AF%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2373926391%7D">FTP软件</a>的共同点了。当然FTP在使用上也会受到地域的限制，无法做到实时传输，只能在指定的机器上完成这一项操作。</p></li><li><p>各类中介软件需要你在电脑安装或者手机上安装相应软件才可以使用，速度一般，有中介，费事</p></li><li><p>如果你是在<strong>电脑</strong>上为手机<strong>备份数据</strong>，那么强烈建议在电脑上安装使用手机软件自带的驱动，这样便于管理。</p><ul><li>这种软件的下载一般用数据线将手机与电脑连接起来即可</li></ul></li></ol><hr><h1 id="云盘or网盘"><a href="#云盘or网盘" class="headerlink" title="云盘or网盘"></a>云盘or网盘</h1><ol><li>用云盘来作为大文件传输软的好处就是可以实现多个终端文件的互通。大文件秒传做的比较出彩的应该算是百度网盘了，仅限于开了超级会员的，免费版的速度还是一言难尽，上传的速度比较慢。</li><li>其次，企业网盘中的<a href="https://www.zhihu.com/search?q=%E9%95%AD%E9%80%9F%E4%BA%91%E4%BC%A0%E6%96%87%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2373926391%7D">镭速云传文件</a>传输做的也很到位，因为拥有网页端使用传输，所以能够实现多个终端的数据互通，更加适合团队或者公司使用。</li><li>另外，跨国传输也是镭速云传主打的一项功能，得益于镭速云传在全球建立的大量数据中心，跨国传输做的还是可以的。</li></ol><hr><h1 id="镭速软件"><a href="#镭速软件" class="headerlink" title="镭速软件"></a><a href="https://www.zhihu.com/search?q=%E9%95%AD%E9%80%9F%E8%BD%AF%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2373926391%7D">镭速软件</a></h1><ol><li>镭速软件提供传输服务器、高速传输引擎、超大文件传输、跨国文件传输、云数据高速传输等服务，在国内很受欢迎。</li><li>随着行业内非结构数据爆炸式增长，海量数字信息在全球范围内快速且可靠地传输已逐渐成为业务成功的关键，所涉及的行业形形色色，包括数字媒体的创建、管理及娱乐内容 传递以及用于科研的基因组序列数据。</li><li>镭速创新型UDP优化传输技术，消除了基于 TCP 的传统文件传输技术（如 FTP 和 HTTP）的缺陷，传输速度比 FTP&#x2F;HTTP 快数百倍，且不受限于文件大小、传输距离或网络条件，支持包括通过卫星、无线以及固有远距离且不可靠的<a href="https://www.zhihu.com/search?q=%E6%B4%B2%E9%99%85%E9%93%BE%E8%B7%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2373926391%7D">洲际链路</a>进行的传输。</li></ol><hr><h1 id="移动端开发者模式传输"><a href="#移动端开发者模式传输" class="headerlink" title="移动端开发者模式传输"></a>移动端开发者模式传输</h1><ol><li><strong>仅限</strong>自己的移动端与电脑之间传输大文件</li><li>将手机与电脑用数据线连接</li><li>手机打开开发者模式，并将数据线连接调为管理文件</li><li>此时，你就可以<strong>直接操作手机上的所有文件</strong>，传输大文件只是复制粘贴的问题，<strong>速度最快</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树中的众数</title>
      <link href="/2022/10/22/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/"/>
      <url>/2022/10/22/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li>强烈建议先看以下两篇博客<ul><li><a href="http://eminent-yaoyilin.com/2022/10/19/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/">二叉搜索树中的搜索</a></li><li><a href="http://eminent-yaoyilin.com/2022/10/20/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">验证二叉搜索树</a></li></ul></li></ol><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 任意顺序 返回。</p><p>假定 BST 满足如下定义：</p><p>结点左子树中所含节点的值 小于等于 当前节点的值<br>结点右子树中所含节点的值 大于等于 当前节点的值<br>左子树和右子树都是二叉搜索树</p><p>示例 1：</p><p>输入：root &#x3D; [1,null,2,2]<br>输出：[2]<br>示例 2：</p><p>输入：root &#x3D; [0]<br>输出：[0]</p><p>示例2：</p><p>给定 BST [1,null,2,2],</p><p><img src="https://img-blog.csdnimg.cn/20201014221532206.png" alt="501. 二叉搜索树中的众数"></p><p>返回[2]</p><p><strong>提示</strong>：</p><p>树中节点的数目在范围 [1, 10的4次幂] 内<br>-10的5次幂 &lt;&#x3D; Node.val &lt;&#x3D; 10的5次幂</p><p><strong>进阶</strong>：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><hr><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数 - 力扣（LeetCode）</a></p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="非二叉搜索树解法"><a href="#非二叉搜索树解法" class="headerlink" title="非二叉搜索树解法"></a>非二叉搜索树解法</h2><p><strong>总体思路</strong>：遍历整个二叉树，用map统计频率，对频率进行排序，最后取出高频元素的集合</p><ol><li>遍历整个二叉树时，我们抓住遍历任务这个主要矛盾，忽略次要矛盾，我们可以发现此时什么遍历顺序和方法都无关紧要，我们此处使用前序遍历</li><li>对统计出的频率排序，在C++中可以将map转化数组vector，再进行排序，vector存放pair&lt;int, int&gt;&#96;类型的数据，第二个记录次数</li><li>取出高频元素</li></ol><h2 id="最终代码Ⅰ"><a href="#最终代码Ⅰ" class="headerlink" title="最终代码Ⅰ"></a>最终代码Ⅰ</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// map&lt;int, int&gt; key:元素，value:出现频率</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">searchBST</span><span class="params">(TreeNode* cur, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; map)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">// 统计元素频率</span></span><br><span class="line">    map[cur-&gt;val]++; </span><br><span class="line">    <span class="built_in">searchBST</span>(cur-&gt;left, map);</span><br><span class="line">    <span class="built_in">searchBST</span>(cur-&gt;right, map);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="type">static</span> <span class="title">cmp</span> <span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// key:元素，value:出现频率</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map; </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">searchBST</span>(root, map);</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(map.<span class="built_in">begin</span>(), map.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 给频率排序</span></span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp); </span><br><span class="line">        result.<span class="built_in">push_back</span>(vec[<span class="number">0</span>].first);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 取最高的放到result数组中</span></span><br><span class="line">            <span class="keyword">if</span> (vec[i].second == vec[<span class="number">0</span>].second) result.<span class="built_in">push_back</span>(vec[i].first);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="二叉搜索树解法"><a href="#二叉搜索树解法" class="headerlink" title="二叉搜索树解法"></a>二叉搜索树解法</h2><p><strong>总体思路</strong></p><ol><li>既然是二叉搜索树，那么<strong>中序遍历</strong>后就是<strong>有序</strong>的</li><li>遍历有序数组的元素，计算出现频率。从头遍历，我们可以对相邻两个元素进行比较，然后输出频率最高的元素</li><li>我们可以直接在二叉树上完成(2)的操作，使用pre指针和cur指针的技巧</li></ol><h2 id="最终代码Ⅱ"><a href="#最终代码Ⅱ" class="headerlink" title="最终代码Ⅱ"></a>最终代码Ⅱ</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> maxCount = <span class="number">0</span>; <span class="comment">// 最大频率</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计频率</span></span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">searchBST</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(cur-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">                                    <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) &#123; <span class="comment">// 第一个节点</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) &#123; <span class="comment">// 与前一个节点数值相同</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 与前一个节点数值不同</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur; <span class="comment">// 更新上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == maxCount) &#123; <span class="comment">// 如果和最大值相同，放进result中</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxCount) &#123; <span class="comment">// 如果计数大于最大值频率</span></span><br><span class="line">            maxCount = count;   <span class="comment">// 更新最大频率</span></span><br><span class="line">            result.<span class="built_in">clear</span>();     <span class="comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(cur-&gt;right);      <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        maxCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>; <span class="comment">// 记录前一个节点</span></span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>壬寅九月廿六有感</title>
      <link href="/2022/10/21/%E5%A3%AC%E5%AF%85%E4%B9%9D%E6%9C%88%E5%BB%BF%E5%85%AD%E6%9C%89%E6%84%9F/"/>
      <url>/2022/10/21/%E5%A3%AC%E5%AF%85%E4%B9%9D%E6%9C%88%E5%BB%BF%E5%85%AD%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="壬寅九月廿六有感"><a href="#壬寅九月廿六有感" class="headerlink" title="壬寅九月廿六有感"></a>壬寅九月廿六有感</h1><p>望往者逝，</p><p>叹来者忧。</p><p>圣人兴教，</p><p>美人祸国，</p><p>贤者竞争流。</p><p>昨日帝王多堪忧，</p><p>奈何江山不永留。</p><p>北斗星辰寒光煞，</p><p>今日流水红花残。</p><p>五岳移形故人离，</p><p>沧海桑田花不开。</p><p>遥遥天际偏向往，</p><p>身旁红颜泪透裳。</p><p>古来圣贤不寂寞，</p><p>唯有饮者悲其名。</p><p>欲问我心归何处？</p><p>渺渺云烟白鹿间。</p>]]></content>
      
      
      <categories>
          
          <category> 诗集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树的最小绝对差</title>
      <link href="/2022/10/21/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/"/>
      <url>/2022/10/21/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li><p>二叉树搜索树的<strong>定义</strong>，反复强调如下：</p><blockquote><ul><li><p>节点的左子树只包含 小于 当前节点的数。</p></li><li><p>节点的右子树只包含 大于 当前节点的数。</p></li><li><p>所有左子树和右子树自身必须也是二叉搜索树</p></li></ul></blockquote></li><li><p>运用递归法与迭代法实现<strong>中序遍历</strong>进而将二叉树转化为<strong>有序数组</strong>，从而在此有序数组中计算数组中最小的绝对差</p></li><li><p>检测有效二叉搜索树的方法是此题的基础操作，其余的要求只是题目附加的，<strong>掌握最基本的原理与方法，可以解决一系列题目</strong></p></li></ol><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：root &#x3D; [4,2,6,1,3]<br>输出：1<br>示例 2：</p><p>输入：root &#x3D; [1,0,48,null,null,12,49]<br>输出：1</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p><img src="https://img-blog.csdnimg.cn/20201014223400123.png" alt="530二叉搜索树的最小绝对差"></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>树中节点的数目范围是 [2, 10的4次幂]</li><li>0 &lt;&#x3D; Node.val &lt;&#x3D; 10的5次幂</li></ol><hr><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a></p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="comment">// 中序遍历 中 左 右</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">        <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val); </span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">if</span> (vec.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line">        <span class="comment">// 统计有序数组的最小差值</span></span><br><span class="line">        <span class="comment">// 因为已经是有序数组了，所以只需要去比较数组中相邻元素的差就可以</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123; </span><br><span class="line">            result = <span class="built_in">min</span>(result, vec[i] - vec[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123; <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) &#123;              <span class="comment">// 中</span></span><br><span class="line">                    result = <span class="built_in">min</span>(result, cur-&gt;val - pre-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;right;               <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>验证二叉搜索树</title>
      <link href="/2022/10/20/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2022/10/20/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li><p>我们需要先认识有效二叉搜索树的定义</p><blockquote><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树<strong>自身</strong>必须也是二叉搜索树。</li></ul></blockquote></li><li><p>有效二叉搜索树的定义也是二叉搜索树的标准定义</p></li></ol><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p><img src="https://img-blog.csdnimg.cn/20210203144334501.png" alt="98.验证二叉搜索树"></p><p>提示：</p><ul><li>树中节点数目范围在<code>[1, 10的4次幂]</code> 内</li><li><code>-2的31次幂 &lt;= Node.val &lt;= 2的31次幂 - 1</code></li></ul><hr><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树 - 力扣（LeetCode）</a></p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>通过<strong>中序遍历</strong>将二叉搜索树转换为<strong>有序数组</strong>，进而直接比较值，看是否符合有效二叉搜索树的定义</li><li>比较值的过程不能想当然，必须要到位</li><li>递归法容易理解</li><li>迭代法本质上是模拟递归的过程</li></ol><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val); </span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>(); </span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 注意小于等于，等于也不二叉搜索树的条件</span></span><br><span class="line">            <span class="keyword">if</span> (vec[i] &lt;= vec[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="comment">// 记录前一个节点</span></span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>; </span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 中</span></span><br><span class="line">                cur = st.<span class="built_in">top</span>();                </span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; cur-&gt;val &lt;= pre-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//保存前一个访问的结点</span></span><br><span class="line">                pre = cur; </span><br><span class="line">    <span class="comment">// 右</span></span><br><span class="line">                cur = cur-&gt;right;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>献血小记</title>
      <link href="/2022/10/19/%E7%8C%AE%E8%A1%80%E5%B0%8F%E8%AE%B0/"/>
      <url>/2022/10/19/%E7%8C%AE%E8%A1%80%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="献血小记"><a href="#献血小记" class="headerlink" title="献血小记"></a>献血小记</h1><p>​到图书馆没多久，偶然发现辅导员发送的信息，一位学姐出了车祸，需要O型血，情况紧急。</p><p>​恰好我是O型血，我赶到校门口，发现有人哭泣，有人焦急，有人镇静，大家都不约而同地去同一个地方。</p><p>​在车上，我用易经起了一卦，卦象显示有兑金和乾金所代表的人帮助这位出事故的学姐，我的内心冷静了下来。</p><p>​献血站内外挤满了年轻的面孔，我默默地跟在他们后面填表、排队。在无聊的排队时间中，通过校园群，我得知昨天凌晨就有女生献了血（兑金代表），惊。</p><p>​献血站门口有一颗树，树干已经发黄，但树叶还翠绿着，在这金秋时节，着实有些怪异。突然，一位戴着眼镜、身穿西装的中年男性率先走出了献血站，不经意间，我发现他是我们学院的领导（乾金代表）。他潇洒走出献血站的身影，给我留下了深刻印象。</p><p>​真的猛士，敢于奉献自己的血液，敢于正视淋漓的鲜血。在献血排队的过程中，我发现了我们的老师、学长学姐、大一的许多新生。在大一新生中，有几乎全寝出动的，也有恐血的。这位恐血勇士的坚定，令人敬佩。</p><p>​到这，我觉得我有写一点东西的必要了。</p><p>​我和鲁迅先生一样，向来是不惮以最坏的恶意来推测中国人的。但这回却很有几点出于我的意外。一是学院领导竟会亲自第一时间献血，一是我们学校的女性抽血时竟如此从容，一是大一新生的奉献热情。</p><p>​呜呼，我说不出话来。</p><p>​壬寅年，戌月，廿三</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树中的搜索</title>
      <link href="/2022/10/19/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/"/>
      <url>/2022/10/19/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li><p><strong>二叉搜索树</strong>的特性</p><blockquote><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul></blockquote></li></ol><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p><p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。</p><p> <strong>示例</strong>：</p><p>例如，</p><p><img src="https://img-blog.csdnimg.cn/20210204155522476.png" alt="700.二叉搜索树中的搜索"></p><p><strong>提示</strong>：</p><ul><li>数中节点数在 [1, 5000] 范围内</li><li>1 &lt;&#x3D; Node.val &lt;&#x3D; 107</li><li>root 是二叉搜索树</li><li>1 &lt;&#x3D; val &lt;&#x3D; 107</li></ul><hr><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a></p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果找到了或没有，返回NULL</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;val == val) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* result = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 根据二叉搜索树都特性，左子树上所有值&lt;根节点&lt;右字树</span></span><br><span class="line">        <span class="comment">// 所以采用以下判断和递归</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) result = <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) result = <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为不需要回溯，所以简单，</span></span><br><span class="line">        <span class="comment">// 判断方法和递归一致</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt; val) root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; val) root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大二叉树</title>
      <link href="/2022/10/17/%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/10/17/%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li><p>务必对<strong>递归的调用</strong>有<strong>清晰</strong>的<strong>认识</strong>，否则这篇文章可能对你不太友好</p></li><li><p>最大二叉树<strong>概念</strong></p><blockquote><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><ul><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li><li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li></ul></blockquote></li><li><p>构造树的一般方法</p><blockquote><p>构造树一般采用的是前序遍历，因为树的结构决定了优先构造中间节点，然后递归构造左子树和右子树</p></blockquote></li></ol><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个不重复的整数数组 nums 。 最大二叉树可以用下面的算法从 nums 递归地构建:</p><p>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。</p><p>示例 ：</p><p><img src="https://img-blog.csdnimg.cn/20210204154534796.png" alt="654.最大二叉树"></p><p>提示：</p><ul><li>给定的数组的大小在 [1, 1000] 之间</li><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><hr><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树 - 力扣（LeetCode）</a></p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li><p>由于需要使用递归，所有<strong>递归三部曲</strong>走起</p><ul><li><p>确定递归函数的参数和返回值</p><ul><li>此处我们需要把数组传入，返回构造二叉树的头结点</li></ul></li><li><p>确定终止条件</p><ul><li><p>传入的数组大小大于1时</p></li><li><p>当传入的数组大小为1时，我们应该定义一个新的节点，并将数组的值赋给此节点，再返回此节点</p></li></ul></li><li><p>确定单层递归的逻辑</p><ol><li>先要找到数组中最大的值和对应的下标， 最大的值构造根节点，下标用来下一步分割数组</li><li>最大值所在的下标左区间，构造左子树</li><li>最大值所在的下标右区间，构造右子树</li></ol></li></ul></li><li><p>最终代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            node-&gt;val = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到数组中最大的值和对应的下标</span></span><br><span class="line">        <span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxValueIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxValue) &#123;</span><br><span class="line">                maxValue = nums[i];</span><br><span class="line">                maxValueIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;val = maxValue;</span><br><span class="line">        <span class="comment">// 最大值所在的下标左区间 构造左子树</span></span><br><span class="line">        <span class="keyword">if</span> (maxValueIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;</span><br><span class="line">            node-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最大值所在的下标右区间 构造右子树</span></span><br><span class="line">        <span class="keyword">if</span> (maxValueIndex &lt; (nums.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin() + maxValueIndex + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line">            node-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻路</title>
      <link href="/2022/10/16/%E5%AF%BB%E8%B7%AF/"/>
      <url>/2022/10/16/%E5%AF%BB%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="寻路"><a href="#寻路" class="headerlink" title="寻路"></a>寻路</h1><p>环山披雾衣，</p><p>似招云游客。</p><p>可怜雾中人，</p><p>彷徨又彷徨。</p><p>天欲掀锅盖，</p><p>迟暮已黄昏。</p><p>欲求微月光，</p><p>指明行路人。</p><p>夜深人枯坐</p><p>忽闻嬉笑声。</p><p>有情人卿卿，</p><p>无情人泣泣。</p><p>黑风卷残灯，</p><p>迷茫胜有声。</p><p>怒道路何在？</p><p>无声胜忧伤。</p>]]></content>
      
      
      <categories>
          
          <category> 诗集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心语 </tag>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找树左下角的值</title>
      <link href="/2022/10/13/%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/"/>
      <url>/2022/10/13/%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li><p>几乎所有二叉树都在重复使用<strong>递归遍历</strong>，<strong>层序遍历</strong>，不同的题目来源取决于此类算法的<strong>目的</strong></p></li><li><p>找树左下角的值，需要先理解<strong>叶子的定义</strong>，不理解的可以阅读此篇博客<a href="http://eminent-yaoyilin.com/2022/10/11/%E5%B7%A6%E5%AD%90%E5%8F%B6%E4%B9%8B%E5%92%8C/">左子叶之和 | 妖 (eminent-yaoyilin.com)</a></p></li><li><p>遍历二叉树的时候，需要<strong>找到最后一行最左边的值</strong>，这是我们此题的目的</p></li><li><p>我们这里谈谈<strong>递归三部曲</strong></p><ul><li>确定递归函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ul></li><li><p><strong>深度最大</strong>的<strong>叶子节点</strong>一定是<strong>最后一行</strong></p></li><li><p>关于<strong>深度</strong>和<strong>高度</strong>的不太熟悉定义的同学可以阅读此篇文章<a href="http://eminent-yaoyilin.com/2022/10/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/">二叉树之最大深度 | 妖 (eminent-yaoyilin.com)</a></p></li><li><p>迭代法采取<strong>层序遍历</strong>解此题简单</p></li></ol><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，在树的最后一行找到最左边的值。</p><p>示例 1:</p><p><img src="https://img-blog.csdnimg.cn/20210204152956836.png" alt="513.找树左下角的值"></p><p>示例 2:</p><p><img src="https://img-blog.csdnimg.cn/20210204153017586.png" alt="513.找树左下角的值1"></p><hr><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值 - 力扣（LeetCode）</a></p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxDepth = INT_MIN;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="comment">// 递归函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遇到叶子节点，统计最大深度</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth &gt; maxDepth) &#123;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">                result = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;left, depth);</span><br><span class="line">            depth--; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;right, depth);</span><br><span class="line">            depth--; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h2><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用队列这个辅助工具完成层序遍历</span></span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) result = node-&gt;val; <span class="comment">// 记录最后一行第一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li>代码随想录</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左子叶之和</title>
      <link href="/2022/10/11/%E5%B7%A6%E5%AD%90%E5%8F%B6%E4%B9%8B%E5%92%8C/"/>
      <url>/2022/10/11/%E5%B7%A6%E5%AD%90%E5%8F%B6%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li>左叶子的<strong>明确定义</strong>：<strong>节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么A节点的左孩子为左叶子节点</strong></li><li>务必看清上述定义</li><li><strong>递归解法</strong>与<strong>迭代解法</strong>均可，这两种解法几乎在和有关二叉树的题目中无处不在</li></ol><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>计算给定二叉树的所有左叶子之和。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20210204151927654.png" alt="404.左叶子之和1"></p><hr><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和 - 力扣（LeetCode）</a></p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li><p>因为我们是求左叶子之和，<strong>而不是二叉树左侧节点的和</strong>，所以不要想当然的使用层序遍历</p></li><li><p>根据前言中左叶子的定义，我们可知，<strong>判断左叶子必须要判断当前节点的父节点是否符合定义</strong></p></li><li><p>所以我们可知，<strong>判断左子叶</strong>的条件为：<strong>该节点的左节点不为空，并且其左节点的下一左右节点均为空</strong></p><ul><li><p>具体代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>我们使用递归的后序遍历，因为这样利于求和</p></li></ol><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这两种都属于没有左子叶</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right== <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; <span class="comment">// 就是一个左叶子</span></span><br><span class="line">            leftValue = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="comment">// 右</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = leftValue + rightValue;               <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftValue</span> <span class="operator">=</span> sumOfLeftLeaves(root.left);    <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightValue</span> <span class="operator">=</span> sumOfLeftLeaves(root.right);  <span class="comment">// 右</span></span><br><span class="line">                                                       </span><br><span class="line">        <span class="type">int</span> <span class="variable">midValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>) &#123; </span><br><span class="line">            midValue = root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> midValue + leftValue + rightValue;  <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="参考文献与推荐"><a href="#参考文献与推荐" class="headerlink" title="参考文献与推荐"></a>参考文献与推荐</h1><ol><li>代码随想录</li><li>大家可以使用迭代法完成此题</li><li>长期在leetcode上刷题的朋友，建议牛客上做做，熟悉一下全代码解题</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡二叉树</title>
      <link href="/2022/10/10/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/10/10/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li>关于二叉树里面<strong>深度与高度</strong>的问题，存在着<strong>争论</strong>的问题</li><li><strong>维基百科</strong>以边为度，<em>leetcode</em>以节点为度，但是因为我们在做<em>leetcode</em>的题，<strong>所以以<em>leetcode</em>为准</strong></li><li><strong>平衡二叉树</strong>：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1</li><li>虽然上述定义存在争议且啰嗦，但是我们还是要对这种概念清楚</li><li>解题思路依然有多种<ul><li>递归</li><li>迭代</li></ul></li></ol><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p>示例 1:</p><p>给定二叉树 [3,9,20,null,null,15,7]</p><p><img src="https://img-blog.csdnimg.cn/2021020315542230.png" alt="110.平衡二叉树"></p><p>返回 true 。</p><p>示例 2:</p><p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p><p><img src="https://img-blog.csdnimg.cn/20210203155447919.png" alt="110.平衡二叉树1"></p><p>返回 false 。</p><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树 - 力扣（LeetCode）</a></p><hr><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            result = <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="number">1</span> + <span class="built_in">max</span>(leftHeight, rightHeight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHeight</span>(root) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%A2%98%E5%A4%96%E8%AF%9D">代码随想录 (programmercarl.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秋风悲</title>
      <link href="/2022/10/08/%E7%A7%8B%E9%A3%8E%E6%82%B2/"/>
      <url>/2022/10/08/%E7%A7%8B%E9%A3%8E%E6%82%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="秋风悲"><a href="#秋风悲" class="headerlink" title="秋风悲"></a>秋风悲</h1><p>茫然心累，</p><p>噪声锤锤。</p><p>无趣之风，</p><p>自寻无味。</p><p>心灵飘荡，</p><p>万千世界，</p><p>确实流连。</p><p>被压迫着，</p><p>无情驱动，</p><p>且看门当户对，</p><p>莫笑自身不配。</p><p>何处秋风悲心肺，</p><p>欲饮天池忘情水。</p><p>问我心何向？</p><p>不知，不知，一片漆黑！</p>]]></content>
      
      
      <categories>
          
          <category> 诗集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity开始</title>
      <link href="/2022/10/08/Unity%E5%BC%80%E5%A7%8B/"/>
      <url>/2022/10/08/Unity%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity入门"><a href="#Unity入门" class="headerlink" title="Unity入门"></a>Unity入门</h1><hr><h1 id="Unity介绍"><a href="#Unity介绍" class="headerlink" title="Unity介绍"></a>Unity介绍</h1><h2 id="Unity的诞生"><a href="#Unity的诞生" class="headerlink" title="Unity的诞生"></a>Unity的诞生</h2><blockquote><p><a href="https://www.jianshu.com/p/55021d9301ab">https://www.jianshu.com/p/55021d9301ab</a></p></blockquote><h2 id="Unity干了什么"><a href="#Unity干了什么" class="headerlink" title="Unity干了什么"></a>Unity干了什么</h2><blockquote><p><a href="https://baike.baidu.com/item/Unity/10793?fr=aladdin">https://baike.baidu.com/item/Unity/10793?fr=aladdin</a></p></blockquote><h2 id="Unity发展"><a href="#Unity发展" class="headerlink" title="Unity发展"></a>Unity发展</h2><blockquote><p><a href="https://baike.baidu.com/item/Unity/10793?fr=aladdin#3">https://baike.baidu.com/item/Unity/10793?fr=aladdin#3</a></p></blockquote><h2 id="Unity职业发展和薪资待遇"><a href="#Unity职业发展和薪资待遇" class="headerlink" title="Unity职业发展和薪资待遇"></a>Unity职业发展和薪资待遇</h2><blockquote><p>找工作渠道</p><p>拉勾 Boss直聘 脉脉 校园招聘 技术社区（论坛、QQ群）</p></blockquote><h2 id="Unity独立游戏"><a href="#Unity独立游戏" class="headerlink" title="Unity独立游戏"></a>Unity独立游戏</h2><blockquote><p>关于独立游戏的定义</p><p>1、小团队开发的游戏</p><p>2、不为了赚钱的而开发的非商业游戏</p><p>3、有个人情怀和故事的游戏</p></blockquote><hr><h1 id="Unity下载和安装"><a href="#Unity下载和安装" class="headerlink" title="Unity下载和安装"></a>Unity下载和安装</h1><h2 id="Unity下载地址"><a href="#Unity下载地址" class="headerlink" title="Unity下载地址"></a>Unity下载地址</h2><blockquote><p>Unity中国官网 unity.cn</p><p>国际官网unity.com</p><p>官网：<a href="http://www.unity.com/">www.unity.com</a></p><p>GetStarted或者网页底部的Get Unity</p><p>个人版和收费版</p></blockquote><h2 id="关于网络"><a href="#关于网络" class="headerlink" title="关于网络"></a>关于网络</h2><blockquote><p>国际官网速度你懂的，但可以<strong>科学上网</strong></p></blockquote><hr><h1 id="Unity五个窗口面板（视图、窗口）"><a href="#Unity五个窗口面板（视图、窗口）" class="headerlink" title="Unity五个窗口面板（视图、窗口）"></a>Unity五个窗口面板（视图、窗口）</h1><p><strong>Project</strong>：工程面板，存放工程的各种资源。包括：声音资源、模型资源、场景文件、材质、脚本等。</p><p><strong>Hierarchy</strong>：层级面板，展示当前打开的场景里面有哪些东西。（里面的东西称为游戏物体）</p><p><strong>Inspector</strong>：检视面板（或属性面板），查看一个游戏物体由哪些组件组成。</p><blockquote><p>场景 -&gt; 多个游戏物体 -&gt; 多个组件</p></blockquote><p><strong>Scene</strong>：场景面板，显示当前场景的样子</p><blockquote><p>鼠标中键：平移视角</p><p>鼠标右键：旋转视角（环顾四周），围绕自身旋转</p><p>Alt+鼠标左键：渲染视角，围绕当前视角前方位置</p></blockquote><p><strong>Game</strong>：游戏面板，场景运行的时候的样子</p><h3 id="场景、游戏物体、组件"><a href="#场景、游戏物体、组件" class="headerlink" title="场景、游戏物体、组件"></a>场景、游戏物体、组件</h3><p>对应的英文：<strong>Scene</strong>，<strong>GameObject</strong>，<strong>Component</strong>。</p><p>场景的简单编辑操作：创建、复制、删除。</p><h3 id="Unity中的基本模型和场景操作"><a href="#Unity中的基本模型和场景操作" class="headerlink" title="Unity中的基本模型和场景操作"></a>Unity中的基本模型和场景操作</h3><p>1、如何创建基本模型和如何导入复杂模型</p><p>2、场景基本操作</p><blockquote><p>聚焦：双击游戏物体 或者 F</p><p>放大缩小视野：鼠标滚轮</p><p>围绕物体旋转：Alt+鼠标左键</p><p>使用MoveTool下 移动物体</p></blockquote><p>3、<strong>视野分类</strong></p><blockquote><p><strong>Persp</strong> 透视视野    <strong>ISO</strong>平行视野</p><p>在不同视野下：关于鼠标右键的不同</p></blockquote><p>4、<strong>保存</strong>（场景保存、代码保存）</p><blockquote><p>Ctrl + S</p></blockquote><h3 id="世界坐标系和局部坐标系"><a href="#世界坐标系和局部坐标系" class="headerlink" title="世界坐标系和局部坐标系"></a>世界坐标系和局部坐标系</h3><p><strong>坐标系</strong>：x 左右 y 上下 z前后</p><p><strong>局部坐标系</strong>：父物体和子物体</p><p><strong>单位：</strong>Unity里面的坐标是以米为单位的</p><h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><p><strong>四个工具</strong>:Q W E R</p><p><strong>Q：</strong>视图工具（使用鼠标中键可以临时切换到这个恐惧）</p><p><strong>W：</strong>移动工具</p><p><strong>E：</strong>旋转工具</p><p><strong>R：</strong>缩放工具</p><p><strong>其他工具</strong></p><blockquote><p>Rect Tool     Transform Tool      Collider Tool</p></blockquote><p><strong>切换工具</strong></p><blockquote><p>位置工具：Pivot原点 - Center中心</p><p>局部和全局坐标切换：Local - Global</p></blockquote><p><strong>步移工具</strong></p><blockquote><p>按钮</p><p>快捷键：Ctrl</p><p>条件：世界坐标系下</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Unity游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树之最大深度</title>
      <link href="/2022/10/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
      <url>/2022/10/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树之最大与最小深度"><a href="#二叉树之最大与最小深度" class="headerlink" title="二叉树之最大与最小深度"></a>二叉树之最大与最小深度</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li>二叉树节点的<strong>深度</strong>：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）</li><li>二叉树节点的<strong>高度</strong>：指从该节点到叶子节点的最长简单路径边的条数后者节点数（取决于高度从0开始还是从1开始）</li><li><strong>根节点的高度就是二叉树的最大深度</strong></li></ol><h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><hr><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例： 给定二叉树 [3,9,20,null,null,15,7]，</p><p><img src="https://img-blog.csdnimg.cn/20210203153031914.png" alt="104. 二叉树的最大深度"></p><p>返回它的最大深度 3 </p><hr><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getdepth</span><span class="params">(treenode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftdepth = <span class="built_in">getdepth</span>(node-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightdepth = <span class="built_in">getdepth</span>(node-&gt;right);     <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth); <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getdepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        queue&lt;treenode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth++; <span class="comment">// 深度记录</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                treenode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="推荐题目"><a href="#推荐题目" class="headerlink" title="推荐题目"></a>推荐题目</h1><ol><li><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度 - 力扣（LeetCode）</a></li><li>致敬Carl大佬</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对称二叉树</title>
      <link href="/2022/10/06/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/10/06/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li>不理解镜像对称的可以自己照照镜子</li><li>镜像对称可以使用<strong>折纸</strong>来理解</li><li>可以在纸上画出二叉树，通过对折理解镜像对称</li><li>二叉树的字节点可能为<code>null</code>，<strong>空节点也需要镜像对称</strong></li><li>本题使用递归法</li></ol><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，<strong>检查</strong>它是否是<strong>镜像对称</strong>的。</p><p><img src="https://img-blog.csdnimg.cn/20210203144607387.png" alt="101. 对称二叉树"></p><hr><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树 - 力扣（LeetCode）</a></p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li><p>使用<strong>递归分别</strong>遍历根节点的<strong>两个子树</strong></p></li><li><p>对两个子树的每一个节点进行判断</p><ul><li><p><strong>节点为空</strong>的情况</p><ul><li>左节点为空，右节点不为空，不对称，return false</li><li>左不为空，右为空，不对称 return false</li><li>左右都为空，对称，返回true</li></ul></li><li><p>左右节点<strong>均非空</strong>，比较值，不相等，返回false</p></li></ul></li><li><p><strong>单层递归</strong>的逻辑十分重要</p><ul><li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li><li>比较内测是否对称，传入左节点的右孩子，右节点的左孩子。</li><li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li></ul></li></ol><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先排除空节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 排除了空节点，再排除数值不相同的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时就是：左右节点都不为空，且数值相同的情况</span></span><br><span class="line">        <span class="comment">// 此时才做递归，做下一层的判断</span></span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line">        <span class="type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中 （逻辑处理）</span></span><br><span class="line">        <span class="keyword">return</span> isSame;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较外侧</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">compareOutside</span> <span class="operator">=</span> compare(left.left, right.right);</span><br><span class="line">        <span class="comment">// 比较内侧</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">compareInside</span> <span class="operator">=</span> compare(left.right, right.left);</span><br><span class="line">        <span class="keyword">return</span> compareOutside &amp;&amp; compareInside;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95">代码随想录 (programmercarl.com)</a></li><li>致敬Carl大佬</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>夜茫</title>
      <link href="/2022/10/06/%E5%A4%9C%E8%8C%AB/"/>
      <url>/2022/10/06/%E5%A4%9C%E8%8C%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="夜茫"><a href="#夜茫" class="headerlink" title="夜茫"></a>夜茫</h1><p>蓝烟夜幕，</p><p>车驰旷道，</p><p>远路黄灯，</p><p>不知多数。</p><p>抬头问天，</p><p>自身前路，</p><p>心感困茫。</p><p>车行有灯，</p><p>心向无光，</p><p>寒星何在？</p><p>孤寂无诉，</p><p>点点幽伤。</p>]]></content>
      
      
      <categories>
          
          <category> 诗集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心语 </tag>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N叉树的遍历</title>
      <link href="/2022/10/05/N%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2022/10/05/N%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="N叉树的遍历"><a href="#N叉树的遍历" class="headerlink" title="N叉树的遍历"></a>N叉树的遍历</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li>此题和之前的题目<strong>十分类似</strong>，可以使用迭代法，递归法</li><li>本篇文章使用<strong>递归法</strong></li></ol><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 n 叉树的根节点  root ，返回 其节点值的<strong>前序&#x2F;后序</strong>遍历 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p><p>示例 1：</p><p>输入：root &#x3D; [1,null,3,2,4,null,5,6]<br>输出：[1,3,5,6,2,4]</p><p>示例 2：</p><p>输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]</p><p>提示：</p><p>节点总数在范围 [0, 104]内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 104<br>n 叉树的高度小于或等于 1000</p><p>进阶：递归法很简单，你可以使用迭代法完成此题吗?</p><p>来源：LeetCode<br>链接：<a href="https://leetcode.cn/problems/n-ary-tree-preorder-traversal">https://leetcode.cn/problems/n-ary-tree-preorder-traversal</a></p><hr><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="comment">// 迭代的妙处体现的淋漓之至</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span> <span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        result.<span class="built_in">push_back</span>(root-&gt;val);<span class="comment">// 此时记录值，为前序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(root-&gt;val);<span class="comment">// 此时记录值，为后续遍历</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻转二叉树</title>
      <link href="/2022/10/04/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/10/04/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li><p>这道题目虽然简单，但背后却有一个令几乎所有程序员悲伤的故事</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">程序员巨佬Max Howell是Homebrew的作者, 某天去google面试, 面试官出了一道反转二叉树的题目, </span><br><span class="line">然而Max Howell没答上来, 最后, 就成为了一段佳话。</span><br><span class="line">Google：我们 90<span class="comment">% 的工程师都用你写的软件（Homebrew），但你没法在白板上翻转二叉树，所以滚蛋吧。</span></span><br></pre></td></tr></table></figure></li><li><p>这道题目<strong>确实非常简单</strong>，但是算法这种东西，在工作中除了算法岗，对于程序员来说几乎没有什么工作中的作用，你几乎不需要用到，但面试就必须考你！</p></li><li><p>作为一位每天编程的程序员，一旦入职不到三个月（非算法岗），算法知识几乎都会<strong>归零</strong></p></li></ol><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>翻转一棵二叉树（见下图）</p><p><img src="https://img-blog.csdnimg.cn/20210203192644329.png" alt="226.翻转二叉树"></p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li>翻转二叉树，我们只需要将每一个节点的左右孩子交换一下（”易子相食”）</li><li>使用什么遍历方式都可以，但中序遍历需要多考虑一下重复翻转的问题</li><li>我们此处使用层序遍历解答</li></ol><hr><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">swap</span>(node-&gt;left, node-&gt;right); <span class="comment">// 进行节点处理</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E8%BF%AD%E4%BB%A3%E6%B3%95">代码随想录 (programmercarl.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树层序遍历</title>
      <link href="/2022/10/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2022/10/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li>层序遍历二叉树就是<strong>从左到右一层一层</strong>的去<strong>遍历</strong>二叉数</li><li>我们使用一个队列来实现。</li><li><strong>队列先进先出，符合一层一层遍历的逻辑</strong></li><li>栈先进后出符合递归的逻辑</li><li><strong>吃透示例，可以一次性AC10个leetcode！</strong> <strong>我要打十个</strong><ul><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102.二叉树的层序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></li><li><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></li><li><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></li><li><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></li><li><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></li><li><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></li><li><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></li><li><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104.二叉树的最大深度</a></li><li><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></li></ul></li></ol><hr><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二叉树，请你返回其按层序遍历得到的节点值</p><img src="https://img-blog.csdnimg.cn/20210203144842988.png" alt="102.二叉树的层序遍历" style="zoom:80%;" /><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 只能使用固定大小的size，不能使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFun02</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        que.offer(node);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; itemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmpNode</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tmpNode.left != <span class="literal">null</span>) que.offer(tmpNode.left);</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.right != <span class="literal">null</span>) que.offer(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            resList.add(itemList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树统一迭代法</title>
      <link href="/2022/10/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95/"/>
      <url>/2022/10/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树统一迭代法"><a href="#二叉树统一迭代法" class="headerlink" title="二叉树统一迭代法"></a>二叉树统一迭代法</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li>请务必看完<a href="http://eminent-yaoyilin.com/2022/09/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E4%B8%8E%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/">二叉树的递归遍历与迭代遍历 | 妖 (eminent-yaoyilin.com)</a>此篇文章</li><li>统一迭代法相比递归遍历与迭代遍历更容易理解</li><li>强烈建议写完<strong>重复</strong>完成下列三题（至少3遍）<ul><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历</a></li></ul></li></ol><hr><h1 id="统一迭代法关键"><a href="#统一迭代法关键" class="headerlink" title="统一迭代法关键"></a>统一迭代法关键</h1><p>将访问的节点放入栈中，把要处理的节点也放入栈同时放入一个<strong>空指针</strong>进行<strong>标记</strong></p><hr><h1 id="遍历代码"><a href="#遍历代码" class="headerlink" title="遍历代码"></a>遍历代码</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line"></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.<span class="built_in">pop</span>();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.<span class="built_in">top</span>();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">            st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">            st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">            st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">            node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">            st.pop();</span><br><span class="line">            result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）         </span></span><br><span class="line">                               </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的递归遍历与迭代遍历</title>
      <link href="/2022/09/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E4%B8%8E%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/"/>
      <url>/2022/09/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E4%B8%8E%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的递归遍历与迭代遍历"><a href="#二叉树的递归遍历与迭代遍历" class="headerlink" title="二叉树的递归遍历与迭代遍历"></a>二叉树的递归遍历与迭代遍历</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="如何正确编写递归程序"><a href="#如何正确编写递归程序" class="headerlink" title="如何正确编写递归程序"></a>如何正确编写递归程序</h2><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><hr><h2 id="二叉树的两种存储方式"><a href="#二叉树的两种存储方式" class="headerlink" title="二叉树的两种存储方式"></a>二叉树的两种存储方式</h2><p><strong>二叉树既可以链式存储，又可以顺序存储。</strong></p><p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p><p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在散落在各个地址的节点串联一起。</p><p>链式存储如图：</p><p><img src="https://img-blog.csdnimg.cn/2020092019554618.png" alt="img"></p><p>链式存储是大家很熟悉的一种方式，那么我们来看看如何顺序存储呢？</p><p>其实就是用数组来存储二叉树，顺序存储的方式如图：</p><p><img src="https://img-blog.csdnimg.cn/20200920200429452.png" alt="img"></p><p>用数组来存储二叉树如何遍历的呢？</p><p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p><p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p><p><strong>所以大家要了解，用数组依然可以表示二叉树</strong></p><h2 id="二叉树的两种遍历方式"><a href="#二叉树的两种遍历方式" class="headerlink" title="二叉树的两种遍历方式"></a>二叉树的两种遍历方式</h2><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走<ul><li>前序遍历（递归法，迭代法）（中左右）</li><li>中序遍历（递归法，迭代法）（左中右）</li><li>后序遍历（递归法，迭代法）（左右中）</li></ul></li><li>广度优先遍历：一层一层的去遍历<ul><li>层次遍历（迭代法）</li></ul></li></ol><p>3.大家可以对着如下图，看看自己理解的前后中序有没有问题。</p><p><img src="https://img-blog.csdnimg.cn/20200806191109896.png" alt="img"></p><h2 id="二叉树的代码定义"><a href="#二叉树的代码定义" class="headerlink" title="二叉树的代码定义"></a>二叉树的代码定义</h2><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line">  TreeNode() &#123;&#125;</span><br><span class="line">  TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">  TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">    <span class="built_in">this</span>.val = val;</span><br><span class="line">    <span class="built_in">this</span>.left = left;</span><br><span class="line">    <span class="built_in">this</span>.right = right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><hr></li></ul><h1 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><ul><li><p>C++ </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        preorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        preorder(root.left, result);</span><br><span class="line">        preorder(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, list);</span><br><span class="line">        list.add(root.val);             <span class="comment">// 注意这一句</span></span><br><span class="line">        inorder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left, list);</span><br><span class="line">        postorder(root.right, list);</span><br><span class="line">        list.add(root.val);             <span class="comment">// 注意这一句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h1><h2 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h2><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();                       <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);           <span class="comment">// 右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);             <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h2><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123; <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>(); <span class="comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val);     <span class="comment">// 中</span></span><br><span class="line">                cur = cur-&gt;right;               <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历顺序: 左-中-右 入栈顺序： 左-右</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">               stack.push(cur);</span><br><span class="line">               cur = cur.left;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               cur = stack.pop();</span><br><span class="line">               result.add(cur.val);</span><br><span class="line">               cur = cur.right;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h2><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 空节点不入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 将结果反转之后就是左右中的顺序了</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><hr><ol><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">programmercarl.com</a></li><li>数据结构（清华大学出版社）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游萍水湖有感</title>
      <link href="/2022/09/28/%E6%B8%B8%E8%90%8D%E6%B0%B4%E6%B9%96%E6%9C%89%E6%84%9F/"/>
      <url>/2022/09/28/%E6%B8%B8%E8%90%8D%E6%B0%B4%E6%B9%96%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="游萍水湖有感"><a href="#游萍水湖有感" class="headerlink" title="游萍水湖有感"></a>游萍水湖有感</h1><p>枯黄飘叶微波粼，</p><p>风巡旷道闲者钓。</p><p>空楼冷阁无人气，</p><p>小岸疾风思绪飘。</p><p>等闲不识金秋月，</p><p>却认自身是清高！</p>]]></content>
      
      
      <categories>
          
          <category> 诗集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心语 </tag>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>晨雨</title>
      <link href="/2022/09/21/%E6%99%A8%E9%9B%A8/"/>
      <url>/2022/09/21/%E6%99%A8%E9%9B%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="晨雨"><a href="#晨雨" class="headerlink" title="晨雨"></a>晨雨</h1><pre><code>    清晨雨起，    茫茫一片。    风吹影摇，    路犹泥池，    车喧人静。    步于雨中，    徐徐而立，    前途漫漫，    不知雨起。    路犹何在？    无人说起。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 诗集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心语 </tag>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆波兰表达式</title>
      <link href="/2022/09/19/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/09/19/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="逆波兰表达式（Reverse-Polish-Notation"><a href="#逆波兰表达式（Reverse-Polish-Notation" class="headerlink" title="逆波兰表达式（Reverse Polish Notation)"></a>逆波兰表达式（<em>Reverse Polish Notation</em>)</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li><p>此篇博客共有两题，两题思路相同，完成第一题也就变相完成了第二题</p></li><li><p>逆波兰表达式在计算机计算中具有重要作用，所以以它为题</p></li><li><p>逆波兰表达式：是一种后缀表达式，所谓后缀就是指算符写在后面。<br> 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</p><p> <strong>逆波兰表达式主要有以下两个优点</strong>：</p></li></ol><ul><li>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul><hr><h1 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h1><h1 id="leetcode链接"><a href="#leetcode链接" class="headerlink" title="leetcode链接"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">leetcode链接</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>示例：</p><ul><li>输入：”abbaca”</li><li>输出：”ca”</li><li>解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; S.length &lt;&#x3D; 20000</li><li>S 仅由小写英文字母组成。</li></ul><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li>遍历字符串，遍历的同时将元素存入栈，进行比较消除</li><li>比较后的栈剩余的元素即为题目所求，只是需要再reverse</li></ol><hr><h1 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h1><ul><li><h2 id="标准解"><a href="#标准解" class="headerlink" title="标准解"></a>标准解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">char</span>&gt; s1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.<span class="built_in">empty</span>() || c != s1.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                s1.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            result = result + s1.<span class="built_in">top</span>();</span><br><span class="line">            s1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure></li><li><h2 id="优解"><a href="#优解" class="headerlink" title="优解"></a>优解</h2><p>直接将字符串作为栈，省去栈转换为字符串的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        string result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> s : S) &#123;</span><br><span class="line">            <span class="keyword">if</span>(result.<span class="built_in">empty</span>() || result.<span class="built_in">back</span>() != s) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h1><h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">leetcode</a></h1><h1 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h1><p>示例 1：</p><ul><li>输入: [“2”, “1”, “+”, “3”, “ * “]</li><li>输出: 9</li><li>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</li></ul><p>示例 2：</p><ul><li>输入: [“4”, “13”, “5”, “&#x2F;“, “+”]</li><li>输出: 6</li><li>解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</li></ul><p>示例 3：</p><ul><li><p>输入: [“10”, “6”, “9”, “3”, “+”, “-11”, “ * “, “&#x2F;“, “ * “, “17”, “+”, “5”, “+”]</p></li><li><p>输出: 22</p></li><li><p>解释:该算式转化为常见的中缀算术表达式为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((10 * (6 / ((9 + 3) * -11))) + 17) + 5       </span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5       </span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5     </span><br><span class="line">= ((10 * 0) + 17) + 5     </span><br><span class="line">= (0 + 17) + 5    </span><br><span class="line">= 17 + 5    </span><br><span class="line">= 22    </span><br></pre></td></tr></table></figure></li></ul><h1 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h1><p><strong>基本和上一题一致，只是匹配到的消除操作，变成了运算操作，再压入栈</strong></p><hr><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意：运算过程中会出现超出int范围的数字，所以使用long类型</span></span><br><span class="line">        stack&lt;<span class="type">long</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tokens.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span> || tokens[i] == <span class="string">&quot;-&quot;</span> || tokens[i] == <span class="string">&quot;*&quot;</span> || tokens[i] == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="type">long</span> num1 = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">long</span> num2 = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span>) s.<span class="built_in">push</span>(num2 + num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;-&quot;</span>) s.<span class="built_in">push</span>(num2 - num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;*&quot;</span>) s.<span class="built_in">push</span>(num2 * num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;/&quot;</span>) s.<span class="built_in">push</span>(num2 / num1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> result  = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="关于stoi"><a href="#关于stoi" class="headerlink" title="关于stoi()"></a>关于<code>stoi()</code></h1><p><a href="https://blog.csdn.net/qq_51325797/article/details/122674222">stoi()函数的讲解</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效的括号</title>
      <link href="/2022/09/15/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
      <url>/2022/09/15/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">leetcode</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。<br>示例 1:</p><p>输入: “()”<br>输出: true<br>示例 2:</p><p>输入: “()[]{}”<br>输出: true<br>示例 3:</p><p>输入: “(]”<br>输出: false<br>示例 4:</p><p>输入: “([)]”<br>输出: false<br>示例 5:</p><p>输入: “{[]}”<br>输出: true</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li><p>区分匹配和不匹配的情况</p><ul><li>第一种不匹配情况：字符串里左方向的括号多余</li><li>第二种不匹配情况：括号没有多余，但是括号的类型没有匹配</li><li>第三种不匹配情况：字符串里右方向的括号多余</li></ul></li><li><p>利用栈的数据结构可以高效完成匹配问题</p></li></ol> <hr><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 字符串长度为奇数时，一定不符合要求</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; s1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 将左方向括号转换为右方向括号</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) s1.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) s1.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) s1.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="comment">// 此时s中左括号已经全部转换为右括号，并已经全部被压入栈，需要去匹配s剩余的所有右括号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s1.<span class="built_in">empty</span>() || s1.<span class="built_in">top</span>() != s[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> s1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用队列实现栈</title>
      <link href="/2022/09/15/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <url>/2022/09/15/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h1><h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">leetcode</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>使用队列实现栈的下列操作：</p><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li>可以使用两个队列</li><li>也可以使用一个队列，我们在此只讲述双队列<ul><li>当使用队列实现栈时，另一个队列发挥着<strong>临时存储</strong>的作用</li><li><strong>队列先进先出</strong>和<strong>栈先进后出</strong>的特性要理解</li></ul></li></ol><hr><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; queueOne;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; queueTwo;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        queueOne.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = queueOne.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 为了在queueOne中留下一个</span></span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">            <span class="comment">// 将queueOne的数据全部临时存储到queueTwo中</span></span><br><span class="line">            queueTwo.<span class="built_in">push</span>(queueOne.<span class="built_in">front</span>());</span><br><span class="line">            queueOne.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="type">int</span> result = queueOne.<span class="built_in">front</span>();</span><br><span class="line">        queueOne.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 将queueTwo赋值给queueOne</span></span><br><span class="line">        queueOne = queueTwo;</span><br><span class="line">        <span class="comment">// 清空queueTwo</span></span><br><span class="line">        <span class="keyword">while</span> (!queueTwo.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            queueTwo.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queueOne.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queueOne.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用栈实现队列</title>
      <link href="/2022/09/13/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2022/09/13/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h1><h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">leetcode</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>使用栈实现队列的下列操作：</p><p>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li>利用队列 “先进先出” 的特性和栈 “先进后出” 的特性实现相应的函数</li><li>注意<code>pop()</code>细节</li><li>实现<code>empty()</code>时，需要同时判断两个栈</li></ol><hr><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stackIn;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stackOut;</span><br><span class="line"><span class="comment">// 初始化数据结构</span></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        stackIn.<span class="built_in">push</span>(x);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackOut.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// stackIn stackOut都需要考虑，结合队列的特性</span></span><br><span class="line">            <span class="keyword">while</span> (!stackIn.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                stackOut.<span class="built_in">push</span>(stackIn.<span class="built_in">top</span>());</span><br><span class="line">                stackIn.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = stackOut.<span class="built_in">top</span>();</span><br><span class="line">        stackOut.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        stackOut.<span class="built_in">push</span>(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackIn.<span class="built_in">empty</span>() &amp;&amp; stackOut.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现strStr()</title>
      <link href="/2022/09/08/%E5%AE%9E%E7%8E%B0strStr/"/>
      <url>/2022/09/08/%E5%AE%9E%E7%8E%B0strStr/</url>
      
        <content type="html"><![CDATA[<h1 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li><p>本题为<em>KMP</em>经典题目</p></li><li><p>本题使用的与KMP相关的知识建议观看下列视频</p><ul><li><a href="https://www.bilibili.com/video/BV1PD4y1o7nd/">帮你把KMP算法学个通透！B站（理论篇）</a></li></ul></li><li><p>本题要好好体会，好好参悟，一次做不出，没事，可以再被<strong>虐</strong>一次！</p></li><li><p>由于我已经推荐学习视频，解题思路<strong>略</strong>！</p></li><li><p>本题<strong>滑动窗口</strong>的解法<strong>容易理解</strong></p></li></ol><h1 id="LeetCode链接"><a href="#LeetCode链接" class="headerlink" title="LeetCode链接"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">LeetCode链接</a></h1><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现 strStr() 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p><p>示例 1: 输入: haystack &#x3D; “hello”, needle &#x3D; “ll” 输出: 2</p><p>示例 2: 输入: haystack &#x3D; “aaaaa”, needle &#x3D; “bba” 输出: -1</p><p><strong>注意</strong>：当<code>needle</code>是空字符串时，我们应当返回0。这与C语言的<code>strstr()</code>以及Java的<code>indexOf()</code>定义符合</p><hr><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><ul><li><p>C++ KMP套路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// getNext运用前缀表的操作最好背诵+理解</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> next[needle.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(next, needle);</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">                <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Java 滑动窗口（<strong>容易理解</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> needle.length();</span><br><span class="line">        <span class="comment">// 当 needle 是空字符串,要返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n - m + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 发现首字母相等</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; haystack.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">                <span class="comment">// 发现没有首字母相等的</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历后续字符，判断是否相等</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m &amp;&amp; haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到</span></span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 未找到</span></span><br><span class="line">                i -= j - <span class="number">1</span>;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左旋装字符串</title>
      <link href="/2022/09/08/%E5%B7%A6%E6%97%8B%E8%A3%85%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/09/08/%E5%B7%A6%E6%97%8B%E8%A3%85%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="左旋装字符串"><a href="#左旋装字符串" class="headerlink" title="左旋装字符串"></a>左旋装字符串</h1><hr><h1 id="leetcode链接"><a href="#leetcode链接" class="headerlink" title="leetcode链接"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">leetcode链接</a></h1><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p>示例 1：<br>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “cdefgab”</p><p>示例 2：<br>输入: s &#x3D; “lrloseumgh”, k &#x3D; 6<br>输出: “umghlrlose”</p><p>限制：<br>1 &lt;&#x3D; k &lt; s.length &lt;&#x3D; 10000</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li>通过整体反转+局部反转，一定要画图举例去理解</li><li>反转 “区间为前n的子串”</li><li>反转 “区间为n到末尾的子串”</li><li>反转 “整个字符串”</li></ol><hr><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ol><li><code>reverse()</code>的操作的区间是<strong>左闭右开</strong></li><li><code>StringBuilder</code>作为中间载体，相比其它的数据结构，更容易完成字符串的增删操作，因为它<strong>不涉及公共池</strong></li></ol><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + n);</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + n, s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 我们通常会使用StringBuilder作为载体去完成字符串增删改的操作</span></span><br><span class="line">        <span class="type">int</span> len=s.length();</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">        reverseString(sb,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">        reverseString(sb,n,len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(StringBuilder sb, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">         <span class="comment">// 此处使用for循环也可</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转字符串中的单词</title>
      <link href="/2022/09/08/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
      <url>/2022/09/08/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h1><hr><h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">leetcode</a></h1><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：<br>输入: “a good  example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li><p>移除字符串中的多余空格</p><ul><li><p>解法一(参考《代码随想录》)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> slowIndex = <span class="number">0</span>, fastIndex = <span class="number">0</span>; <span class="comment">// 定义快指针，慢指针</span></span><br><span class="line">    <span class="comment">// 去掉字符串前面的空格</span></span><br><span class="line">    <span class="keyword">while</span> (s.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; fastIndex &lt; s.<span class="built_in">size</span>() &amp;&amp; s[fastIndex] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        fastIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; fastIndex &lt; s.<span class="built_in">size</span>(); fastIndex++) &#123;</span><br><span class="line">        <span class="comment">// 去掉字符串中间部分的冗余空格</span></span><br><span class="line">        <span class="keyword">if</span> (fastIndex - <span class="number">1</span> &gt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; s[fastIndex - <span class="number">1</span>] == s[fastIndex]</span><br><span class="line">                &amp;&amp; s[fastIndex] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s[slowIndex++] = s[fastIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowIndex - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; s[slowIndex - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">// 去掉字符串末尾的空格</span></span><br><span class="line">        s.<span class="built_in">resize</span>(slowIndex - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s.<span class="built_in">resize</span>(slowIndex); <span class="comment">// 重新设置字符串大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法二</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123; </span><br><span class="line">         <span class="comment">//遇到非空格就处理，即删除所有空格</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// slow != 0说明不是第一个单词，需要在单词前添加空格</span></span><br><span class="line">            <span class="keyword">if</span> (slow != <span class="number">0</span>) s[slow++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//给单词之间添加空格</span></span><br><span class="line">            <span class="comment">// 补上该单词，遇到空格说明单词结束</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123; </span><br><span class="line">                s[slow++] = s[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//slow的大小即为去除多余空格后的大小</span></span><br><span class="line">    s.<span class="built_in">resize</span>(slow); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>将整个字符串反转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将每个单词反转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">removeExtraSpaces</span>(s); <span class="comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span></span><br><span class="line">       <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">       <span class="type">int</span> start = <span class="number">0</span>; <span class="comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() || s[i] == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span></span><br><span class="line">               <span class="built_in">reverse</span>(s, start, i - <span class="number">1</span>); <span class="comment">//翻转，注意是左闭右闭 []的翻转。</span></span><br><span class="line">               start = i + <span class="number">1</span>; <span class="comment">//更新下一个单词的开始下标start</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> s;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) &#123;</span><br><span class="line">                    s[slow++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeExtraSpaces</span>(s);</span><br><span class="line">        <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() || s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s, start, i<span class="number">-1</span>);</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://programmercarl.com/">代码随想录 (programmercarl.com)</a>)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈学习</title>
      <link href="/2022/09/07/%E8%B0%88%E8%B0%88%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/09/07/%E8%B0%88%E8%B0%88%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="谈谈学习"><a href="#谈谈学习" class="headerlink" title="谈谈学习"></a>谈谈学习</h1><hr><h1 id="我认为的学习"><a href="#我认为的学习" class="headerlink" title="我认为的学习"></a>我认为的学习</h1><p>​       学习是一个输入的过程，同时它也是一个输出的过程。</p><p>​学习最终的话是一种记忆。</p><p>​学的东西最终都要转化为一种知识存储到你的大脑，最后当你在运用的时候可以准确的回忆提取出来。</p><p>​学习这两个字包括了学和习。学就是从不会到会这个过程。它永远是一种将生疏的、陌生的转化为自己的、熟悉的，能够运用和掌握的过程。学完之后，是习，修习。你需要把学到的知识，进行深入的钻研，达到一种更高的境界。</p><p>​人在学习的过程中永远是和外物进行交互，人与自己的交互是属于脑海中知识存储和处理的一部分。</p><p>​但是世界上万物都是在不断发展和变化的，知识永远是在更新的，而人的生命却是有限的。人在学习的过程中肯定会遇到一些对自己来说是非常晦涩的书，我认为，这并不是人自己的问题，而是书的问题。因为学习是一个针对你的问题，你自己的学习是针对于你而言的，所以你学完这本书之后发现自己知识没有增长多少，那就说明这本书就你而言无用。外物相对于人自身而言，它仅仅是一种外在的东西，人最终通过学习是要达到一种将外物外化为心（输入），内化为行（输出）的一个过程。把外在的化为自己的最后一定是给自己去使用，所以我们要”能知万物备于我，肯把三才别立根”，以我为主、为我所用。达到这种境界的话才能说是学习，学习是一个非常灵活的过程。他并不一定是像人去吃饭一样，可以很仓促的就把它吃完，它是一个需要进食并进行消化的过程，一定要把它真正的完全的焊在自己的脑子里。在脑海中光有这些知识还不够，最后还要达到自己能够输出的界限，这才叫学习。所以从本质上来说，学习就是增强输入，把握输出，最后去巩固脑海中存储并提取知识的能力的过程。</p><p>​学习不单纯是麻木自己的事情，更是一种人类在物质上满足社会更替的需求的行为，但它最终能够在精神世界上去满足人，最后还能反馈于物质世界。</p><hr><h1 id="我认为的学习效率"><a href="#我认为的学习效率" class="headerlink" title="我认为的学习效率"></a>我认为的学习效率</h1><p>​我们可以发现这个问题。比如在我们去背诵四六级单词的时候，我们会发现，关于一些单词我们是背了就遗忘，遗忘了就需要再去背，但在当时我们确实把这些单词记得非常牢固。一到考试的时候，我们很可能会出现“单词认识我们，我们却不认识单词”的尴尬情形，最后，我们可能会想起这个单词到底是什么意思，但是这个反应却不是立刻的，而是有一定延迟的，甚至是只留下一丝印象。这就说明我们人类在大多数学习上都是浅度的。根据科学分析，深度的学习，就中国人背诵99乘法表而言，这种深度的学习是建立在我们通过不断的使用、不断的使用的基础之上的。所以学习也是一个重复的过程。</p><p>​但人类的生命是有限的，我们必须要想办法去减少重复的过程，去开拓更为高效的学习。我们之前已经谈过学习是需要有输入，并最后是要用于输出的。为什么输出可以强化学习的效果呢？因为输出会去强迫我们的大脑去提取存储的知识。提取的越多，我们去大脑去提取这部分相应的知识的时候就会越迅速，我们在这部分知识上的熟练度也会增加，这也和“古代逛青楼，一回生，二回熟一样啊”。但是人类的天性是懒惰的，一旦经历了相当的长的时间的话，大多数人就会感到“疲倦”或“厌倦”，所以我们要为自己的学习去找到自己的方法。我们要激励我们的大脑去学习，要激励我们的身心去学习，这不仅需要有一具强健的身体，需要有细致的心灵，心有猛虎，细嗅蔷薇。身体不行，学习自然不行；身体行，学习却不一定行。另外我发现，我们人类在学习的过程中，有很多东西是需要我们用经验去积累的。比如：在使用数学上，高等数学上很多公式之间的结构以及这种解题思路，很多都是需要我们通过大量的做题去积累相应的经验，这部分经验在解题的时候会给我们很大的鼓舞，更多时候都会给我们一种灵感，这种东西呢也是通过学习学到的。做题的时候其实是一种强度比较大的学习，我们在不断的进行输入和输出，也在时时调用并更新我们自己的知识库。</p><p>​大脑的记忆确实是一个非常神奇的东西，我们对很多知识的感悟以及理解很可能转瞬即逝，但是这却并不会影响我们之后的学习，它会给我们留下“伏笔”，这可能就是我们所谓的灵感吧。所以我认为，灵感也是可以培训出来的。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>替换空格</title>
      <link href="/2022/09/06/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>/2022/09/06/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><h2 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">leetcode</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1： 输入：s &#x3D; “We are happy.”<br>输出：”We%20are%20happy.”</p><hr><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>首先可以根据空格数扩充数组，将数组总长度调整</li><li>利用双指针法重新填充数组，使之达到题目要求</li></ol><ul><li>C++常用的库函数需要知道如何使用，<code>resize()</code></li><li>Java的StringBuilder类的特性有时有奇效</li><li>双指针替换的操作要熟练</li></ul><hr><h2 id="具体解题代码"><a href="#具体解题代码" class="headerlink" title="具体解题代码"></a>具体解题代码</h2><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计空格数量</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> oldSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 调整数组大小</span></span><br><span class="line">        s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + count*<span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> newSize = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 使用双指针填充数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = newSize - <span class="number">1</span>, j = oldSize - <span class="number">1</span>; j &lt; i; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                s[i] = s[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[i<span class="number">-1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[i<span class="number">-2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 优先处理特殊情况</span></span><br><span class="line">       <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> s;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// StringBuilder的使用需要熟悉</span></span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">               str.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> s;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 调整字符串大小</span></span><br><span class="line">       s += str.toString();</span><br><span class="line">       <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 填充时，将String类转换为字符数组</span></span><br><span class="line">       <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="comment">// 双指针填充</span></span><br><span class="line">       <span class="keyword">while</span>(left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (chars[left] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">               chars[right--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">               chars[right--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">               chars[right] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               chars[right] = chars[left];</span><br><span class="line">           &#125;</span><br><span class="line">           left--;</span><br><span class="line">           right--;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">// 细节，需要转换为String类返回</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转字符串</title>
      <link href="/2022/09/05/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/09/05/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="反转字符串I"><a href="#反转字符串I" class="headerlink" title="反转字符串I"></a>反转字符串I</h1><h2 id="力扣题目链接"><a href="#力扣题目链接" class="headerlink" title="力扣题目链接"></a><a href="https://leetcode.cn/problems/reverse-string/">力扣题目链接</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><p>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li><p>直接使用C++&#x2F;Java库函数<code>reverse()</code>可以直接达到题目要求</p></li><li><p>自定义函数实现相应功能</p><ul><li><p>使用双指针，分别从数组首地址开始和数组末尾开始，相向移动并进行互换</p></li><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>()/<span class="number">2</span>; i++, j--) &#123;</span><br><span class="line">        <span class="comment">// swap() 交换值，也可以使用位运算交换值</span></span><br><span class="line">        <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            s[l] ^= s[r];  <span class="comment">//构造 a ^ b 的结果，并放在 a 中</span></span><br><span class="line">            s[r] ^= s[l];  <span class="comment">//将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b</span></span><br><span class="line">            s[l] ^= s[r];  <span class="comment">//a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换</span></span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr></li></ol><h1 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h1><h2 id="力扣题目链接-1"><a href="#力扣题目链接-1" class="headerlink" title="力扣题目链接"></a><a href="https://leetcode.cn/problems/reverse-string-ii/">力扣题目链接</a></h2><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p><p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>示例:</p><p>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “bacdfeg”</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li><p>遍历字符串的过程中，让 <code>i = i + (2 * k)</code>，i 每次移动<code>2 * k</code>，然后判断是否需要有反转的区间。</p><p>因为我们只需要找到每个2 * k 区间的<strong>起点</strong></p></li></ol><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += (<span class="number">2</span> * k)) &#123;</span><br><span class="line">            <span class="comment">// 通过 i + k 判断 （1）和 （2）</span></span><br><span class="line">            <span class="comment">// （1）. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">            <span class="comment">// （2）. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// (3) 进行收尾操作</span></span><br><span class="line">                <span class="comment">// （3）. 剩余字符少于 k 个，则将剩余字符全部反转。</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; ch.length; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">            <span class="comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= ch.length) &#123;</span><br><span class="line">                reverse(ch, i, i + k -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转</span></span><br><span class="line">            reverse(ch, i, ch.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义翻转函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] ch, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; j; i++, j--) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span>  <span class="operator">=</span> ch[i];</span><br><span class="line">        ch[i] = ch[j];</span><br><span class="line">        ch[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近日的状况</title>
      <link href="/2022/08/26/%E8%BF%91%E6%97%A5%E7%9A%84%E7%8A%B6%E5%86%B5/"/>
      <url>/2022/08/26/%E8%BF%91%E6%97%A5%E7%9A%84%E7%8A%B6%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="大一下暑假Android培训后的状况"><a href="#大一下暑假Android培训后的状况" class="headerlink" title="大一下暑假Android培训后的状况"></a>大一下暑假Android培训后的状况</h1><ol><li>骨折住院后我打开了一扇新的大门，《梅花易数》已经入门</li><li>《心易》也读完了，建立了较为完善的世界观和方法论</li><li>准备考教师资格证</li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android IO</title>
      <link href="/2022/08/01/Android-IO/"/>
      <url>/2022/08/01/Android-IO/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-IO"><a href="#Android-IO" class="headerlink" title="Android_IO"></a>Android_IO</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li>App管理的文件路径<code>cacheDir</code>,<code>fileDir</code>，不需要权限</li><li>对于手机的SD卡，可以通过<code>getExternalStorage</code>（获取外部存储路径）访问文件</li><li>创建文件需要先确定被创建的文件的路径（<em>path</em>)</li><li>自己通过代码的创建的文件以及目录均可以使用Android Studio连接手机运行app后在Device File Explorer中的data下的data对应的app中找到</li><li>与输入输出文件相关内容可见我之前写的《Java输入输出流》这篇文章</li></ol><hr><h1 id="创建文件与目录（文件夹）"><a href="#创建文件与目录（文件夹）" class="headerlink" title="创建文件与目录（文件夹）"></a>创建文件与目录（文件夹）</h1><h2 id="cacheDir下创建⼀个⽂件"><a href="#cacheDir下创建⼀个⽂件" class="headerlink" title="cacheDir下创建⼀个⽂件"></a><em>cacheDir</em>下创建⼀个⽂件</h2><ol><li><p>获取被创建文件上一级文件的路径（<em>path</em>)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cachePath = cacheDir.path</span><br></pre></td></tr></table></figure></li><li><p>拼接文件的完整路径</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> filePath = <span class="string">&quot;<span class="subst">$&#123;cachePath&#125;</span>/1.jpg&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>创建文件对应的file对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> file = File(filePath)</span><br></pre></td></tr></table></figure></li><li><p>创建文件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">    file.delete()</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(file.createNewFile()) &#123;</span><br><span class="line">                Log.v(<span class="string">&quot;yyl&quot;</span>, <span class="string">&quot;create file ok&quot;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                Log.v(<span class="string">&quot;yyl&quot;</span>, <span class="string">&quot;create file failed&quot;</span>)</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="filesDir下创建⼀个⽂件"><a href="#filesDir下创建⼀个⽂件" class="headerlink" title="filesDir下创建⼀个⽂件"></a><em>filesDir</em>下创建⼀个⽂件</h2><ol><li><p>获取文件对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> file = File(filesDir, <span class="string">&quot;2.jpg&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>创建文件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> file = File(filesDir, <span class="string">&quot;2.png&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            file.delete()</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.createNewFile()) &#123;</span><br><span class="line">                Log.v(<span class="string">&quot;yyl&quot;</span>, <span class="string">&quot;successful&quot;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                Log.v(<span class="string">&quot;yyl&quot;</span>, <span class="string">&quot;error&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="mkdirs创建多级⽬录"><a href="#mkdirs创建多级⽬录" class="headerlink" title="mkdirs创建多级⽬录"></a><em>mkdirs</em>创建多级⽬录</h2><p>代码示例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name = <span class="string">&quot;image&quot;</span></span><br><span class="line">        <span class="keyword">val</span> mindir = File(filesDir, <span class="string">&quot;<span class="variable">$name</span>/min_thumbnail&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> middle_dir = File(filesDir, <span class="string">&quot;<span class="variable">$name</span>/middle_thumbnail&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> org_dir = File(filesDir, <span class="string">&quot;<span class="variable">$name</span>/org_thumbnail&quot;</span>)</span><br><span class="line"></span><br><span class="line">        mindir.mkdir()</span><br><span class="line">        middle_dir.mkdir()</span><br><span class="line">        org_dir.mkdir()</span><br></pre></td></tr></table></figure><hr><h1 id="获取目录与文件"><a href="#获取目录与文件" class="headerlink" title="获取目录与文件"></a>获取目录与文件</h1><h2 id="list-获取⽬录下所有⽂件的名称（⽂件和⽬录）"><a href="#list-获取⽬录下所有⽂件的名称（⽂件和⽬录）" class="headerlink" title="list() 获取⽬录下所有⽂件的名称（⽂件和⽬录）"></a><code>list()</code> 获取⽬录下所有⽂件的名称（⽂件和⽬录）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filesDir.list().forEach &#123;</span><br><span class="line">            Log.v(<span class="string">&quot;yyl&quot;</span>, it)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="list-FileNameFilter-过滤满⾜条件的⽂件"><a href="#list-FileNameFilter-过滤满⾜条件的⽂件" class="headerlink" title="list(FileNameFilter)过滤满⾜条件的⽂件"></a><code>list(FileNameFilter)</code>过滤满⾜条件的⽂件</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jpgFiles = filesDir.list &#123; dir, name -&gt;</span><br><span class="line">            name.endsWith(<span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">jpgFiles.forEach &#123;</span><br><span class="line">            Log.v(<span class="string">&quot;yyl&quot;</span>, it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="输入输出操作部分"><a href="#输入输出操作部分" class="headerlink" title="输入输出操作部分"></a>输入输出操作部分</h1><h2 id="字符读写"><a href="#字符读写" class="headerlink" title="字符读写"></a>字符读写</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> path = <span class="string">&quot;<span class="subst">$&#123;filesDir.path&#125;</span>/我的靓照/小说.txt&quot;</span></span><br><span class="line">        <span class="keyword">val</span> infile = File(path)</span><br><span class="line">        <span class="keyword">val</span> fileReader = FileReader(infile)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建文件 写入字符串</span></span><br><span class="line">        <span class="keyword">val</span> file = File(filesDir, <span class="string">&quot;abc.txt&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">            Log.v(<span class="string">&quot;pxd&quot;</span>,<span class="string">&quot;文件存在&quot;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            file.createNewFile()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建字符输出流</span></span><br><span class="line">        <span class="keyword">val</span> fileWriter = FileWriter(file)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> buffer = CharArray(<span class="number">1024</span>) <span class="comment">// 一次读取1024byte</span></span><br><span class="line">        <span class="keyword">var</span> len = fileReader.read(buffer,<span class="number">0</span>,<span class="number">1024</span>) <span class="comment">// 起始位置为0，长度为1024</span></span><br><span class="line">        <span class="keyword">while</span> (len != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//使用writer写到文件里面去，直到读完</span></span><br><span class="line">            fileWriter.write(buffer,<span class="number">0</span>,len)</span><br><span class="line">            len = fileReader.read(buffer,<span class="number">0</span>,<span class="number">1024</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fileWriter.flush()<span class="comment">// 使用缓冲可以充分输出缓存的数据</span></span><br><span class="line">        fileReader.close()</span><br><span class="line">        fileWriter.close()</span><br></pre></td></tr></table></figure><h2 id="图⽚移动"><a href="#图⽚移动" class="headerlink" title="图⽚移动"></a>图⽚移动</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> srcPath = <span class="string">&quot;<span class="subst">$&#123;filesDir.path&#125;</span>/scene.jpeg&quot;</span></span><br><span class="line">   <span class="keyword">val</span> fis = FileInputStream(srcPath)</span><br><span class="line">   <span class="comment">//创建输出字节流</span></span><br><span class="line">   <span class="keyword">val</span> destPath = <span class="string">&quot;<span class="subst">$&#123;filesDir.path&#125;</span>/android/scene3.jpeg&quot;</span></span><br><span class="line">   <span class="keyword">val</span> fos = FileOutputStream(destPath)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> buffer = ByteArray(<span class="number">1024</span>)</span><br><span class="line">   <span class="keyword">var</span> len = fis.read(buffer,<span class="number">0</span>,<span class="number">1024</span>)</span><br><span class="line">   <span class="keyword">while</span> (len != -<span class="number">1</span>)&#123;</span><br><span class="line">       fos.write(buffer,<span class="number">0</span>,len)</span><br><span class="line">       len = fis.read(buffer,<span class="number">0</span>,<span class="number">1024</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   fos.flush()</span><br><span class="line">   fis.close()</span><br><span class="line">   fos.close()</span><br><span class="line"></span><br><span class="line">   File(srcPath).delete()</span><br></pre></td></tr></table></figure><h2 id="file的图⽚显示到imageView"><a href="#file的图⽚显示到imageView" class="headerlink" title="file的图⽚显示到imageView"></a>file的图⽚显示到imageView</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> iv = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> uri = Uri.parse(<span class="string">&quot;<span class="subst">$&#123;filesDir.path&#125;</span>/android/scene2.jpeg&quot;</span>)</span><br><span class="line">   iv.setImageURI(uri)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//file -&gt;Bitmap</span></span><br><span class="line">   <span class="keyword">val</span> bitmap = BitmapFactory.decodeFile(</span><br><span class="line">       <span class="string">&quot;<span class="subst">$&#123;filesDir.path&#125;</span>/android/scene2.jpeg&quot;</span>)</span><br><span class="line">   iv.setImageBitmap(bitmap)</span><br></pre></td></tr></table></figure><h2 id="缓冲流读写视频"><a href="#缓冲流读写视频" class="headerlink" title="缓冲流读写视频"></a>缓冲流读写视频</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bis:BufferedInputStream? = <span class="literal">null</span></span><br><span class="line">   <span class="keyword">var</span> bos:BufferedOutputStream? = <span class="literal">null</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">val</span> srcPath = <span class="string">&quot;<span class="subst">$&#123;filesDir.path&#125;</span>/dev.mp4&quot;</span></span><br><span class="line">       <span class="keyword">val</span> fis = FileInputStream(srcPath)</span><br><span class="line">       bis = BufferedInputStream(fis)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">val</span> destPath = <span class="string">&quot;<span class="subst">$&#123;filesDir.path&#125;</span>/android/dev2.mp4&quot;</span></span><br><span class="line">       <span class="keyword">val</span> fos = FileOutputStream(destPath)</span><br><span class="line">       bos = BufferedOutputStream(fos)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">val</span> buffer = ByteArray(<span class="number">1024</span>)</span><br><span class="line">       <span class="keyword">var</span> len = bis.read(buffer, <span class="number">0</span>, <span class="number">1024</span>)</span><br><span class="line">       <span class="keyword">while</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">           bos.write(buffer, <span class="number">0</span>, len)</span><br><span class="line">           len = bis.read(buffer, <span class="number">0</span>, <span class="number">1024</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       fos.flush()</span><br><span class="line">   &#125;<span class="keyword">catch</span> (e: Exception)&#123;</span><br><span class="line">       e.printStackTrace()</span><br><span class="line">   &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">       bos?.close()</span><br><span class="line">       bis?.close()</span><br><span class="line">   &#125;</span><br><span class="line">   Log.v(<span class="string">&quot;pxd&quot;</span>,<span class="string">&quot;<span class="subst">$&#123;System.currentTimeMillis()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="advanced用法"><a href="#advanced用法" class="headerlink" title="advanced用法"></a>advanced用法</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> srcPath = <span class="string">&quot;<span class="subst">$&#123;filesDir.path&#125;</span>/dev.mp4&quot;</span></span><br><span class="line">        FileInputStream(srcPath).use &#123; fis -&gt;</span><br><span class="line">            <span class="keyword">val</span> destPath = <span class="string">&quot;<span class="subst">$&#123;filesDir.path&#125;</span>/android/dev2.mp4&quot;</span></span><br><span class="line">            FileOutputStream(destPath).use &#123; fos -&gt;</span><br><span class="line">                <span class="keyword">val</span> buffer = ByteArray(<span class="number">1024</span>)</span><br><span class="line">                <span class="keyword">var</span> len = fis.read(buffer,<span class="number">0</span>,<span class="number">1024</span>)</span><br><span class="line">                <span class="keyword">while</span> (len != -<span class="number">1</span>)&#123;</span><br><span class="line">                    fos.write(buffer,<span class="number">0</span>,len)</span><br><span class="line">                    len = fis.read(buffer,<span class="number">0</span>,<span class="number">1024</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android动画</title>
      <link href="/2022/07/26/Android%E5%8A%A8%E7%94%BB/"/>
      <url>/2022/07/26/Android%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-animation"><a href="#Android-animation" class="headerlink" title="Android animation"></a>Android animation</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>动画尽量不要在onCreate中启动，因为此时界面布局都还没有完成，你看到的动画是残缺的</li><li>如遇到不清楚的类或属性，建议看优质的博客</li></ul><hr><h1 id="帧动画-FrameAnimation"><a href="#帧动画-FrameAnimation" class="headerlink" title="帧动画( FrameAnimation)"></a>帧动画( <em>FrameAnimation</em>)</h1><p>帧动画就是顺序播放一组预先定义好的图片，就类似于我们观看视频，就是一张一张的图片连续播放</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ol><li><p>res下drawable包内准备图片资源</p></li><li><p>drawable内创建animation-list的xml文件，里面使用<code>&lt;item&gt;</code>存放动画图片资源，设置duration控制每一帧图片显示时间，<strong>具体是</strong>在 xml中设置要播放帧动画的图片资源，持续时间，播放属性</p></li><li><p>父容器布局文件中加入一个ImageView，运用src属性配置animation-list文件，建立关联</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--示例--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/campfire01&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/campfire02&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>注意：每个item都有Drawable和duration属性，Drawable表示我们要播放的图片；duration表示这张图播放的时间</p><h4 id="开启动画"><a href="#开启动画" class="headerlink" title="开启动画"></a>开启动画</h4><ol><li><p>MainActivity中重写<code>override fun onStart()</code>方法，运用findViewById找到已经关联动画的图片，键入下列代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fire = findViewById&lt;ImageView&gt;(R.id.fire)</span><br><span class="line"><span class="keyword">var</span> animDrawable = fire.drawable <span class="keyword">as</span> AnimationDrawable</span><br><span class="line"> animDrawable.start()</span><br></pre></td></tr></table></figure></li><li><p>使用<code>animDrawable.start()</code>开启帧动画</p></li></ol><hr><h1 id="View动画（补间动画）-TweenAnimation"><a href="#View动画（补间动画）-TweenAnimation" class="headerlink" title="View动画（补间动画）(TweenAnimation)"></a>View动画（补间动画）(<em>TweenAnimation</em>)</h1><ul><li><p>view动画也称为补间动画，因为我们只需要拿到一个view，设定它开始和结束的位置，中间的view会自动由系统补齐，而不需要帧动画每一幅图都是提前准备好的。</p></li><li><p>补间动画是Android一开始就提供的比较原始的动画，主要支持四种效果：平移（translate）、缩放（scale）、旋转（rotate）、透明度变化（渐变）（alpha） 四种基本效果，我们可以再这四种基础效果的基础上，选择其中的几种进行组合。</p></li><li><p>补间动画也是Android中常用的动画之一，相对属性动画来说，补间动画的点击事件<strong>不会跟着动画的位置变化而变化</strong>。因为属性动画的点击事件会<strong>随着动画的位置变化而变化</strong>，后续将逐渐被<strong>属性动画</strong>替代</p></li><li><p>View动画的四种基本效果分别对应Animation的四个子类</p></li><li><p>pivotX pivotY为缩放的中⼼点</p><p><img src="https://img-blog.csdnimg.cn/20190621225246708.png"></p></li></ul><h2 id="补间动画属性"><a href="#补间动画属性" class="headerlink" title="补间动画属性"></a>补间动画属性</h2><ol><li><p>duration 动画时⻓</p></li><li><p>fillAfter 是否保持动画结束状态，fillBefore 是否保持动画起始状态</p></li><li><p>interpolator 插值器，动画运动速率</p><ul><li>LinearInterpolator</li><li>BounceInterpolator</li><li>AccelerateInterpolator</li><li>DecelerateInterpolator</li></ul></li><li><p>repeatCount 重复次数 infinite表示⽆限次</p></li><li><p>repeatMode 重复⽅式 </p><ul><li>RESTART </li><li>REVERSE</li></ul></li><li><p>cancel() 取消动画</p></li><li><p>setAnimationListener 监听动画事件</p><ul><li>onAnimationStart</li><li>onAnimationEnd</li><li>onAnimationRepeat</li></ul></li></ol><p>注意：50% 相对于⾃身宽度50%，50%p 相对于⽗容器宽度的50%</p><h2 id="补间动画常用"><a href="#补间动画常用" class="headerlink" title="补间动画常用"></a>补间动画常用</h2><ol><li>透明动画 AlphaAnimation</li><li>旋转动画 ScaleAnimation</li><li>缩放动画 RotateAnimation</li><li>平移动画 TranslateAnimation</li><li>动画集合 AnimationSet</li><li>XML 实现动画效果</li></ol><h3 id="如何使用-1"><a href="#如何使用-1" class="headerlink" title="如何使用"></a>如何使用</h3><ol><li><ul><li><p><strong>代码创建</strong></p></li><li><p><strong>xml中定义</strong></p><ul><li>在res资源下，新建一个anim资源包，内部新建一个xml资源文件，根元素为 translate，scale，rotate，alpha，set</li></ul></li></ul></li><li><p>在这个xml文件内，设置相应的属性（在此仅说明xml文件定义的方法）</p><p>Scale举例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scale</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromXScale</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromYScale</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toXScale</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toYScale</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scale</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Rotate举例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rotate</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromDegrees</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toDegrees</span>=<span class="string">&quot;360&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rotate</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Translate</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">translate</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromXDelta</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromYDelta</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toXDelta</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toYDelta</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">translate</span>&gt;</span></span><br></pre></td></tr></table></figure><p>动画集合 AnimationSet</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:interpolator</span>=<span class="string">&quot;@android:anim/accelerate_decelerate_interpolator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fillAfter</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scale</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">&quot;3000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromXScale</span>=<span class="string">&quot;0.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromYScale</span>=<span class="string">&quot;0.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toXScale</span>=<span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toYScale</span>=<span class="string">&quot;1.0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alpha</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">&quot;3000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromAlpha</span>=<span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toAlpha</span>=<span class="string">&quot;0.5&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rotate</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromDegrees</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toDegrees</span>=<span class="string">&quot;720&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotX</span> = <span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span> = <span class="string">&quot;3000&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromXDelta</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toXDelta</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromYDelta</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toYDelta</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>加载动画资源</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> scaleAnim = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.anim_rotate) <span class="comment">// 装载动画</span></span><br><span class="line">scaleAnim.interpolator = LinearInterpolator() <span class="comment">// 插值器</span></span><br><span class="line">scaleAnim.repeatCount = <span class="number">2</span><span class="comment">// 重复次数</span></span><br><span class="line">scaleAnim.repeatMode = Animation.RESTART<span class="comment">// 重复模式</span></span><br><span class="line">fireAnim.startAnimation(scaleAnim)<span class="comment">// 开启动画</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="代码创建动画"><a href="#代码创建动画" class="headerlink" title="代码创建动画"></a>代码创建动画</h2><p>示例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tranAnim = TranslateAnimation(<span class="number">0f</span>, <span class="number">200f</span>,<span class="number">0f</span>,<span class="number">0f</span>)</span><br><span class="line">        <span class="keyword">val</span> rotateAnim = RotateAnimation(<span class="number">0f</span>, -<span class="number">45f</span>,<span class="number">0.5f</span>,<span class="number">0.5f</span>)</span><br><span class="line">        <span class="keyword">val</span> animatorSet = AnimationSet(<span class="literal">true</span>)</span><br><span class="line">        animatorSet.addAnimation(tranAnim)</span><br><span class="line">        animatorSet.addAnimation(rotateAnim)</span><br><span class="line">        animatorSet.interpolator = LinearInterpolator()</span><br><span class="line">        animatorSet.duration = <span class="number">200</span></span><br><span class="line">        animatorSet.repeatCount = Animation.INFINITE</span><br><span class="line">        animatorSet.repeatMode = Animation.REVERSE</span><br><span class="line">        animatorSet.fillAfter = <span class="literal">true</span></span><br><span class="line">        loadingAnim.startAnimation(animatorSet)</span><br></pre></td></tr></table></figure><h1 id="属性动画（-PropertyAnimator）"><a href="#属性动画（-PropertyAnimator）" class="headerlink" title="属性动画（ PropertyAnimator）"></a>属性动画（ <em>PropertyAnimator</em>）</h1><p><a href="https://developer.android.google.cn/guide/topics/graphics/prop-animation?hl=zh_cn">属性动画概览  | Android 开发者  | Android Developers (google.cn)</a></p><h2 id="Animator"><a href="#Animator" class="headerlink" title="Animator"></a>Animator</h2><ul><li><p>AnimatorSet</p></li><li><p>ValueAnimator</p></li><li><p>ObjectAnimator</p></li><li><p>TimeAnimator</p></li></ul><h2 id="动画属性（动画属性必须有set和get⽅法）"><a href="#动画属性（动画属性必须有set和get⽅法）" class="headerlink" title="动画属性（动画属性必须有set和get⽅法）"></a>动画属性（动画属性必须有set和get⽅法）</h2><p>示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> transAnimator = ObjectAnimator.ofFloat(</span><br><span class="line">            fireAnim,<span class="string">&quot;translationX&quot;</span>,<span class="number">0f</span>,fireAnim.width*<span class="number">2f</span></span><br><span class="line">        )</span><br><span class="line">        transAnimator.duration = <span class="number">500</span></span><br><span class="line">        transAnimator.interpolator = BounceInterpolator()</span><br><span class="line">        transAnimator.addUpdateListener &#123;  &#125;</span><br><span class="line">        transAnimator.addPauseListener&#123;&#125;</span><br><span class="line">        transAnimator.addListener(</span><br><span class="line">            onCancel = &#123;&#125;,</span><br><span class="line">            onStart = &#123;&#125;,</span><br><span class="line">            onEnd = &#123;&#125;,</span><br><span class="line">            onRepeat = &#123;&#125;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>帧动画可用来制作动态图片</li><li>补间动画可以制作控件变化效果，但并不会改变控件本身，不具有交互性，但使用方便</li><li>属性动画实现动画的同时，不会丢失控件原本的事件</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android SealedClass</title>
      <link href="/2022/07/25/Android-SealedClass/"/>
      <url>/2022/07/25/Android-SealedClass/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-SealedClass"><a href="#Android-SealedClass" class="headerlink" title="Android SealedClass"></a>Android SealedClass</h1><h2 id="普通class"><a href="#普通class" class="headerlink" title="普通class"></a>普通class</h2><ul><li>优点：灵活，只要是open的可以在任何地方被继承</li><li>缺点：无法控制，无法知道自己被哪些类继承</li></ul><hr><h2 id="sealed-class-密封类"><a href="#sealed-class-密封类" class="headerlink" title="sealed class 密封类"></a>sealed class 密封类</h2><h3 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h3><ol><li><p>需要知道自己有哪些子类 （有限子类）</p></li><li><p>需要统一接口</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sex-&gt;boy girl</span><br><span class="line">网络请求-&gt;失败 成功</span><br><span class="line">计算器-&gt;运算符 数字 =  clear</span><br><span class="line">运算符-&gt; + - x ÷</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="如何创建sealed-class的子类"><a href="#如何创建sealed-class的子类" class="headerlink" title="如何创建sealed class的子类"></a>如何创建sealed class的子类</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span></span>(<span class="keyword">val</span> symbol:String)&#123;</span><br><span class="line">    <span class="keyword">object</span> Add:Operation(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">    <span class="keyword">object</span> Minus:Operation(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Divide</span></span>(<span class="keyword">val</span> tt:String):Operation(<span class="string">&quot;÷&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造子类的特点"><a href="#构造子类的特点" class="headerlink" title="构造子类的特点"></a>构造子类的特点</h3><ol><li>子类不需要附带信息 没有主构造函数 使用object</li><li>子类需要附带信息 有主构造函数 使用class</li></ol><hr><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loadData</span><span class="params">(callBack:(<span class="type">NetWorkResult</span>)-&gt;<span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//callBack(NetWorkResult.Success(&quot;图片信息&quot;))</span></span><br><span class="line">    callBack(NetWorkResult.Failure(<span class="string">&quot;网络异常&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">NetWorkResult</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Success</span></span>(<span class="keyword">val</span> <span class="keyword">data</span>:String):NetWorkResult()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Failure</span></span>(<span class="keyword">val</span> errMsg:String):NetWorkResult()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loadData&#123; result -&gt;</span><br><span class="line">        <span class="keyword">when</span>(result)&#123;</span><br><span class="line">          <span class="keyword">is</span> NetWorkResult.Success -&gt;&#123; result.<span class="keyword">data</span> &#125;</span><br><span class="line">          <span class="keyword">is</span> NetWorkResult.Failure -&gt;&#123; result.errMsg &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span></span>(<span class="keyword">val</span> symbol:String)&#123;</span><br><span class="line">    <span class="keyword">object</span> Add:Operation(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">    <span class="keyword">object</span> Minus:Operation(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Divide</span></span>(<span class="keyword">val</span> tt:String):Operation(<span class="string">&quot;÷&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">operationBtnClicked</span><span class="params">(operation: <span class="type">Operation</span>)</span></span>&#123;</span><br><span class="line">      <span class="keyword">when</span>(operation)&#123;</span><br><span class="line">        <span class="keyword">is</span> Operation.Add -&gt;&#123; operation.symbol&#125;</span><br><span class="line">        <span class="keyword">is</span> Operation.Minus -&gt;&#123;&#125;</span><br><span class="line">        <span class="keyword">is</span> Operation.Divide -&gt;&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android消消乐</title>
      <link href="/2022/07/21/Android%E6%B6%88%E6%B6%88%E4%B9%90/"/>
      <url>/2022/07/21/Android%E6%B6%88%E6%B6%88%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Android消消乐"><a href="#Android消消乐" class="headerlink" title="Android消消乐"></a>Android消消乐</h1><p><a href="https://www.bilibili.com/video/BV1vF411P7aK?spm_id_from=333.999.0.0&vd_source=7fe10f1e27c87c48c14791fba3897c90">Android消消乐_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> Android项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android触摸事件</title>
      <link href="/2022/07/19/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/"/>
      <url>/2022/07/19/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Android触摸事件"><a href="#Android触摸事件" class="headerlink" title="Android触摸事件"></a>Android触摸事件</h1><h2 id="前言（Very-Important）"><a href="#前言（Very-Important）" class="headerlink" title="前言（Very Important）"></a>前言（<em>Very Important</em>）</h2><ol><li><p>事件是由系统来处理，当触摸到⼿机屏幕时，系统会将此触摸封装为MotionEvent事件，如果有监听这个触摸事件的对象，就会去执⾏对象中重写的onTouchEvent⽅法，并且传递当前的MotionEvent事件。</p></li><li><p>界⾯中如果有多个控件(层级先后排列)，这个事件优先被最外层的视图得到，如果外层不处理，就会向下传递事件。如果已经处理了， 事件的传递就结束了。如果都不处理，交给MainActivity处理，如果 Activity中不处理，事件就丢失了。</p></li><li><p>不宜在监听触摸事件的方法中测算某容器高度，因为这一般会导致重复调用测算的方法</p></li><li><p>onCreate -&gt; onStart -&gt;onResume -&gt; 界面才真正测量，并开始布局，进行渲染（即绘制），所以测量某控件位置，应当在绘制之前，即使用viewTreeObserver.addPreDrawListener{},并在此方法内测量，此方法的返回值若为true，则继续进行绘制，为false，则取消绘制</p></li><li><p>MotionEvent类内调用getAction()获取对应的事件类型</p><ul><li>ACTION_DOWN 触摸按下</li><li>ACTION_MOVE 触摸移动</li><li>ACTION_UP 触摸抬起</li><li>ACTION_CANCEL其他事件中断这个触摸事件（一般不需要考虑）</li></ul></li><li><p>每次触摸，必定包括触摸按下（ACTION_DOWN）和触摸抬起（ACTION_UP）这<strong>两起</strong>事件</p></li><li><p>MotionEvent类内已经内置获取触摸点的X,Y的方法，使用<code>getX()</code>，<code>getY()</code>可以获取触摸点的坐标，获取的X和Y为相对于整个windows的偏移量，一般会直接使用<code>?.x</code>，<code>?.y</code>获取</p></li><li><p>常用Rect对象或RectF对象封装矩形区域的坐标，需要传入四个参数，left, top, right, bottom，本质上需要矩形左上顶点和右下顶点的坐标，即可确定一个矩形区域</p></li><li><p>获取statusBar高度(不多说，重要)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resId = resources.getIdentifier(</span><br><span class="line"><span class="string">&quot;status_bar_height&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dimen&quot;</span>,</span><br><span class="line">    <span class="string">&quot;android&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">val</span> statusBarHeight = resources.getDimensionPixelSize(resId)</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="如何给视图添加触摸事件"><a href="#如何给视图添加触摸事件" class="headerlink" title="如何给视图添加触摸事件"></a>如何给视图添加触摸事件</h2><ol><li>监听触摸事件</li><li>判断触摸点是否在触摸范围内</li></ol><p><strong>注意</strong></p><ul><li><p>触摸点坐标相对于整个父容器（如果是在MainActivity中，则父容器为手机屏幕，坐标原点为手机显示部分左上角顶点）</p></li><li><p>使用<code>resources.displayMetrics.?</code>获取屏幕高度（手机可显示屏幕减去手机顶部状态栏部分）</p></li><li>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">container.viewTreeObserver.addOnPreDrawListener&#123;</span><br><span class="line">          <span class="comment">//获取测量的高度</span></span><br><span class="line">          <span class="keyword">val</span> containerHeight = container.measuredHeight</span><br><span class="line">          <span class="comment">// 屏幕的高度</span></span><br><span class="line">          <span class="keyword">val</span> screenHeight = resources.displayMetrics.heightPixels</span><br><span class="line">          <span class="comment">//status bar height</span></span><br><span class="line">          <span class="keyword">val</span> resid = resources.getIdentifier(</span><br><span class="line">              <span class="string">&quot;status_bar_height&quot;</span>,</span><br><span class="line">              <span class="string">&quot;dimen&quot;</span>,</span><br><span class="line">              <span class="string">&quot;android&quot;</span></span><br><span class="line">          )</span><br><span class="line">          <span class="keyword">val</span> statusBarHeight = resources.getDimensionPixelSize(resid)</span><br><span class="line">  <span class="comment">//bar的高度 = 屏幕高度 - 容器的高度 + 顶部状态栏的高度</span></span><br><span class="line">          barHeight = screenHeight - containerHeight + statusBarHeight</span><br><span class="line">          <span class="literal">true</span> <span class="comment">//继续绘制过程  false 取消当前绘制</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>如要获取状态栏的高度，需要先获取其资源id，再通过其资源id去获取状态栏的高度</p></li><li><p><strong>视图切换</strong>，视图是相对内容区域， 触摸点是相对与整个屏幕而言的</p></li></ul><hr><h2 id="1-监听触摸事件"><a href="#1-监听触摸事件" class="headerlink" title="1.监听触摸事件"></a>1.监听触摸事件</h2><ol><li><p>监听触摸事件，也称为<strong>处理</strong>触摸事件</p></li><li><p>监听触摸事件，必须重写<strong>onTouchEvent</strong>方法，并使此方法的返回值改为<strong>true</strong></p></li></ol><p>代码示例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="comment">//获取事件类型</span></span><br><span class="line">        <span class="keyword">when</span>(event?.action)&#123;</span><br><span class="line">            <span class="comment">// 一般在程序中会将dealWithTouchPoint方法封装</span></span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; dealWithTouchPoint(event.x,event.y)</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; dealWithTouchPoint(event.x,event.y)</span><br><span class="line">            MotionEvent.ACTION_UP -&gt; &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-判断触摸点是否在触摸范围内"><a href="#2-判断触摸点是否在触摸范围内" class="headerlink" title="2.判断触摸点是否在触摸范围内"></a>2.判断触摸点是否在触摸范围内</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部需要传入触摸点的坐标（该坐标相对于**父容器**）</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dealWithTouchPoint</span><span class="params">(x:<span class="type">Float</span>, y:<span class="type">Float</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取view的矩形区域 x,y,w,h</span></span><br><span class="line">        <span class="keyword">val</span> view = findViewById&lt;View&gt;(R.id.view)</span><br><span class="line">        <span class="keyword">val</span> viewRect = Rect(</span><br><span class="line">            view.x.toInt(),</span><br><span class="line">            view.y.toInt(),</span><br><span class="line">            (view.x+view.width).toInt(),</span><br><span class="line">            (view.y+view.height).toInt(),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断触摸点 是否在矩形区域内</span></span><br><span class="line">        <span class="keyword">if</span> (viewRect.contains(x.toInt(),(y-barHeight).toInt()))&#123;</span><br><span class="line">            <span class="comment">// 如果触摸点在矩形区域内，具体要做什么</span></span><br><span class="line">            <span class="comment">// 至此，监听触摸事件才算完成</span></span><br><span class="line">            view.setBackgroundColor(Color.BLACK)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="将视图从xml中独立出来"><a href="#将视图从xml中独立出来" class="headerlink" title="将视图从xml中独立出来"></a>将视图从xml中独立出来</h2><ol><li>res.layout包内新建相应的layout文件</li><li>在activity_main.xml中使用include应用此视图</li></ol><h2 id="单独给xml中某个视图添加触摸事件"><a href="#单独给xml中某个视图添加触摸事件" class="headerlink" title="单独给xml中某个视图添加触摸事件"></a>单独给xml中某个视图添加触摸事件</h2><p><strong>此方法也可运用于那些独立于xml的视图</strong></p><p>运用<code>setOnTouchListener</code>单独给某个视图添加触摸事件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：此堆代码须在onCreate方法中书写</span></span><br><span class="line"><span class="comment">// 此触摸事件范围仅在触摸该视图内有效</span></span><br><span class="line"><span class="keyword">val</span> view = findViewById&lt;View&gt;(R.id.unlockView)</span><br><span class="line">        view.setOnTouchListener&#123; _, event -&gt;</span><br><span class="line">            <span class="keyword">if</span> (event.action == MotionEvent.ACTION_DOWN)&#123;</span><br><span class="line">                view.setBackgroundColor(Color.BLACK)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="新建类中实现视图并使用代码添加触摸事件"><a href="#新建类中实现视图并使用代码添加触摸事件" class="headerlink" title="新建类中实现视图并使用代码添加触摸事件"></a>新建类中实现视图并使用代码添加触摸事件</h2><ol><li><p>必须重写父类的构造函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUnlockView</span>: <span class="type">View &#123;</span></span></span><br><span class="line">    <span class="comment">//代码中创建这个控件时，会调用这个构造函数</span></span><br><span class="line">   <span class="keyword">constructor</span>(context: Context):<span class="keyword">super</span>(context)&#123;&#125;</span><br><span class="line">    <span class="comment">//xml中拖拽控件就会调用这个构造函数，并且把控件的所有属性封装为AttributeSet类型</span></span><br><span class="line">   <span class="keyword">constructor</span>(context: Context, attrs:AttributeSet?):<span class="keyword">super</span>(context,attrs)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//xml 使用style资源id</span></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context,</span><br><span class="line">                attrs:AttributeSet?,</span><br><span class="line">                style:<span class="built_in">Int</span></span><br><span class="line">               ):<span class="keyword">super</span>(context,attrs,style)&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>封装触摸事件（即重写触摸事件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        setBackgroundColor(Color.BLACK)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="自定义父容器实现相应子类的触摸事件"><a href="#自定义父容器实现相应子类的触摸事件" class="headerlink" title="自定义父容器实现相应子类的触摸事件"></a>自定义父容器实现相应子类的触摸事件</h2><ol><li><p>定义一个类继承于ViewGroup</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUnlockView</span>: <span class="type">View &#123;</span></span></span><br><span class="line">    <span class="comment">//代码中创建这个控件时，会调用这个构造函数</span></span><br><span class="line">   <span class="keyword">constructor</span>(context: Context):<span class="keyword">super</span>(context)&#123;&#125;</span><br><span class="line">    <span class="comment">//xml中拖拽控件就会调用这个构造函数，并且把控件的所有属性封装为AttributeSet类型</span></span><br><span class="line">   <span class="keyword">constructor</span>(context: Context, attrs:AttributeSet?):<span class="keyword">super</span>(context,attrs)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//xml 使用style资源id</span></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context,</span><br><span class="line">                attrs:AttributeSet?,</span><br><span class="line">                style:<span class="built_in">Int</span></span><br><span class="line">               ):<span class="keyword">super</span>(context,attrs,style)&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>重写onSizeChanged方法，可以获取宽高，添加控件</p><blockquote><p>This is called during layout when the size of this view has changed. If you were just added to the view hierarchy, you’re called with the old values of 0.</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这个方法里面 容器的尺寸就确定了</span></span><br><span class="line">    <span class="comment">//1.获取容器的宽 高</span></span><br><span class="line">    <span class="comment">//2.添加子控件</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSizeChanged</span><span class="params">(w: <span class="type">Int</span>, h: <span class="type">Int</span>, oldw: <span class="type">Int</span>, oldh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> view = ImageView(context).apply &#123;</span><br><span class="line">            setImageResource(R.drawable.bg)</span><br><span class="line">            visibility = INVISIBLE</span><br><span class="line">        &#125;</span><br><span class="line">        addView(view)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>重写onLayout方法，对所有子控件进行布局</p><p><strong>注意</strong>：除了在xml中设置控件大小时可以使用单位，不要单位设置控件大小时，单位为像素</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子控件如何布局 如何显示 宽度 高度  x  y</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLayout</span><span class="params">(changed: <span class="type">Boolean</span>, l: <span class="type">Int</span>, t: <span class="type">Int</span>, r: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">//查找自己的子控件 </span></span><br><span class="line">        <span class="keyword">val</span> iv = getChildAt(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">//布局</span></span><br><span class="line">        iv.layout(dpToPx(<span class="number">20</span>),dpToPx(<span class="number">20</span>),dpToPx(<span class="number">200</span>),dpToPx(<span class="number">200</span>)) </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 此方法经常使用，使控件大小适配不同手机端</span></span><br><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">dpToPx</span><span class="params">(dp:<span class="type">Int</span>)</span></span> = (resources.displayMetrics.density*dp).toInt()</span><br></pre></td></tr></table></figure></li><li><p>重写onTouchEvent方法监听触摸事件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event?.action == MotionEvent.ACTION_DOWN)&#123;</span><br><span class="line">            <span class="keyword">val</span> iv = getChildAt(<span class="number">0</span>) <span class="keyword">as</span> ImageView</span><br><span class="line">            iv.visibility = VISIBLE</span><br><span class="line">            <span class="comment">//iv.setImageResource(R.drawable.calculate)</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在xml或者代码中使用这个控件</p><p>仅举例xml中使用此控件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 注意开头</span><br><span class="line"><span class="tag">&lt;<span class="name">com.example.touchevent.MyUnlockView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">&quot;invisible&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android创建控件的三种方法</title>
      <link href="/2022/07/17/Android%E5%88%9B%E5%BB%BA%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2022/07/17/Android%E5%88%9B%E5%BB%BA%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Android创建控件的三种方法"><a href="#Android创建控件的三种方法" class="headerlink" title="Android创建控件的三种方法"></a>Android创建控件的三种方法</h1><h2 id="xml中创建"><a href="#xml中创建" class="headerlink" title="xml中创建"></a>xml中创建</h2><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><ul><li>选择&#x2F;拖动一个控件到xml中</li><li>设置对应控件的宽、高</li><li>根据父容器的特点设置对应的（x，y）</li><li>设置控件的属性</li></ul><p><strong>总结</strong>：在xml中确定控件属性，让它位置确定</p><hr><h2 id="1-代码中创建"><a href="#1-代码中创建" class="headerlink" title="1.代码中创建"></a>1.代码中创建</h2><ol><li><p>创建控件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> view = View(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure></li><li><p>设置控件对应的宽和高</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> layoutParams = ConstraintLayout.LayoutParams(</span><br><span class="line">ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">viewGroup.LayoutParams.MATCH_PARENT</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>创建LayoutParams对象–&gt;需要控制控件的宽高和偏移及相对位置</p><p><strong>注意</strong>：需要选用控件所在的父容器对应的LayoutParams，因为不同的容器就有不同的显示规则</p></blockquote></li><li><p>根据父容器的特点设置对应的坐标(x, y)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layoutParams.startToStart = R.id.root</span><br><span class="line">layoutParams.tooToTop = R.id.root</span><br></pre></td></tr></table></figure></li><li><p>设置控件的属性</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.setBackgroundColor(Color.MAGENTA)</span><br></pre></td></tr></table></figure></li><li><p>将子控件添加到容器中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container.addView(view, layoutParams)</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="代码中创建容器（重要）"><a href="#代码中创建容器（重要）" class="headerlink" title="代码中创建容器（重要）"></a>代码中创建容器（重要）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rootContainer = ConstraintLayout(<span class="keyword">this</span>).apply &#123;</span><br><span class="line">            setBackgroundColor(Color.MAGENTA)</span><br><span class="line">            <span class="comment">// 绑定(系统对自定义id分配的)id</span></span><br><span class="line">            id = R.id.root_id <span class="comment">// root_id是自定义的id</span></span><br><span class="line">&#125;</span><br><span class="line">setContentView(rootContainer) <span class="comment">// 注意</span></span><br></pre></td></tr></table></figure><h3 id="如何手动添加资源id"><a href="#如何手动添加资源id" class="headerlink" title="如何手动添加资源id"></a>如何手动添加资源id</h3><p>res下values包里面新建资源文件ids.xml，自己添加自定义id</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;root_id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="控件是在xml创建的"><a href="#控件是在xml创建的" class="headerlink" title="控件是在xml创建的"></a>控件是在xml创建的</h2><ol><li><p>在res下layout包中自定义xml文件</p></li><li><p>使用LayoutInflater将xml中的视图解析出来</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">val</span> imgView = layoutInflater.inflate(</span><br><span class="line">            R.layout.icon_layout, <span class="comment">// 自定义xml文件</span></span><br><span class="line">            rootContainer, <span class="comment">// 父容器</span></span><br><span class="line">            <span class="literal">false</span> <span class="comment">// 是否加入父容器</span></span><br><span class="line">            )</span><br><span class="line"><span class="keyword">val</span> layoutParamsForImg = ConstraintLayout.LayoutParams(</span><br><span class="line">            imgView.layoutParams.width,</span><br><span class="line">            imgView.layoutParams.height</span><br><span class="line">        ).apply &#123;</span><br><span class="line">            startToStart = R.id.root_id</span><br><span class="line">            endToEnd = R.id.root_id</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意</strong>：代码中设置控件相当于父容器的布局</p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android DataBinding进阶使用</title>
      <link href="/2022/07/15/Android-DataBinding%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/07/15/Android-DataBinding%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-DataBinding进阶使用"><a href="#Android-DataBinding进阶使用" class="headerlink" title="Android DataBinding进阶使用"></a>Android DataBinding进阶使用</h1><h2 id="DataBinding优劣"><a href="#DataBinding优劣" class="headerlink" title="DataBinding优劣"></a>DataBinding优劣</h2><ul><li><p>advantage</p><p><strong>将UI和数据之间的交互从Activity中分离</strong>，从而使得MainActivity变成了一个“中介”,服务于逻辑数据与界面layout之间，进而使得数据与UI的绑定在xml中即可实现，</p></li><li><p>disadvantage</p><p>因为多了媒介，所以需要增加多的开销（代码量与代码操作）</p></li></ul><hr><h2 id="DataBinding中如何绑定数据"><a href="#DataBinding中如何绑定数据" class="headerlink" title="DataBinding中如何绑定数据"></a>DataBinding中如何绑定数据</h2><h3 id="1-DataBinding中如何绑定数据"><a href="#1-DataBinding中如何绑定数据" class="headerlink" title="1.DataBinding中如何绑定数据"></a>1.DataBinding中如何绑定数据</h3><p><strong>注意</strong>：此处的数据包括变量，方法，事件，即变量、方法、事件均可以被绑定</p><p>  <strong>预先准备</strong>：convert to data binding layout </p><h3 id="a-绑定一个变量"><a href="#a-绑定一个变量" class="headerlink" title="a. 绑定一个变量"></a>a. 绑定一个变量</h3><p> 在Data区域声明一个variable 在属性中使用@{}访问变量的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;mViewModel.title&#125;&quot;</span><br><span class="line">android:text=&quot;@&#123;String.valueOf(mViewModel.number)&#125;&quot;</span><br></pre></td></tr></table></figure><h3 id="b-绑定一个方法"><a href="#b-绑定一个方法" class="headerlink" title="b. 绑定一个方法"></a>b. 绑定一个方法</h3><p>   如果数据源里面的数据不能直接显示，需要做额外的处理，就需要<strong>自己定义绑定的事件</strong>(常用)<br>   <strong>特点</strong>：界面被加载的时候就会被调用</p><ol><li><p>在一个文件中定义自己的绑定事件 BindingAdapters</p></li><li><p>需要在build.gradle中添加plugin ‘kotlin-kapt’</p></li><li><p>在文件中定义方法——对应控件的扩展方法</p><ul><li><p>方式一</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="string">&quot;loadImage&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ImageView.<span class="title">loadImage</span><span class="params">(url: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.load(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式二</p><p>使用独立方法，需要一个当前这个控件作为参数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="string">&quot;loadImage2&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loadImage2</span><span class="params">(imageView:<span class="type">ImageView</span>,url: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        imageView.load(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>xml中像普通属性一样去使用这个方法</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadImage=&quot;@&#123;mViewModel.imageUrl&#125;&quot;</span><br></pre></td></tr></table></figure></li></ol><h3 id="c-绑定一个事件"><a href="#c-绑定一个事件" class="headerlink" title="c. 绑定一个事件"></a>c. 绑定一个事件</h3><p>  把事件所在的类传递给xml中绑定的变量</p><ol><li><p>在某个类中定义好对应的方法，注意：一定要接收一个参数类型为View</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">changeBackgroundColor</span><span class="params">(view: <span class="type">View</span>)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>在xml中绑定一个变量，类型就是当前这个方法所在的类</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">&quot;mainActivity&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;com.example.eventbinding.MainActivity&quot;</span> </span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在控件的onClick方法中绑定对应的方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onClick=&quot;@&#123;(view)-&gt;mainActivity.changeBackgroundColor(view)&#125;&quot;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android绑定与监听</title>
      <link href="/2022/07/14/Android%E7%BB%91%E5%AE%9A%E4%B8%8E%E7%9B%91%E5%90%AC/"/>
      <url>/2022/07/14/Android%E7%BB%91%E5%AE%9A%E4%B8%8E%E7%9B%91%E5%90%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="Android绑定与监听"><a href="#Android绑定与监听" class="headerlink" title="Android绑定与监听"></a>Android绑定与监听</h1><h2 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h2><p>如果您不知道括号内填写什么类型的参数，按住<code>Ctrl+p</code>可以提示需要填写参数的类型</p><h2 id="访问xml控件的三种方式"><a href="#访问xml控件的三种方式" class="headerlink" title="访问xml控件的三种方式"></a>访问xml控件的三种方式</h2><ol><li>findViewById</li><li>kotlin-android-extensions</li><li>viewBinding视图绑定</li></ol><h2 id="ViewBinding"><a href="#ViewBinding" class="headerlink" title="ViewBinding"></a>ViewBinding</h2><p>功能:</p><ul><li><p>访问xml中控件</p></li><li><p>可以通过<code>binding.视图id</code>使用相关资源</p></li></ul><p>如何使用:</p><ol><li><p>首先需要在gradle中添加如下代码</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">viewBinding &#123;</span><br><span class="line">enabled <span class="keyword">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在MainActivity中使用<code>lateinit var binding: ActivityMainBinding</code>来定义一个变量保存binding类对象</p></li><li><p>在Oncreate方法中实现如下代码</p><p>获取binding类对象</p><ul><li>layoutInflater: Layoutnflater 布局解析器</li><li>代码中只能使用对应的View或者ViewGroup无法使用xml文件</li><li>需要使用布局解析器来将xml文件转化为对应的View&#x2F;ViewGroup</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">binding = ActivityMainBinding.inflate(layoutInflater)<span class="comment">// 将xml的解析</span></span><br><span class="line"><span class="comment">// 将binding类绑定的视图和MainActivity关联</span></span><br><span class="line">setContentView(binding.root)</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="数据丢失问题"><a href="#数据丢失问题" class="headerlink" title="数据丢失问题"></a>数据丢失问题</h2><h3 id="具体问题"><a href="#具体问题" class="headerlink" title="具体问题"></a>具体问题</h3><p>当界面旋转时内容清空了&#x2F;还原为初始状态了<br>原因：<strong>界面旋转时，activity会被重新加载</strong></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p>让屏幕支持旋转(横竖屏)（<strong>有可能无效，经过本人实现</strong>）</p><p><strong>此处如果设置将screenOrientation设置为nosensor,由于页面不随手机位置摆放旋转，有效</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AndroidManifest.xml中找到对应Activity</span><br><span class="line">      设置android:screenOrientation=&quot;sensor&quot;</span><br><span class="line">      unspecified，默认值，由系统决定，不同手机可能不一致</span><br><span class="line">      landscape，强制横屏显示</span><br><span class="line">      portrait，强制竖屏显</span><br><span class="line">      behind，与前一个activity方向相同</span><br><span class="line">      sensor，根据物理传感器方向转动，用户90度、180度、270度旋转手机方向，activity都跟随着变化</span><br><span class="line">      sensorLandscape，横屏旋转，一般横屏游戏会这样设置</span><br><span class="line">      sensorPortrait，竖屏旋转</span><br><span class="line">      nosensor，旋转设备时候，界面不会跟着旋转。初始化界面方向由系统控制</span><br></pre></td></tr></table></figure></li><li><p>使用状态保存机制</p><p><strong>优点</strong>：操作简单  使用onSaveInstanceState存储 ，使用onCreate取出<br><strong>缺点</strong>：</p><ol><li>无法共享</li><li>进程被销毁时，数据会丢失</li></ol><p>Activity提供了状态保存的机制，当界面即将消失时，保存状态值，界面重新显示时读取并显示状态值。使用Bundle来存储数据，通过key-value存取</p><p><strong><em>onSaveInstanceState</em>在界面销毁之前系统自动调用，可以重写此方法，实现自己的目的</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//onSaveInstanceState在界面销毁之前系统自动调用，可以重写此方法，实现自己的目的</span></span><br><span class="line">​      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSaveInstanceState</span><span class="params">(outState: <span class="type">Bundle</span>)</span></span> &#123;</span><br><span class="line">​        <span class="comment">// 放入数据</span></span><br><span class="line">​        outState.putInt(<span class="string">&quot;number&quot;</span>,number)</span><br><span class="line">    <span class="comment">// 存储数据</span></span><br><span class="line">​        <span class="keyword">super</span>.onSaveInstanceState(outState)</span><br><span class="line">​      &#125;</span><br></pre></td></tr></table></figure><p><strong>取数据</strong></p><p><strong>注意</strong>：读取数据，系统已经自动写好，使用保存的数据通过<code>savedInstanceState</code>的相应方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> onCreate时取：</span><br><span class="line">​      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">​        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">​        <span class="comment">//重新读取保存的数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用已经保存的数据</strong>举例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">savedInstanceState?.getInt(<span class="string">&quot;number&quot;</span>).also &#123;</span><br><span class="line">​          <span class="keyword">if</span> (it != <span class="literal">null</span>)&#123;</span><br><span class="line">​            number = it</span><br><span class="line">​            binding.textView.text = <span class="string">&quot;<span class="variable">$number</span>&quot;</span></span><br><span class="line">​          &#125;</span><br><span class="line">​        &#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="ViewModle"><a href="#ViewModle" class="headerlink" title="ViewModle"></a>ViewModle</h2><p><a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel?hl=zh-cn"><code>ViewModel</code></a> 类旨在以注重生命周期的方式存储和管理界面相关的数据。<a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel?hl=zh-cn"><code>ViewModel</code></a> 类让数据可在发生屏幕旋转等配置更改后继续留存。</p><p><strong>注意</strong>：ViewModle也可解决屏幕旋转后的问题</p><p>​<strong>如何使用？</strong></p><ol><li><p>定义一个类继承于ViewModel</p></li><li><p>在类中声明数据和数据相关的逻辑</p></li><li><p>在MainActivity中保存MainViewModel的对象</p><ul><li><p>创建MainViewModel对象</p></li><li><p>让this(MainActivity)成为这个对象的拥有者，MainViewModel可以感知Activity的生命周期<br>model &#x3D; ViewModelProvider(this).get(MainViewModel::class.java)</p></li></ul></li></ol><p>示例:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">  <span class="comment">//1.定义一个变量保存binding类对象</span></span><br><span class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> binding:ActivityMainBinding</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义变量保存viewModel</span></span><br><span class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> model: MainViewModel</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     \* 2.获取binding类对象</span></span><br><span class="line"><span class="comment">     \* layoutInflater: LayoutInflater 布局解析器</span></span><br><span class="line"><span class="comment">     \* 代码中只能使用对应的View或者ViewGroup无法使用xml文件</span></span><br><span class="line"><span class="comment">     \* 需要使用布局解析器来将xml文件转化为对应的View/ViewGroup</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//3.将binding类绑定的视图和MainActivity关联</span></span><br><span class="line">​    setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//创建MainViewModel对象</span></span><br><span class="line">​    model = ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(MainViewModel::<span class="keyword">class</span>.java)</span><br><span class="line">​    binding.textView.text = <span class="string">&quot;<span class="subst">$&#123;model.number&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">​    <span class="comment">//4.正常使用</span></span><br><span class="line">​    binding.button.setOnClickListener &#123;</span><br><span class="line">​      <span class="comment">/* number++</span></span><br><span class="line"><span class="comment">​      binding.textView.text = &quot;$number&quot;*/</span></span><br><span class="line">​      model.addOne()</span><br><span class="line">​      binding.textView.text = <span class="string">&quot;<span class="subst">$&#123;model.number&#125;</span>&quot;</span></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//重新读取保存的数据</span></span><br><span class="line">​    <span class="comment">/*savedInstanceState?.getInt(&quot;number&quot;).also &#123;</span></span><br><span class="line"><span class="comment">​      if (it != null)&#123;</span></span><br><span class="line"><span class="comment">​        */</span><span class="comment">/*number = it</span></span><br><span class="line"><span class="comment">​        binding.textView.text = &quot;$number&quot;*/</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">​      &#125;</span></span><br><span class="line"><span class="comment">​    &#125;*/</span></span><br><span class="line"></span><br><span class="line">​    <span class="comment">//点击按钮实现跳转</span></span><br><span class="line">​    binding.nextBtn.setOnClickListener &#123;</span><br><span class="line">​      startActivity(Intent(<span class="keyword">this</span>,SecondActivity::<span class="keyword">class</span>.java))</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*//在界面销毁之前调用</span></span><br><span class="line"><span class="comment">  override fun onSaveInstanceState(outState: Bundle) &#123;</span></span><br><span class="line"><span class="comment">    //存储数据</span></span><br><span class="line"><span class="comment">    outState.putInt(&quot;number&quot;,number)</span></span><br><span class="line"><span class="comment">    super.onSaveInstanceState(outState)</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="如何监听数据？"><a href="#如何监听数据？" class="headerlink" title="如何监听数据？"></a>如何监听数据？</h2><p><strong>时刻监听数据也可解决屏幕旋转导致数据显示的问题</strong></p><h3 id="1-使用LiveData-x2F-MutableData"><a href="#1-使用LiveData-x2F-MutableData" class="headerlink" title="1.使用LiveData&#x2F;MutableData"></a>1.使用LiveData&#x2F;MutableData</h3><p><strong>注意：MutableData为LiveData的子类</strong></p><ol><li>liveData使用步骤</li></ol><ul><li>a.在ViewModel中声明需要监听的对象<br>var number &#x3D; MutableLiveData&lt;&gt;()</li><li>b.在ViewModel中实现数据改变逻辑<br> fun addOne(){<br>   number.postValue(number.value!!+1)<br> }</li><li>c.界面中获取ViewModel对象<br> val model: MainViewModel by viewModels()</li><li>d.观察数据并实现改变之后需要处理的业务逻辑<br> model.number.observe(this){<br>binding.textView.text &#x3D; “$it”<br> }</li></ul><h3 id="2-DataBinding"><a href="#2-DataBinding" class="headerlink" title="2.DataBinding"></a>2.DataBinding</h3><p>注意：</p><ol><li><p>启动DataBinding功能</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">     dataBinding&#123;</span><br><span class="line">       enabled <span class="keyword">true</span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>在xml文件的根容器上使用 alt+enter -&gt; convert to data binding layout</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">       <span class="attr">name</span>=<span class="string">&quot;自己定义的变量名&quot;</span> // 例如<span class="attr">:</span> <span class="attr">viewModel</span></span></span><br><span class="line"><span class="tag">     <span class="attr">type</span>=<span class="string">&quot;类型的完整路径&quot;</span> // 例如<span class="attr">:</span> <span class="attr">com.example.lineData.MainViewModel</span></span></span><br><span class="line"><span class="tag">    \&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在xml中给按钮绑定事件：注意-&gt;两边的空格</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onClick=&quot;@&#123;() -&gt; viewModel.addOne()&#125;&quot;</span><br></pre></td></tr></table></figure></li><li><p>在xml中绑定数据</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=<span class="string">&quot;@&#123;String.valueOf(viewModel.number)&#125;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>将Activity中创建的ViewModel对象设置给DataBinding中申明的变量</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binding.viewModel = model</span><br><span class="line">binding.lifecycleOwner = <span class="keyword">this</span></span><br></pre></td></tr></table></figure></li><li><p>如果事件需要参数，或者说需要做额外的操作，必须自定义绑定的事件</p><ol><li><p>在build.gradle的plugins中导入插件</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>在一个文件中定义好需要绑定的方法(给对应的控件添加扩展)</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要使用@BindingAdapter()注解修饰</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android之自信demo</title>
      <link href="/2022/07/13/Android%E4%B9%8B%E8%87%AA%E4%BF%A1demo/"/>
      <url>/2022/07/13/Android%E4%B9%8B%E8%87%AA%E4%BF%A1demo/</url>
      
        <content type="html"><![CDATA[<h1 id="Android之自信demo"><a href="#Android之自信demo" class="headerlink" title="Android之自信demo"></a>Android之自信demo</h1><p><strong>2022年7月9日暑假留校开始了Android培训，第一个小demo，算是标志我自己的Android开始吧，我坚信自己一定能成功!</strong></p><h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;280dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:scaleType</span>=<span class="string">&quot;centerCrop&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:srcCompat</span>=<span class="string">&quot;@drawable/girlone&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;160dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:scaleType</span>=<span class="string">&quot;centerCrop&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:srcCompat</span>=<span class="string">&quot;@drawable/girltwo&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:scaleType</span>=<span class="string">&quot;centerCrop&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@+id/imageView2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:srcCompat</span>=<span class="string">&quot;@drawable/girlthree&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;120dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;160dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;120dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/textOne&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@color/black&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fontFamily</span>=<span class="string">&quot;@font/enlova&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/imageView&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/buttonText&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/textView&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;130dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;110dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;120dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/annotationOne&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@color/red&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fontFamily</span>=<span class="string">&quot;@font/enlova&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;30sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/imageView2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;130dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;130dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;184dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fontFamily</span>=<span class="string">&quot;sans-serif-black&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/humor&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@color/green&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">&quot;invisible&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/button&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> android.widget.Button</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.core.view.isVisible</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> stringBuilder = StringBuilder()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> headView = findViewById&lt;TextView&gt;(R.id.textView)</span><br><span class="line">        <span class="keyword">val</span> headViewTwo = findViewById&lt;TextView&gt;(R.id.textView2)</span><br><span class="line">        <span class="keyword">val</span> headViewThree = findViewById&lt;TextView&gt;(R.id.textView3)</span><br><span class="line">        <span class="keyword">val</span> button = findViewById&lt;Button&gt;(R.id.button)</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;I will be a billionaire&quot;</span>)</span><br><span class="line">            Log.v(<span class="string">&quot;test&quot;</span>, stringBuilder.toString())</span><br><span class="line">            headView.text = <span class="string">&quot;I am a big bull&quot;</span></span><br><span class="line">            headViewTwo.text = <span class="string">&quot;Daydream!&quot;</span></span><br><span class="line">            headViewThree.apply &#123;</span><br><span class="line">                <span class="keyword">this</span>.isVisible = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>一切我取得的成就，都是努力，奋斗。<br>效果，会永远留在我心中，就如同我写的博客一样，字字充满心血，以此向过去的自己致敬</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2022/07/08/%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/07/08/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><ul><li><p>链表是一种通过指针串联在一起的线性结构</p></li><li><p>链表由链节🔗（节点）构成</p></li><li><p>每一个节点由两部分组成，一个是数据域（用来存放数值），一个是指针域（存放指向下一个节点的指针）</p></li><li><p>链表的最后一个节点的指针域指向null（空指针）</p></li><li><p>链接的入口节点称为链表的头结点(<em>head</em>)</p></li></ul><p>如图所示： <img src="https://img-blog.csdnimg.cn/20200806194529815.png" alt="链表1"></p><hr><h2 id="链表的类型"><a href="#链表的类型" class="headerlink" title="链表的类型"></a>链表的类型</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单链表中的有且仅有一个指针域，此指针域只能指向下一节点</p><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>每一个节点有两个指针域，一个指向上一个节点，一个指向下一个节点</p><p><strong>注意</strong>：双链表既可向前查询，也可向后查询。</p><p>如图所示： <img src="https://img-blog.csdnimg.cn/20200806194559317.png" alt="链表2"></p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表，顾名思义，就是链表首尾相连</p><p>循环链表可以用来解决约瑟夫环问题。</p><p><img src="https://img-blog.csdnimg.cn/20200806194629603.png" alt="链表4"></p><hr><h2 id="链表在内存中的存储方式"><a href="#链表在内存中的存储方式" class="headerlink" title="链表在内存中的存储方式"></a>链表在内存中的存储方式</h2><ul><li><p>数组是在内存中是连续分布的，但是链表在内存中不是连续分布的</p></li><li><p>链表通过指针域的指针链接在内存中各个节点。</p></li></ul><p>所以通常链表中的节点在内存中是不连续分布的 ，它们通常散乱分布在内存中的某地址上，它们的分配机制取决于操作系统的内存管理。</p><p>如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200806194613920.png" alt="链表3"></p><p>这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。</p><hr><h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><h3 id="单链表-1"><a href="#单链表-1" class="headerlink" title="单链表"></a>单链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> value;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value = <span class="literal">None</span>, <span class="built_in">next</span> = <span class="literal">None</span></span>): </span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure><h3 id="双链表-1"><a href="#双链表-1" class="headerlink" title="双链表"></a>双链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> value;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value = <span class="literal">None</span>, left = <span class="literal">None</span>, right = <span class="literal">None</span></span>): </span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure><h2 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h2><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除D节点，如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200806195114541.png" alt="链表-删除节点"></p><p>此时将C节点的next指针指向E节点即可</p><p><strong>注意</strong>：</p><ul><li><p>此时D节点仍然存留在内存，只不过此时已经不在这个链表</p></li><li><p>所以C++里面最好是再手动释放这个D节点，释放这块内存</p></li><li><p>其他语言例如Java、Python，就有自己的内存回收机制，无需自己手动释放</p></li></ul><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200806195134331.png" alt="链表-添加节点"></p><p>此时C节点的指针域应当存放F节点的地址，F节点应当存放D节点的地址</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>告别大一的自己</title>
      <link href="/2022/07/08/%E5%91%8A%E5%88%AB%E5%A4%A7%E4%B8%80%E7%9A%84%E8%87%AA%E5%B7%B1/"/>
      <url>/2022/07/08/%E5%91%8A%E5%88%AB%E5%A4%A7%E4%B8%80%E7%9A%84%E8%87%AA%E5%B7%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="告别大一的自己"><a href="#告别大一的自己" class="headerlink" title="告别大一的自己"></a>告别大一的自己</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​不知不觉大一就结束了，我也不再是<em>freshman</em>了。现在回想去年9月3日开学的时候，确实是有趣的，无悔来到西南大学，确实收获了许多，也成长了许多。</p><hr><h2 id="总结大一生活"><a href="#总结大一生活" class="headerlink" title="总结大一生活"></a>总结大一生活</h2><h3 id="大一上"><a href="#大一上" class="headerlink" title="大一上"></a>大一上</h3><p>大一上比较有意思的就是军训，阳光下的曝晒，军体拳打的着实累人。军训期间，我摸索了学校图书馆，发现了种种玄机奥妙，也探寻了自习室。为了备考四级英语，高考后暑假就把四级英语试卷差不多做了一半，无聊的时候，高数也自学了一半。军训后，买了一本《吉米多维奇高等数学习题精选精解》，随后，随着高数课程进度，此书，也在被我同步完成。大一上的时候，学了C语言，后来，找了一个练习算法网站，于是在洛谷上解了三十道多道题吧。解这种算法题，一般一道至少15min，有的解出来确实费时费力。除了学校上面的事，还参加了前端的培训班，学习了HTML5,CSS，完成了一些demo，也录制了一些视频在bilibili上，现在回想起来，这些对我确实挺有用处。西南大学的体育考试别具一格，别的学校都是大一就开始选修，只考选的项目，而西南大学的学生要考2400m长跑，跳远，引体向上，样样都对我极不友好。为了体育考试不挂科，每天晚上9点20后，约好和一位同学体能训练，确实大有益处。开学的时候，加入了一个学生会部门，但实在不喜欢那个部门里面的氛围，退了。之后的日子，就是在潜心学高数，备考四级英语和上培训班了。四级英语考了600多分，确实没有辜负我的努力。生活上，得到了寝室长的帮助，寝室里面虽然发生了一些矛盾，但还是都解决了，寝室的关系也融洽了起来，人生中的某些困惑也得到了学校老师们的帮助，在此特别感谢我的辅导员，某位老师以及我的父母。最后，跟着施庆伟教授一起写论文，迎来了寒假。</p><h3 id="大一下"><a href="#大一下" class="headerlink" title="大一下"></a>大一下</h3><p>大一下继续参加Android培训，途中有一件哭笑不得的事——打太极扭断髌骨，成功重伤。在医院躺了12天，非常感谢慰问、看望我的辅导员和我的妹妹。住院的日子，确实极大让我成长了。出院后，因为落下很多课，最为致命的是高等数学和线性代数，高数还算好，对我来说，简单，线代因为每一节之间的关联性太强了，出院后恢复上课，每节课我都上的难受，六级英语考试也迫在眉睫，写了一半的论文也因为住院荒废了，我也明确了自己的方向。我利用空闲时间搭建了个人网站，在此过程中遇到了许许多多的问题，但都被我解决了。我还加入了一个社群，遇到许多企业的前辈，和各路大牛交流，真正算是了解计算机行业技术与发展了，也吸收了各种找工作面试，学技术，读研读博的经验，也有内推的机会，开始了在leetcode的算法刷题之路。六级英语，我这次只能浅过了。期末的时候，我特别担心线性代数挂科，买了一本《线性代数习题精选精解》，每天一节，这本接近400页的书，见证了我线代的自学之路。这个学期还参加了大学生创新创业大赛，为此去了重庆璧山实地走访，也增长了见识。最近在机缘巧合下，走进了《梅花易数》，开启了我人生的易学大门，也算是一件幸事吧。学年设计的话，该怎么做怎么做。开学还要体育缓考，这个真要努力啊！</p><hr><h2 id="大二生活的规划"><a href="#大二生活的规划" class="headerlink" title="大二生活的规划"></a>大二生活的规划</h2><ul><li><em>leetcode</em>上完成200道各类算法题</li><li>学一门计算机语言——后端开发路线，留后路</li><li>完成《梅花易数》和《易经》的学习</li><li>六级英语考到600分以上，为了专业八级奋斗</li><li>多参加竞赛</li><li>为考研完成高数考研真题和考研英语真题</li><li>个人博客完善，部署到云服务器上</li><li>进一步提升英语和文言文阅读水平</li></ul><p>​<strong>2022.7.8  姚依琳</strong></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统的概念、功能与特征</title>
      <link href="/2022/07/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%89%B9%E5%BE%81/"/>
      <url>/2022/07/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的概念、功能和特征"><a href="#操作系统的概念、功能和特征" class="headerlink" title="操作系统的概念、功能和特征"></a>操作系统的概念、功能和特征</h1><h2 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h2><p>我的理解：计算机组装好之后（即裸机）首先安装的软件，这类软件被称为系统软件，负责控制计算机底层硬件，为上层软件服务，而操作系统为系统软件中最基本的系统软件。</p><p><strong>我们通常把覆盖了软件的机器成为扩展机器，又称为虚拟机</strong></p><hr><h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><p>操作系统是作为用户与计算机硬件之间的接口</p><ul><li><p>命令接口：允许用户直接使用</p></li><li><p>程序接口：允许用户通过程序间接使用</p></li><li><p><em>GUI</em>：现代操作系统中最流行的图形用户接口</p></li></ul><hr><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><p>操作系统四大特征</p><ul><li>并发</li><li>共享</li><li>虚拟</li><li>异步</li></ul><p><strong>注意</strong>：并发和共享是操作系统<strong>最基本</strong>的特征，<strong>二者互为共存条件</strong></p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>多个事件同时发生。在计算机执行上，宏观上是同时发生，微观上是计算机CPU交替执行这些事件</p><h3 id="操作系统的并发性"><a href="#操作系统的并发性" class="headerlink" title="操作系统的并发性"></a>操作系统的并发性</h3><p>多个程序运行时，操作系统宏观上“同时”执行这些程序，但微观上，是交替执行，只是交替执行的速度太快</p><hr><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>共享指资源共享，即系统中的资源可供内存中多个并发程序共同使用</p><h3 id="共享方式"><a href="#共享方式" class="headerlink" title="共享方式"></a>共享方式</h3><ul><li><p>互斥共享方式</p><p>系统中的某些资源，一个时间段内只能允许一个程序访问</p></li><li><p>同时共享方式</p><p>系统中的某些资源，一个时间段内允许多个程序”同时”访问</p></li></ul><p><strong>注意</strong>：所谓的”同时”往往是宏观上的，而在微观上，这些进程可能交替地对该资源进行访问（即分时共享）</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>互斥共享方式：使用QQ和WeChat同时进行视频通话，同一个时间内摄像头只能分配给同一个进程</p><p>同时共享方式：使用QQ发送文件A，使用WeChat发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘</p><hr><h2 id="并发与共享的关系"><a href="#并发与共享的关系" class="headerlink" title="并发与共享的关系"></a>并发与共享的关系</h2><p><strong>并发性</strong>指计算机系统中同时存在着多个运行着的程序</p><p><strong>共享性</strong>指系统中的资源可供内存中多个并发执行的程序共同使用</p><p>如果失去并发性，系统中只有一个程序运行，共享性则失去了意义，如果失去共享性，系统中并发的程序无法“同时”访问硬盘资源，也就无法实现并发，所以<strong>并发性与共享性互为存在条件</strong></p><h2 id="操作系统的特征-1"><a href="#操作系统的特征-1" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><ul><li>虚拟是将一个物理上的实体变成若干个逻辑上的对应物。</li><li>物理实体（前者）是实际存在的</li><li>而逻辑上的对应物是用户感受到的</li></ul><h2 id="虚拟技术"><a href="#虚拟技术" class="headerlink" title="虚拟技术"></a>虚拟技术</h2><ul><li>空分复用技术（如虚拟存储器技术）</li><li>时分复用技术（如虚拟存储器）</li></ul><h3 id="时分复用共享"><a href="#时分复用共享" class="headerlink" title="时分复用共享"></a>时分复用共享</h3><p>时分复用是指当多个程序或用户想要使用同一个资源时而采取的策略，每个程序或用户需要按照一定的顺序依次使用这个资源。</p><h3 id="空分复用技术"><a href="#空分复用技术" class="headerlink" title="空分复用技术"></a>空分复用技术</h3><p> <strong>计算机中使用空分复用技术来提高存储空间的利用率</strong></p><p> 举例理解：</p><p>一个程序<strong>需要放入内存</strong>并给它<strong>分配CPU</strong>才能执行</p><p>LOL最低需要2GB的运行内存，QQ需要256MB的内存，假设我的电脑：2GB内存</p><p>问题：这些程序同时运行需要的内存大于2GB，那么它们为什么还可以在我的电脑上运行呢？</p><p>答：这就是<strong>虚拟存储器技术</strong></p><p><strong>虚拟存储器技术在本质上就是使内存时分复用和空分复用。该技术将一道程序划分成若干部分，物理内存也划分成多个部分，通过“请求调入功能”和“置换功能”，每次只把用户程序的一部分调入内存运行，这样便实现了用户程序各个部分分时进入内存运行的功能，从而在逻辑上扩充存储器的容量。</strong></p><h3 id="时分复用技术"><a href="#时分复用技术" class="headerlink" title="时分复用技术"></a>时分复用技术</h3><p>时分：将大的时间段分为小的时间片</p><p>举例理解：</p><p>一个单核CPU”同时”运行多个程序。</p><hr><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>异步是指，在多道程序环境下，允许多个程序并发，但由于资源有限，导致进程的执行是不彻底的，而是走走停停，以不可预知的速度前进。</p><p>由上易知：<strong>只有系统拥有并发性，才可能导致异步</strong></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java贪吃蛇</title>
      <link href="/2022/07/03/Java%E8%B4%AA%E5%90%83%E8%9B%87/"/>
      <url>/2022/07/03/Java%E8%B4%AA%E5%90%83%E8%9B%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Java贪吃蛇"><a href="#Java贪吃蛇" class="headerlink" title="Java贪吃蛇"></a><em>Java</em>贪吃蛇</h1><h2 id="视频链接"><a href="#视频链接" class="headerlink" title="视频链接"></a>视频链接</h2><h2 id="https-www-bilibili-com-video-BV1JG411x7dn"><a href="#https-www-bilibili-com-video-BV1JG411x7dn" class="headerlink" title="https://www.bilibili.com/video/BV1JG411x7dn/"></a><a href="https://www.bilibili.com/video/BV1JG411x7dn/">https://www.bilibili.com/video/BV1JG411x7dn/</a></h2>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>螺旋矩阵</title>
      <link href="/2022/07/01/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
      <url>/2022/07/01/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><p>题目地址：<a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵 - 力扣（LeetCode）</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>本题未涉及到具体的算法，但是却巧妙考察了代码的控制能力</li><li>此题应该模拟顺时针画矩阵的过程（填充矩阵顺序）<ul><li>填充矩阵上行从左到右</li><li>填充矩阵右列从上到下</li><li>填充矩阵下行从右到左</li><li>填充矩阵左列从下到上</li><li>由外及里最后停止</li></ul></li></ul><h2 id="具体解答"><a href="#具体解答" class="headerlink" title="具体解答"></a>具体解答</h2><ul><li><p>具体解释见代码注释</p></li><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 使用vector创建二维数组</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// startX is the starting position of the every loop in the overall process</span></span><br><span class="line">        <span class="comment">// the same as startY</span></span><br><span class="line">        <span class="type">int</span> startX = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> startY = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// to control the counts of the loop</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// the middle position of the matrix</span></span><br><span class="line">        <span class="type">int</span> mid = n / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// to give the value by loop,and the count will change</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// use offset to control the length of the border of the loop</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop--) &#123;</span><br><span class="line">            i = startX;</span><br><span class="line">            j = startY;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// to fill from left to right</span></span><br><span class="line">            <span class="keyword">for</span> (j = startY; j &lt; startY + n - offset; j++) &#123;</span><br><span class="line">                res[startX][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// to fill from top to bottom</span></span><br><span class="line">            <span class="keyword">for</span> (i = startX; i &lt; startX + n - offset; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// to fill from right to left</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; startY; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startX; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// when the loop &gt; 2, it need to add one</span></span><br><span class="line">            startX++;</span><br><span class="line">            startY++;</span><br><span class="line"><span class="comment">// the offset is used to control the length of border which need to cover</span></span><br><span class="line">            offset += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// if n is odd number, we need to give the value to the middle num respectively</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt;list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (Math.min(m, n) + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; count) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n - i; j++) &#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; m - i; j++) &#123;</span><br><span class="line">                list.add(matrix[j][(n-<span class="number">1</span>) - i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (n-<span class="number">1</span>) - (i+<span class="number">1</span>); j &gt;= i &amp;&amp; (m-<span class="number">1</span>-i) != i; j--) &#123;</span><br><span class="line">                list.add(matrix[(m-<span class="number">1</span>) - i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (m-<span class="number">1</span>) - (i +<span class="number">1</span>); j &gt;= i+<span class="number">1</span> &amp;&amp; (n-<span class="number">1</span>-i) != i; j--) &#123;</span><br><span class="line">                list.add(matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Kotlin</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">generateMatrix</span><span class="params">(n: <span class="type">Int</span>)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">      <span class="keyword">var</span> res = Array(n)&#123;IntArray(n)&#125;</span><br><span class="line">      <span class="keyword">var</span> r = <span class="number">0</span></span><br><span class="line">      <span class="keyword">var</span> c = <span class="number">0</span></span><br><span class="line">      <span class="keyword">var</span> row = n - <span class="number">1</span></span><br><span class="line">      <span class="keyword">var</span> column = n - <span class="number">1</span></span><br><span class="line">      <span class="keyword">var</span> count = <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (r &lt;=row &amp;&amp; c &lt;= column) &#123;</span><br><span class="line">          <span class="keyword">for</span> (i <span class="keyword">in</span> c..column) &#123;</span><br><span class="line">              res[r][i] = count++</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> (i <span class="keyword">in</span> (r+<span class="number">1</span>)..row) &#123;</span><br><span class="line">              res[i][column] = count++</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (r &lt; row &amp;&amp; c &lt; column) &#123;</span><br><span class="line">              <span class="keyword">for</span> (i <span class="keyword">in</span> (column-<span class="number">1</span>) downTo c) &#123;</span><br><span class="line">                  res[row][i] = count++</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">for</span> (i <span class="keyword">in</span> (row-<span class="number">1</span>) downTo r+<span class="number">1</span>) &#123;</span><br><span class="line">                  res[i][c] = count++</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">            r++</span><br><span class="line">            c++</span><br><span class="line">            row--</span><br><span class="line">            column--</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin嵌套定义及扩展函数</title>
      <link href="/2022/06/26/Kotlin%E5%B5%8C%E5%A5%97%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0/"/>
      <url>/2022/06/26/Kotlin%E5%B5%8C%E5%A5%97%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin嵌套定义及扩展函数"><a href="#Kotlin嵌套定义及扩展函数" class="headerlink" title="Kotlin嵌套定义及扩展函数"></a><em>Kotlin</em>嵌套定义及扩展函数</h1><h2 id="函数嵌套定义"><a href="#函数嵌套定义" class="headerlink" title="函数嵌套定义"></a>函数嵌套定义</h2><p><strong>为什么有这个特性</strong>？</p><p> 让一些代码块独立，不让外部和类内部的其他方法访问</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">input</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> <span class="comment">//输入</span></span><br><span class="line">input()</span><br><span class="line"><span class="comment">//检测</span></span><br><span class="line">validate()</span><br><span class="line"><span class="comment">//服务器发起请求-&gt; 验证</span></span><br><span class="line">request()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>如果嵌套函数内部想访问其他嵌套函数，必须是在定义之后</li><li>嵌套函数可以访问外部的属性和方法</li></ol><hr><h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h2><p><strong>系统库默认的类无法通过继承添加属性和方法，为final修饰，无法继承</strong></p><p>例如：系统库默认的String类被final修饰（看源码）</p><p>如何在<strong>已有类基础</strong>上添加属性或者方法？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">getNumberCount</span><span class="params">()</span></span>:<span class="built_in">Int</span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="string">&quot;I will win in the end!&quot;</span>.getNumberCount()</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li><p>扩展函数并没有真正在扩展类中添加对应的方法</p></li><li><p>扩展函数通常定义在外部(顶层函数)</p></li><li><p>只有这个类或者子类可以访问对应的扩展函数</p><p>示例如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Father.<span class="title">checkAbility</span><span class="params">()</span></span>&#123;</span><br><span class="line">println(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:<span class="type">Father</span></span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span>:<span class="type">Father</span></span>()</span><br><span class="line">Child().checkAbility()</span><br><span class="line">Child2().checkAbility()</span><br></pre></td></tr></table></figure></li><li><p>如果扩展函数和原有类中的函数重名，原有函数的优先级更高</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Father.<span class="title">checkAbility</span><span class="params">()</span></span>&#123;</span><br><span class="line">println(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:<span class="type">Father</span></span>()&#123;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkAbility</span><span class="params">()</span></span>&#123;</span><br><span class="line">println(<span class="string">&quot;in child&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">Child().checkAbility()</span><br><span class="line">输出结果为：<span class="keyword">in</span> child</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>扩展类方法&#x2F;静态方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Father.Companion.<span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">Father.test()</span><br></pre></td></tr></table></figure><hr></li></ol><h2 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h2><h3 id="为什么要扩展属性？"><a href="#为什么要扩展属性？" class="headerlink" title="为什么要扩展属性？"></a>为什么要扩展属性？</h3><p>通过这个属性触发特定的任务</p><h3 id="什么时候要用扩展函数或者扩展属性？"><a href="#什么时候要用扩展函数或者扩展属性？" class="headerlink" title="什么时候要用扩展函数或者扩展属性？"></a>什么时候要用扩展函数或者扩展属性？</h3><p>不想改变原有代码(系统类、三方库、别人写的、自己写的)的基础上</p><ul><li>添加新的功能</li><li>封装</li></ul><p><strong>注意</strong> </p><ol><li><p>扩展属性不提供默认的field变量，无法存值。其实现的本质为：在里面创建对应get和set静态方法</p></li><li><p>扩展属性和类内部的属性重复，类内部的属性优先级最高</p></li><li><p>本质上扩展属性就是两个扩展函数的集合(<em>var val</em>)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin属性</title>
      <link href="/2022/06/24/Kotlin%E5%B1%9E%E6%80%A7/"/>
      <url>/2022/06/24/Kotlin%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin属性"><a href="#Kotlin属性" class="headerlink" title="Kotlin属性"></a><em>Kotlin</em>属性</h1><h2 id="属性的setter和getter方法"><a href="#属性的setter和getter方法" class="headerlink" title="属性的setter和getter方法"></a>属性的<em>setter</em>和<em>getter</em>方法</h2><h3 id="什么时候需要重写setter和getter方法"><a href="#什么时候需要重写setter和getter方法" class="headerlink" title="什么时候需要重写setter和getter方法"></a>什么时候需要重写<em>setter</em>和<em>getter</em>方法</h3><h4 id="setter"><a href="#setter" class="headerlink" title="setter"></a><em>setter</em></h4><ol><li>外部给我值时，需要做额外的处理</li><li>捕获外部<strong>给值</strong>的时机</li></ol><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a><em>getter</em></h4><ol><li>外部获取值时，需要做额外的处理</li><li>捕获外部<strong>需要</strong>的时机</li><li>懒加载</li></ol><h4 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a><em>Kotlin</em></h4><ol><li><code>field </code>是用来存值的</li><li>提供<code>setter</code>方法</li><li>提供<code>getter</code>方法</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">var</span> age:<span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"> <span class="keyword">set</span>(value) &#123;</span><br><span class="line"> tag = <span class="keyword">if</span> (age <span class="keyword">in</span> <span class="number">1.</span><span class="number">.18</span>) &#123;</span><br><span class="line"> <span class="string">&quot;未成年人&quot;</span></span><br><span class="line"> &#125; </span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="string">&quot;成年人&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line"> field = value</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age:<span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">get</span>() &#123;<span class="comment">// 死循环</span></span><br><span class="line"><span class="keyword">return</span> age <span class="comment">//错误 age在默认调用age的get方法</span></span><br><span class="line"><span class="comment">// 本身又在get方法中 出现死循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age:<span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">set</span>(value) &#123;</span><br><span class="line">age = <span class="number">20</span> <span class="comment">//报错 set方法中 调用set方法</span></span><br><span class="line">field = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更改访问权限</span></span><br><span class="line"><span class="keyword">var</span> age:<span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">set</span> <span class="comment">//内部可以改变(赋值) 外部无法赋值 只能访问</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="延迟初始化-lateinit"><a href="#延迟初始化-lateinit" class="headerlink" title="延迟初始化 (lateinit)"></a>延迟初始化 (<em>lateinit</em>)</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> name: String</span><br></pre></td></tr></table></figure><p><strong>为什么使用</strong>：一个变量必须有值 但是定义时不知道给什么值,后续再赋值 </p><p><strong>注意</strong>：在使用之前必须给值，而且<code>lateinit </code>只能修饰<code>var</code>类型变量</p><hr><h2 id="懒加载-by-lazy"><a href="#懒加载-by-lazy" class="headerlink" title="懒加载 (by lazy)"></a>懒加载 (<em>by lazy</em>)</h2><p>懒加载只会调用一次， 后面访问的是变量的值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">val</span> name:String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">println(<span class="string">&quot;在调用lazy&quot;</span>)</span><br><span class="line">    <span class="string">&quot;jack&quot;</span><span class="comment">// 最后一行作为name的值</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>by lazy</code>只能使用<code>val</code><strong>不能</strong>使用<code>var</code>这个变量，且<strong>只能初始化一次</strong></p><hr><h2 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将属性对象的创建过程交给其他类去完成(代理给外部类完成创建)</span></span><br><span class="line"><span class="comment">// 外部类必须满足：getValue() -&gt; 创建对应的对象</span></span><br><span class="line"><span class="comment">// setValue() 可选 看val var</span></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(obj: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: Car &#123;</span><br><span class="line"><span class="comment">//对象的创建就在这里完成</span></span><br><span class="line">println(<span class="string">&quot;property: <span class="variable">$property</span>&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> Car(<span class="string">&quot;马自达&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(obj: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, car: <span class="type">Car</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> bmw:Car <span class="keyword">by</span> CarFactory()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="静态属性、静态方法与成员属性和方法"><a href="#静态属性、静态方法与成员属性和方法" class="headerlink" title="静态属性、静态方法与成员属性和方法"></a>静态属性、静态方法与成员属性和方法</h2><ol><li><p>实例&#x2F;对象方法，必须有这个类的对象，才能调用它的方法  </p><p>缺点：必须要创建对象 </p><p>优点：有这个对象，就可以操作这个对象的数据 </p></li><li><p>什么情况需要静态方法？ </p><ol><li>如果一个方法 不访问这个类的数据 和 这个类的实例方法</li><li>在项目的多个模块、多个类中，不希望创建对象就能使用某个类的方法</li></ol></li><li><p>静态的特点 </p><ol><li>当类被加载到内存中时，静态的属性或者方法同时被加载 </li><li>此时类和静态属性、静态方法同时存在，就可以直接使用类名访问</li></ol></li><li><p>静态方法中是否可以访问类的属性或者实例方法？</p><p><strong>不可以，静态方法被加载时，对象不存在，所以无法访问对象的属性和方法</strong></p></li><li><p>实例方法中是否可以访问静态方法或者静态属性？</p><ul><li>可以</li><li>当类加载时，静态方法和静态属性已经被加载了， 创建对象之后，就可以在对象方法中访问已经存在的静态内容</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>真正的兴趣</title>
      <link href="/2022/06/22/%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%85%B4%E8%B6%A3/"/>
      <url>/2022/06/22/%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%85%B4%E8%B6%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="真正的兴趣"><a href="#真正的兴趣" class="headerlink" title="真正的兴趣"></a>真正的兴趣</h1><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul><li><h3 id="此文作者为知心冰冰，此文仅为转载，可见《冰冰成长心语集》"><a href="#此文作者为知心冰冰，此文仅为转载，可见《冰冰成长心语集》" class="headerlink" title="此文作者为知心冰冰，此文仅为转载，可见《冰冰成长心语集》"></a>此文作者为知心冰冰，此文仅为转载，可见《冰冰成长心语集》</h3></li><li><h3 id="本博客仅因为此文写的确实不错，触动人心，特此转载"><a href="#本博客仅因为此文写的确实不错，触动人心，特此转载" class="headerlink" title="本博客仅因为此文写的确实不错，触动人心，特此转载"></a>本博客仅因为此文写的确实不错，触动人心，特此转载</h3></li></ul><h3 id="一-“-听你讲得这么灵动，我倒是感‘兴趣’了！”"><a href="#一-“-听你讲得这么灵动，我倒是感‘兴趣’了！”" class="headerlink" title="一 “ 听你讲得这么灵动，我倒是感‘兴趣’了！”"></a><strong>一</strong> <strong>“</strong> <strong>听你讲得这么灵动，我倒是感‘兴趣’了！”</strong></h3><p>大一的时候，我曾经跟几个小伙伴一起向校方递交过一份技术社团申请书，数日之后，校方领导就技术社团的申请问题找我洽谈，在洽谈之中，他们一致提议把我们即将创办的社团与另外一个社团合并到一起，说起来，起初我是坚决不同意这种做法的，因为我很清楚，一旦合并，就意味着我们将失去主控权，但是当时摆在我们面前的有这样使我们不得不认真思索的几个问题——–一来是学校不会选择给我们配备资源，因为他们觉得是在消耗资源，二来是我们还是学生，没有这么大的财力去建设属于自己的资源，三来是另外一个社团有着丰富的资源，并入其中，原来我们考虑的资源问题就迎刃而解了！在综合各种因素的考虑之后，我带着我的团队并入了另外一个社团，我也成为了他们社团的其中一个技术讲师，负责日常的教学活动！</p><p>就这样，我们成了那个社团的其中一员，穿上了由那个社团量身定制的会服和会卡，然后出席着由该社团举办的各项活动……一切看似悄无声息地进行着，但其实有一种叫做矛盾的东西，从一开始就穿插在我们的生活之间，只是我们都没有察觉罢了，日子一天天地过，这样的矛盾也在不断加剧，终于有一天，它忍不住爆发了———-“老大，都怪你，把我们并进来”，“老大，我们想退出了”，“老大，我知道你很用心，可这东西学起来太难了，我们不是这块料！”，“老大，对不起，我们不学了”…….”我能够理解你们，可是当初我不是一早就跟你们说过这东西不好学的吗？你们还异口同声地跟我说你们对这很感兴趣，再难也会学下去！”，“老大，你之前的一些公开课，我们有听过，<strong>当时我们觉得你讲得那么灵动，那么有趣，于是就起了兴趣</strong>，想学这个，只是没想到这个定西这么难学，所以就打算放弃了，老大，对不起，我们真的学不下去了，而且自从进了这个社团，每天破事那么多，我们有点累”，“你们…哎，算了，你们走吧！强留你们也没意思”，“谢谢老大”，“走走走，我们走，我王者还等着上铂金呢？”……他们走了之后，我一个人对着黑板，发呆了很久很久，从那一刻起，我瞬间明白了，<strong>别人嘴里说出来的喜欢和兴趣是靠不住的，这样简单的一句喜欢，简单的一句兴趣，任谁都可以随口而出，并不需要费很大的劲！</strong></p><p>忽然想起这样一首歌：《走着走着就散了》，有些人因为一句兴趣，一句喜欢走到了一起，匆匆地凑合，却因一句“对不起，我不感兴趣了，我不喜欢了”一拍而散，匆匆地离场，来也匆匆，去也匆匆，因兴趣和喜欢结了缘，本该是一件好事，可世事总难料，<strong>有些人走着走着，注定是散场，他们所谓的兴趣，所谓的爱好，从一开始，早就失去了应有的灵魂</strong>，<strong>你不是真正的喜欢和感兴趣，自然你也不会有真正的快乐！因此散了也罢，勉强地扯在一起，徒增烦恼而已，又何必纠结于此……</strong></p><hr><h3 id="二-“喜欢便是享受”"><a href="#二-“喜欢便是享受”" class="headerlink" title="二 “喜欢便是享受”"></a><strong>二</strong> <strong>“喜欢便是享受”</strong></h3><h3 id="“你喜欢读书写文章呀！我也很‘喜欢’耶！”"><a href="#“你喜欢读书写文章呀！我也很‘喜欢’耶！”" class="headerlink" title="“你喜欢读书写文章呀！我也很‘喜欢’耶！”"></a><strong>“你喜欢读书写文章呀！我也很‘喜欢’耶！”</strong></h3><p>前段时间，我曾应朋友之邀，去他家做客，看到我来了，他很是热情，先是招呼我到合适的位置坐下，给我倒了一杯热茶，上了些许点心过后，便跑去厨房施展他的厨艺去了，说起来，他这人还真有一点趣头，千辛万苦把我邀请过来，其实不为别的，就为了让我品尝一下他最近做的几款新菜！</p><p>许久过后，他兴高采烈地端出他的佳作，小心翼翼地放在我面前,一股诱人的芳香瞬间扑鼻而来，“发呆干啥，赶快试试我的手艺如何？”，我迟疑了一下，方才拿起筷子，夹了一块放在嘴里，“哇，你近来手艺增长了不少耶，很好吃，真的！”，他噗嗤一笑道：“那是，你不看看我是谁，快吃，好吃就多吃点”，“咦，看把你嘚瑟得什么样，啧啧啧！”话音刚落，他拿起了另外一个筷子，便把菜往我碗里夹，“行了，行了，我自己来，我自己来，你也辛苦了，你坐下一起吃吧！”他点了点头，然后拉了下凳子，坐了下来，拿起筷子，夹了几口菜，放在自己的碗里，见我吃得津津有味，他开始滔滔不绝跟我分享他的做菜故事，我顿然有点享受这样的惬意，一边是美味的食物，一边是精彩的故事，更重要的是，还有这样一位“中看又中用”的厨师帅哥的陪伴，突然间想感慨这样一句———“此曲只应天上有，人间能得几回闻”，自从出来工作，已经很久没有这么享受过生活了，我说我甚是羡慕他懂得如此享受生活，他却摸了摸头，傻傻地笑了，回道：“其实只要你愿意，你也可以这么去享受生活的，<strong>你记住我的一句话——喜欢便是享受，</strong>你看我，虽然谈不上有什么爱好啥的。但我唯独喜欢做菜，当然有空的时候，我也会写写菜谱之类的！”,”对，你说得太对了，<strong>喜欢便是享受！</strong>”……</p><p>那日，他翻出了他撰写的菜谱给我看，身同感受，是的，<strong>他是真的喜欢做菜</strong>，<strong>这才是真正的喜欢，真正的感兴趣，</strong>我不禁意间想起另外一个朋友来，一次，他在微信给我发信息，问道：“近来可好？现在在做什么呢？”，我礼貌性地回了一句：“谢谢你的问候，我近来一切都好着呢？我现在的话，正坐在书桌前，喝着一杯小茶，读着一本书，等会心血来潮。估计又要落笔成文了，哈哈哈”，过了一会，手机叮咚了下，我打开微信，只见他回道：“哇塞，这么优雅惬意的生活，佩服佩服！，<strong>你这么喜欢读书，这么喜欢写文章</strong>，那有没有人告诉你，<strong>我也喜欢这样的生活耶！</strong>”，微信的这头，我噗嗤一笑，顺道灰锴了一下他，道：“得了吧你，我又不是没去过你家，难道你忘记了吗？你家一本书都没有，连笔也不一定找得到，所以你是在逗我，我们认识了那么久，上学那会。每次老师布置作文作业，有哪次不是你让我帮你写的，本来我都不想帮你写的，要不是你苦苦哀求，又是这样那样的，我才懒得理你，而且你要知道，每次写两个作业有多累，哈哈哈！”，信息发出的时候，当时我在想，微信那头，看到信息的他，脸到底有多黑？许久过后，他才发来信息，哈哈一番道：“陈年旧事，不值得一提了啦！你忙吧！不能耽误你工作！”。就这样，我跟他匆匆结束了话题！其实想来也颇有一番顿悟，他是个浪荡不羁的人，注定按捺不住自己的心，无法平静下来，他朋友圈总是晒着一堆旅游照，今天在一个地方，明天又在另一个地方，生活很是潇洒，但回到当我说我喜欢读书写文章，他附和说自己也喜欢和感兴趣的这个问题上，我想我顿然明白了一个道理：所谓的喜欢和感兴趣有时已经沦为别人套近乎，拉近距离，博取共鸣之感的手段，<strong>人生在世，谁不希望有几个志同道合之人为友呢？这样子自己不显得过于孤单，那是一种来自内心强烈的渴望</strong>，在这样一种渴望的驱动之下，你喜欢的和感兴趣的东西，他说他也喜欢和感兴趣的时候，自然，你便有了巴不得跟他立马成为好朋友的一丝瞎想！<strong>他所谓的感兴趣，所谓的喜欢，从一开始便失去了应有的灵魂，这也就注定了有一天你们不会在一个频道上前进！</strong></p><p><strong>真正的感兴趣，真正的喜欢，就像我那位厨师朋友那样，是发自内心真真切切的渴望，不是形式上的美好，也不是让别人摸不着边际的套路，它是有自己灵魂的，缺了灵魂的兴趣和喜欢，注定不是真正的兴趣，真正的喜欢！</strong></p><hr><h3 id="三-“我一直喜欢……”"><a href="#三-“我一直喜欢……”" class="headerlink" title="三 “我一直喜欢……”"></a><strong>三</strong> <strong>“我一直喜欢……”</strong></h3><p>一次活动，我偶然认识了小A，相互加了微信，也聊了一段时间，她告诉我说：“冰冰姐，<strong>其实我一直很喜欢画画</strong>，于是读了设计专业，但是毕业出来的时候，在机缘巧合之下，却做了销售！”，我问她说：“那你为什么不考虑去从事设计相关的工作呢？”，她说：“刚开始的时候，我确实挺想从事这一行的，但是面试了很多家公司，都没有通过，那时我很沮丧，偶然间看到一家公司在招销售岗位，我觉得自己口才还不错，于是就去面试了，结果没想到通过了，自此我便做了销售，与设计再也无缘了”，听到这里，我叹了一口气，安慰道：“哎，可惜了，不过我现在抛开你的职业不说，只想问你这样的一个问题，你必须特别认真地回答，先不急着回答我，你考虑清楚之后，再告诉我答案！”。</p><p>几天之后，她回复了我说：“冰冰姐，我想清楚了，我还是那一句话，<strong>我一直很喜欢画画</strong>！”，我有点开心，回复道：“很好啊！其实我想听到是你这样的回答，坚持初心，才能方得始终！当然我还有一个问题，需要你认认真真的回答我，你有自己的作品集吗？”，大概了过了一会，她回复我说：“啊，冰冰姐，我没有作品集哟！而且我已经很久没有画过了，更别说作品集了……”,我皱了下眉头，忽然有点丧，回道说：“那你收回你那句’一直很喜欢’的话吧！因为你不是真的喜欢画画，你不是真的对画画感兴趣！”,“为什么呀！<strong>我是真的一直很喜欢画画</strong>，就是工作忙了点，没时间画，当然还有别的因素，我平常也有关注一些画画的论坛，公众号之类的，看别人的一些作品，如果我不是喜欢的话，那又如何解释呢？要不然冰冰姐，你给我说说什么才是真正的喜欢，真正的感兴趣！”,“等你画了几幅画之后，自然就会明白了！”,“好！那冰冰姐，到时我还是不懂的话，我再请教你，哈哈哈！”。</p><p>2个月后，她用手机拍了她画的几幅画，发了给我，我定是惊喜，回道：“不错啊，怎么样，你领悟到了什么才是真正的喜欢和感兴趣了吗？”“哈哈哈，我好像明白了，<strong>真正的喜欢和感兴趣，不是形式上的美好，也不是靠嘴巴说出来的，是靠行动和实践出来的，对一个喜欢画画的人来说，如果没有自己的作品集，其实并谈不上什么喜欢，更谈不上什么感兴趣！</strong>”，“正解，这就是我要让你领悟的东西！<strong>真正的兴趣和喜欢，需要配以极强的行动力才能称得上是真正的，它是有灵魂的，倘若一个人对一件事很感兴趣，很喜欢，那么他心里更渴望的是在这件事有所建树</strong>，<strong>而要有建树，就必须有强大的行动力！当然，也请你记住这样一句话：越是逆境，越是能够坚持的东西，才配得上叫兴趣，叫做喜欢！</strong>”，”明白了，谢谢冰冰姐，我知道怎么做了！”。</p><p>数月之后，她开心地跟我说她转型做了设计师，并完成了属于自己人生的第一本画集！人生有时往往这样，<strong>你不逼自己一把，你永远不知道自己有多优秀！</strong></p><hr><h3 id="四-“我发现我对你突然很感‘兴趣’，我‘喜欢’上你怎么办？”"><a href="#四-“我发现我对你突然很感‘兴趣’，我‘喜欢’上你怎么办？”" class="headerlink" title="四 “我发现我对你突然很感‘兴趣’，我‘喜欢’上你怎么办？”"></a><strong>四</strong> <strong>“我发现我对你突然很感‘兴趣’，我‘喜欢’上你怎么办？”</strong></h3><p>微友小B，是我在一个社群上加的，那时加他，纯粹只是为了业务需要，空闲时，我会跟他聊天，我很乐意跟他分享一些东西，当然他也很乐意跟我分享关于他的，有时觉得互联网最强大的一个地方，就是让两个素未谋面的人相逢于线上，这也许就是缘分吧！</p><p>我跟他聊了大概有一个月左右，本以为会一直以聊友的关系保持着联系，可是有一天，情况终于变了，他忽然给我发了一句这样的信息：“<strong>我发现我对你突然很感兴趣，我喜欢上你了怎么办？</strong>”，起初看到这样的信息，我并不太想回复，但是出于礼貌，我还是选择了回复，道：“这样子啊，很好，那我问你几个问题！，你必须认真回答我”，“可以啊，是不是要考验我啊！哈哈，那你快点问！”，“好，第一个问题就是你知道我平常都喜欢吃什么，穿什么颜色的衣服吗？”，“不知道”，“第二个问题就是你知道我平常都喜欢去哪些地方玩吗？”“不知道”，“第三个问题就是你知道我最喜欢做的事是什么吗？”，“不知道”，“第四个问题就是你知道我的梦想是什么吗？”，“不知道”……”好了，我问完了，你出局了！”，“为啥呀，你连机会都不给我，那我怎么了解你！”，“不不不，因为你不是一个用心之人，我刚刚问你的好几个问题，其实在我朋友圈都有过一丝痕迹，只是你缺了耐心去翻罢了，真正对一个人感兴趣，真正喜欢一个人并不是这样子的……因为感兴趣，因为喜欢，才会主动去了解！”“这样子啊，那我现在去翻下，看一下可以吗？”，“不了，你出局了，你不是真的对我感兴趣，也不是真的喜欢我，你只是想摆脱单身的状态罢了！”，“好吧，不好意思，打扰了！”……自此，他再也没找我聊过天！</p><p>这个世界上，总有一种让你特别揪心的生物，聊着聊着就说对你感兴趣，聊着聊着就说喜欢你，聊着聊着就说爱上你，没错，这种生物就是那些忽然给你发微信说<strong>“我发现我对你突然很感兴趣，我喜欢上你怎么办？”的人！</strong>微信式的告白，抛开那个自己真的喜欢的人不说，倒是显得有些浮躁，你到底了解对方多少，喜欢对方什么，可能连你自己都不清楚，你是为了摆脱脱单的状态？还是真的感兴趣？真的喜欢？<strong>感情就是一个特别微妙的东西，本就来不得一丝马虎，因为谁都不希望跟着一个感情敷衍的人过一辈子，谁也不愿意冒着风险在感情上做赌注，爱对了，就是爱情，爱错了，就是青春</strong>，真的喜欢一个人，真的对一个人感兴趣，就会迫不及待地想去了解，而不是等着对方来告诉你，当对方愿意告诉你的时候，是因为信任……</p><p><strong>终有一天，当你明白真正的喜欢，真正的感兴趣，是有自己的灵魂的</strong>，也许你就真真正正地，透彻地懂得了自己的心！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin构造函数与单例</title>
      <link href="/2022/06/21/Kotlin%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8D%95%E4%BE%8B/"/>
      <url>/2022/06/21/Kotlin%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8D%95%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin构造函数与单例"><a href="#Kotlin构造函数与单例" class="headerlink" title="Kotlin构造函数与单例"></a><em>Kotlin</em>构造函数与单例</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>类是同一类事物的高度抽象的，不实际存在的（不会占内存）的概念</li><li>对象是类的实例化，现实化（具体存在，完成具体任务&lt;存值，执行&gt;）</li><li>存值：成员变量，属性变量</li><li>执行：行为，方法</li></ul><hr><h2 id="为什么要有构造函数？"><a href="#为什么要有构造函数？" class="headerlink" title="为什么要有构造函数？"></a>为什么要有构造函数？</h2><ol><li><p>默认的无参构造函数  </p><p>类本身不知道如何创建⾃⼰的对象，对象本身是由顶层类来构建，再由当前这个类来初始化那个对象</p></li><li><p>重载的有参构造⽅法  </p><ol><li>为了⽅便给初始化值  </li><li>在创建对象的同时给予某些需要的数据(时机)</li></ol></li></ol><hr><h2 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h2><h3 id="单例对象概念"><a href="#单例对象概念" class="headerlink" title="单例对象概念"></a>单例对象概念</h3><p>当我们巧妙使⽤private来私有化构造⽅法，给外部提供⼀个单例对象(整个程序运⾏中这个类只有⼀个对象)</p><h3 id="如何得到单例对象"><a href="#如何得到单例对象" class="headerlink" title="如何得到单例对象"></a>如何得到单例对象</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a><em>Java</em></h4><ol><li><p><strong>私有化</strong>构造⽅法 -&gt; 使<strong>外部⽆法</strong>创建这个类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Animal</span><span class="params">()</span>&#123;&#125; </span><br></pre></td></tr></table></figure></li><li><p>在<strong>类内部</strong>提供⼀个<strong>静态</strong>的成员属性 -&gt; 静态变量只会初始化<strong>⼀次</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Animal</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br></pre></td></tr></table></figure></li><li><p>给外部提供⼀个<strong>静态⽅法</strong> -&gt; 获取这个对象</p><p><strong>注意</strong>: 此处未考虑内存消耗和线程安全 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title function_">getInstance</span><span class="params">()</span>&#123; <span class="keyword">return</span> instance; &#125;</span><br></pre></td></tr></table></figure></li><li><p>外部获取这个对象 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal.getInstance();</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意</strong>：系统类库中以下开头的⽅法通常都是提供<strong>单例</strong></p><ul><li><strong>instance</strong></li><li><strong>shared</strong></li><li><strong>default</strong></li></ul><hr><h4 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a><em>Kotlin</em></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()&#123;<span class="comment">// kotlin单例不完善版本</span></span><br><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">val</span> defaultInstance = Animal()</span><br><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: Animal &#123;</span><br><span class="line"> <span class="keyword">return</span> defaultInstance</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;<span class="comment">// kotlin单例一般写法</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> sharedAnimal: Animal <span class="keyword">by</span> lazy(LazyThreadSafetyMode.SYNCHRONIZED) &#123;</span><br><span class="line">            Animal()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Kotlin构造函数"><a href="#Kotlin构造函数" class="headerlink" title="Kotlin构造函数"></a>Kotlin构造函数</h2><ol><li><p>主构造函数 </p><ul><li><p>创建⼀个没有主体的类 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span></span><br></pre></td></tr></table></figure></li><li><p>显示指定构造⽅法 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> <span class="keyword">constructor</span></span>() </span><br></pre></td></tr></table></figure></li><li><p>主构造函数需要传递⼀个字符串对象 constructor不能省略</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person3</span> <span class="keyword">constructor</span></span>(<span class="keyword">var</span> name:String) </span><br></pre></td></tr></table></figure></li><li><p>有修饰符限定构造函数权限时 constructor不能省略 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person4</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() </span><br></pre></td></tr></table></figure></li><li><p>如果有⽗类，必须直接调⽤⽗类的构造函数 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person5</span> : <span class="type">Father</span></span>() </span><br></pre></td></tr></table></figure></li><li><p>如果⽗类有参数 ⼦类必须提供相应有参的构造函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Father2</span> <span class="keyword">constructor</span></span>(name: String) </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person6</span> <span class="keyword">constructor</span></span>(name: String) : Father2(name) </span><br></pre></td></tr></table></figure></li></ul><hr></li><li><p>次构造函数 </p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(name:String) : <span class="keyword">this</span>()&#123;&#125; </span><br><span class="line"><span class="comment">// 注意：</span></span><br><span class="line"><span class="comment">//     a.次构造函数必须直接调⽤主构造函数 </span></span><br><span class="line"><span class="comment">//     b.如果有⽗类，必须调⽤⽗类的构造函数 </span></span><br></pre></td></tr></table></figure><ul><li><p>次构造函数必须继承主构造函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person7</span></span>(name: String) &#123; </span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>): <span class="keyword">this</span>(name)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>次构造函数只需要考虑和主构函数的关系</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Father3</span> <span class="keyword">constructor</span></span>(name: String)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person8</span> <span class="keyword">constructor</span></span>(name: String) : Father3(name)&#123; </span><br><span class="line"><span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>):<span class="keyword">this</span>(name) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的equals()和==</title>
      <link href="/2022/06/18/Java%E7%9A%84equals-%E5%92%8C/"/>
      <url>/2022/06/18/Java%E7%9A%84equals-%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Java的equals-与-x3D-x3D"><a href="#Java的equals-与-x3D-x3D" class="headerlink" title="Java的equals()与&#x3D;&#x3D;"></a><em>Java</em>的equals()与&#x3D;&#x3D;</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><em>java</em>中的<code>euqals()</code>是<strong>成员方法</strong></li><li>而<code>==</code>是<strong>运算符</strong></li></ol><p>切记、切记、切记！！！</p><hr><h2 id="x3D-x3D"><a href="#x3D-x3D" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h2><ol><li>如果等号两边比较的对象为基本数据类型，则比较是变量存储内容的值（<em>value</em>)，即比较等号两边<strong>数值</strong>是否相等</li><li>如果等号两边比较的是引用类型，则比较的是<strong>其存储的对象内存地址</strong>是否相等</li></ol><p><strong>注意</strong>：</p><ul><li><em>Java</em>只有值传递（<em>call by value</em>）</li><li>String类型以及你自己创建的对象都是引用类型</li><li>引用类型变量存储的是<strong>对象</strong>在堆中的<strong>地址</strong></li><li>因为<em>Java</em>只有值传递，所以对于<code>==</code>，无论&#x3D;&#x3D;两边比较的是什么，其本质比较的都是值（<em>value</em>)</li></ul><hr><h2 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h2><h3 id="equals-方法没有被覆盖"><a href="#equals-方法没有被覆盖" class="headerlink" title="equals()方法没有被覆盖"></a>equals()方法没有被覆盖</h3><ul><li><p>通过<code>equals()</code>比较类的两个对象是，相当于通过<code>==</code>比较对象，使用的是<em>Object</em>类的<code>equals()</code></p><p>Object类的equals方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="equals-方法被类覆盖"><a href="#equals-方法被类覆盖" class="headerlink" title="equals()方法被类覆盖"></a>equals()方法被类覆盖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;s1==s2: &quot;</span> + (s1 == s2));</span><br><span class="line">        System.out.println(<span class="string">&quot;a==b: &quot;</span> + (a == b));</span><br><span class="line">        System.out.println(<span class="string">&quot;a.equals(b): &quot;</span> + (a.equals(b)));</span><br><span class="line">        System.out.println(<span class="string">&quot;42 == 42.0 : &quot;</span> + (<span class="number">42</span> == <span class="number">42.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果</span><br><span class="line">s1==s2: true</span><br><span class="line">a==b: false</span><br><span class="line">a.equals(b): true</span><br><span class="line">42 == 42.0 : true</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li><em><strong>String中的 equals方法是被重写过的，因为 Object的 equals方法是比较的对象的内存地址，而 String的 equals方法比较的是对象的值</strong></em></li><li><em><strong>当创建 String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String对象</strong></em></li></ul><h3 id="String类中的equals方法源码："><a href="#String类中的equals方法源码：" class="headerlink" title="String类中的equals方法源码："></a>String类中的equals方法源码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li><em>equals</em>方法不能用于判断基本数据类型的变量，如只能用来判断两个对象是否相等</li><li>如果没有对equals方法进行<a href="https://so.csdn.net/so/search?q=%E9%87%8D%E5%86%99&spm=1001.2101.3001.7020">重写</a>，则比较的是引用类型的变量所指向的对象的地址。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2022/06/17/JDBC/"/>
      <url>/2022/06/17/JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a><em>JDBC</em></h1><h2 id="JDBC简介"><a href="#JDBC简介" class="headerlink" title="JDBC简介"></a><em>JDBC</em>简介</h2><p><em>JDBC</em>（<em>Java Data Base Connectivity</em>）是一套基于<em>Java</em>语言实现的、执行<em>SQL</em>语句的<em>Java</em> API（Application Programming Interface），它屏蔽了于数据库通信的细节，使<em>Java</em>应用程序调用<em>JDBC</em> API ，即可发送<em>SQL</em>语句访问数据库</p><hr><h2 id="JDBC框架"><a href="#JDBC框架" class="headerlink" title="JDBC框架"></a><em>JDBC</em>框架</h2><ol><li><em>JDBC API</em>：提供应用程序与JDBC驱动管理器之间的连接</li><li><em>JDBC</em> 驱动管理器（<em>JDBC Driver Manager</em>)：装载并管理数据库驱动器，建立与数据库之间的连接  </li><li><em>JDBC</em> 驱动器API（<em>JDBC Driver API</em>)：负责JDBC驱动管理器与驱动器的连接</li><li><em>JDBC</em> 驱动器（<em>JDBC Driver</em>)：负责与数据库连接</li></ol><img src="https://ezralinblogpicture-1311676448.cos.ap-chongqing.myqcloud.com/blogPicture/ JDBC.jpg"/><hr><h2 id="编写JDBC-API应用程序"><a href="#编写JDBC-API应用程序" class="headerlink" title="编写JDBC API应用程序"></a>编写<em>JDBC API</em>应用程序</h2><ol><li><p>选择并加载一个合适的JDBC驱动程序</p></li><li><p>创建一个Connection对象，建立与数据库的连接</p></li><li><p>创建一个Statement对象或PreparedStatement对象（普遍采用）</p></li><li><p>通过Statement对象或PreparedStatement对象执行SQL语句，进行数据库操作</p></li><li><p>返回ResultSet结果集，并通过返回的ResultSet对象获取相应的数据</p></li><li><p>关闭相关连接，清理对象</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConnection</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;<span class="comment">//选择并加载一个合适的JDBC驱动程序</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;驱动程序无法加载!&quot;</span>);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//创建一个Connection对象，建立与数据库的连接</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/javahomework?characterEncoding=utf8&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">userPassword</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn = DriverManager.getConnection(url, userName, userPassword);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;]()</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">findStudentByName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">List&lt;Student&gt;list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseConnection.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from student where name like ?&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个Statement对象或PreparedStatement对象</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;%&quot;</span>+name+<span class="string">&quot;%&quot;</span>);</span><br><span class="line">            <span class="comment">//返回ResultSet结果集，并通过返回的ResultSet对象获取相应的数据</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">stu.setNumber(rs.getString(<span class="string">&quot;number&quot;</span>));</span><br><span class="line">stu.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">stu.setGender(rs.getString(<span class="string">&quot;gender&quot;</span>));</span><br><span class="line">stu.setProfession(rs.getString(<span class="string">&quot;profession&quot;</span>));</span><br><span class="line">stu.setMath(rs.getInt(<span class="string">&quot;math&quot;</span>));</span><br><span class="line">stu.setChinese(rs.getInt(<span class="string">&quot;chinese&quot;</span>));</span><br><span class="line">stu.setComputer(rs.getInt(<span class="string">&quot;computer&quot;</span>));</span><br><span class="line">stu.setTotal(rs.getInt(<span class="string">&quot;total&quot;</span>));</span><br><span class="line">list.add(stu);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//关闭相关连接，清理对象</span></span><br><span class="line">rs.close();</span><br><span class="line">ps.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>具体语法太简单，在此不做说明，如有需要请阅读：<a href="https://www.runoob.com/java/java-mysql-connect.html">Java MySQL 连接 | 菜鸟教程 (runoob.com)</a></p><p>主要是理清<em>JDBC</em>的框架，这样编写程序就没有太大问题</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内部类</title>
      <link href="/2022/06/16/Java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2022/06/16/Java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内部类"><a href="#Java内部类" class="headerlink" title="Java内部类"></a><em>Java</em>内部类</h1><h2 id="内部类的概念"><a href="#内部类的概念" class="headerlink" title="内部类的概念"></a>内部类的概念</h2><ul><li>内部类是在另一个类或方法的定义中定义的一个类，即在其他类或方法内部定义的类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">StoneVillage</span> &#123;<span class="comment">//内部类——石村</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部类作用"><a href="#内部类作用" class="headerlink" title="内部类作用"></a>内部类作用</h2><ol><li><p>实现类的重用功能</p><ul><li>把一个类的定义全部放入类体中，使其可以被直接使用，不必通过创建对象来使用，实现类的重用</li></ul></li><li><p>实现多重继承</p><ul><li>如果一个类已经继承与另一个类，此时这个类的内部类可以再继承于另一个类，就相当于继承两个类</li></ul></li><li><p>增强封装</p><ul><li>可以把一些数据隐藏在内部类中，使用时，不必声明该内部类的具体对象，而通过外部类对象调用内部类数据</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 内部类的所有属性和方法外部均可调用,无论其访问权限如何</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawWater</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StoneVillage</span> <span class="variable">stoneVillage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StoneVillage</span>();</span><br><span class="line">        stoneVillage.machine = <span class="string">&quot;Water pump&quot;</span>;</span><br><span class="line">        stoneVillage.use();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">StoneVillage</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String machine;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The water pump was used&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// main函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.drawWater();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><ul><li>如果不希望通过外部类使用内部类，可以把内部类声明为<em>static</em>,这样内部类就可以在类外直接访问</li><li>静态内部类因为已经声明为static，所以它只能访问外部类的静态属性和静态方法</li><li>静态内部类若想访问外部类的非静态属性和方法，可以先实例化一个外部类对象访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span> &#123;</span><br><span class="line">            o.i = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="匿名内部类-anonymous-inner-class"><a href="#匿名内部类-anonymous-inner-class" class="headerlink" title="匿名内部类(anonymous inner class)"></a>匿名内部类(<em>anonymous inner class</em>)</h2><ul><li>当内部类名字被省略时，我们称此时的内部类为匿名内部类</li><li>通常在方法中使用，即方法中定义的省略了名字的内部类</li><li>匿名内部类可以访问所有的外部类的方法变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Paper <span class="title function_">pp</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 从内部类定义开始</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Paper</span>() &#123;</span><br><span class="line">            <span class="keyword">private</span> String line;</span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">mark</span><span class="params">()</span> &#123;</span><br><span class="line">                line = s;</span><br><span class="line">                <span class="keyword">return</span> line;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; <span class="comment">// return 语句结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Paper</span> <span class="variable">c</span> <span class="operator">=</span> test.pp(<span class="string">&quot;I will win in the end!&quot;</span>);</span><br><span class="line">        System.out.println(c.mark());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java接口与多态</title>
      <link href="/2022/06/16/Java%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
      <url>/2022/06/16/Java%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Java接口与多态"><a href="#Java接口与多态" class="headerlink" title="Java接口与多态"></a><em>Java</em>接口与多态</h1><hr><h2 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（<em>interface</em>）</h2><ul><li><p>接口概念</p><ul><li>接口类似于一种“插件”，只要“接上”就能使用，但这种“插件”需要自己具体实现</li><li>接口是类与类之间连接的通道，不同类之间可以通过接口互通信息，从而实现类与类之间的资源交互</li></ul></li><li><p>接口用途</p><ol><li>实现多重继承</li><li>统一规范</li></ol></li></ul><hr>### 接口的声明及实现  <h4 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h4><ul><li><p>接口使用关键字<em><strong>interface</strong></em></p></li><li><p>在接口中，所有定义的常量默认修饰为<em>public static final</em>  </p></li><li><p>在接口中，所有定义的方法默认修饰为<em>public abstract</em> ,当然可以自己显示修饰</p></li></ul><p><strong>注意</strong>：</p><ul><li>接口没有构造方法，不能被实例化，<em>JDK8</em>之后允许在接口中使用默认方法和静态方法</li><li>接口中的静态方法可以具体实现，默认方法不要求实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">driverCar</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">required</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;default method&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">route</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;a static function is defined&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><ul><li>接口通过具体类来实现，即通过类实现接口，不能采用new运算符创建对象方式生成，接口只是”插件“，不能离开具体的类  </li><li>接口使用关键字<em><strong>implements</strong></em>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnlineShopping</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addToShoppingCart</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">food</span> <span class="keyword">implements</span> <span class="title class_">OnlineShopping</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToShoppingCart</span><span class="params">()</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h4><p>接口可以实现多继承，如同*C++*里面的一般。但是继承后，<strong>实现接口时，需要将父类的抽象方法一同实现</strong>。</p><p>就如同斗罗大陆里面的双生武魂，同时拥有其父母的武魂，后天需要给两个武魂分别配置魂环</p><p><strong>注意</strong>：<em>Java</em>不支持多继承，但是支持实现多个接口（而且接口可以多继承）这样就达到了多继承的目的以便于完成相应的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HaoTianHammer</span> &#123;<span class="comment">// 昊天锤</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hit</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlueGrass</span> &#123;<span class="comment">// 蓝银草</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">entangle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TwinMartialSoul</span> <span class="keyword">extends</span> <span class="title class_">HaoTianHammer</span>, BlueGrass &#123;<span class="comment">// 双生武魂</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">TwinMartialSoul</span> &#123; <span class="comment">// 实现多继承的接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hit</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">entangle</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="多态（polymorphism"><a href="#多态（polymorphism" class="headerlink" title="多态（polymorphism)"></a>多态（<em>polymorphism</em>)</h2><h3 id="多态实质"><a href="#多态实质" class="headerlink" title="多态实质"></a>多态实质</h3><ul><li>多态实质上是由向上转型（<em>upcasting</em>）和动态绑定（dynamic binding）机制结合完成</li><li>多态就是对于同一个消息，不同对象做出不同的行为</li><li>多态需要和<strong>继承</strong>配合使用，需要重写方法</li><li>多态是一种继承关系下，基于动态绑定机制的接口实例</li></ul><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>子类对象赋值给父类对象，子类舍弃自己的特征——“返祖”</li><li>子类向上转型后，只能调用父类定义的方法，不能调用父类没有而子类有的方法</li></ul><p><strong>注意</strong>：当子类与父类含有<strong>同名</strong>的方法时，子类对象向上转型而生成的父类对象能<strong>自动调用子类的方法</strong>，此种用法运用广泛</p><hr><h3 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h3><h4 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h4><ul><li><p>将一个方法调用同一个方法所在的类关联在一起就是<strong>绑定</strong></p></li><li><p>绑定分为静态绑定和动态绑定  </p><ul><li><p>静态绑定  </p><p>在编译前，编译器就能确定应该调用哪个方法，此时绑定在运行前完成，也称为<strong>前期绑定</strong>。</p><p>一般来说，静态绑定的代码写法是<strong>写死的</strong>，也可以根据此判断是否为静态绑定</p></li><li><p>动态绑定</p><p>程序在<strong>运行期间</strong>由<em>JVM</em>根据对象的类型自动判断应该调用哪个方法，也称为<strong>后期绑定</strong> 。</p><p>也就是说，在运行时才能把方法调用与方法所属类关联在一起</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态绑定</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">tangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        tangsan.play();<span class="comment">//通过对象调用方法，属于静态绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多态绑定</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person[] persons = <span class="keyword">new</span> <span class="title class_">Person</span>[<span class="number">7</span>];<span class="comment">// 生成对象数组，史莱克七怪</span></span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; persons.length; i++) &#123;</span><br><span class="line">            n = r.nextInt(<span class="number">7</span>)</span><br><span class="line">            <span class="keyword">switch</span>(n) &#123;<span class="comment">//Person1,Person2均为Person的子类</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: persons[i] = <span class="keyword">new</span> <span class="title class_">Person1</span>(); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: persons[i] = <span class="keyword">new</span> <span class="title class_">Person2</span>(); <span class="keyword">break</span>;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; persons.length; i++) &#123;</span><br><span class="line">                persons[i].play();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上实例可以看出，编译时，persons[i].play()无法确定调用的是Perosn的哪一个子类的方法，只有运行时，才能确定，这就是动态关联</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2022/06/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/06/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a><em>Java</em>多线程</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul><li>进程是一个可运行的程序，启动一个程序就启动了一个进程</li><li>一个线程内可以启动多个程序，线程也称为轻量级进程（<em>light-weight process</em>)</li><li>每个进程各自独自一份内存空间，一个进程内的多个线程属于同一个进程</li><li>多个线程共同处于一个内存空间的优势在于能直接共享数据和资源</li></ul><hr>  <h2 id="多线程创建方式"><a href="#多线程创建方式" class="headerlink" title="多线程创建方式"></a>多线程创建方式</h2><ul><li>生成一个<em>Thread</em>类的对象来创建线程</li><li>编写一个类，实现<em>Runnable</em>接口，然后在<em>Thread</em>类的构造方法中启动它</li><li>太过于简单，此处不举例</li></ul><hr><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><table><thead><tr><th>线程基本状态</th><th>调用方法</th><th>说明</th></tr></thead><tbody><tr><td>新建状态</td><td>new Thread()</td><td>用new创建一个新线程对象</td></tr><tr><td>就绪状态</td><td>start()</td><td>调用start()，启动线程</td></tr><tr><td>运行状态</td><td>run()</td><td>线程活动CPU时间，执行run方法</td></tr><tr><td>休眠状态</td><td>sleep()</td><td>进入休眠，不占用CPU</td></tr><tr><td>等待状态</td><td>wait()</td><td>线程等待某种请求完成，始终在等待，期间不允许执行其他操作</td></tr><tr><td>死亡状态</td><td>interrupt()</td><td>线程已完成任务正常退出，或阻塞状态被中断运行，需捕获异常后退出</td></tr></tbody></table><hr><h2 id="java锁"><a href="#java锁" class="headerlink" title="java锁"></a><em>java</em>锁</h2><ul><li><p>Java中的锁分为显示锁和隐式锁。隐式锁由synchronized关键字实现，⽽显示锁是由实现了 Lock接⼝和AQS框架等等类来实现。</p></li><li><p>锁的分类  </p><p>​从宏观上看，锁的分类有多种不同划分。可以分为乐观锁和悲观锁，可以分为共享锁和排他锁，还可以分为可重⼊锁和不可重⼊锁等等。  </p><ul><li><p>乐观锁</p><p>乐观锁就是对数据冲突保持乐观态度的锁，它认为不会有其他线程同时修改数据。因此乐观锁不会上锁，只是在更新数据的时候判断是否有其他线程更新，如果没有其他线程修改，它则更新数据， 有其他线程修改，它则放弃数据，重新读取数据处理。  </p></li><li><p>悲观锁</p><p>悲观锁对数据冲突持悲观的态度，认为总是发⽣数据冲突。因此它以⼀种预防的态度，先⾏把数据锁住，知道操作完成才释放锁，在此期间其他线程⽆法操作数据。</p></li></ul></li></ul><hr>  <h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a><em>synchronized</em>关键字</h2><p><em>java</em>中每一个对象都可以作为锁，有三种加锁方式：</p><ul><li>对于普通同步⽅法，锁是当前实例对象  </li><li>对于静态同步⽅法，锁是当前类的 Class 对象</li><li>对于同步⽅法块，锁是 Synchonized 括号⾥配置的对象</li></ul><hr>  <h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>synchronized关键字的实现，依赖于<em>Java</em>的对象头</p><ul><li>⼀个对象由三部分组成：对象头、实体数据、对⻬填充。对象头的⻓度不是固定的，如果是数据类型则对象头占12个字节，⾮数组类型对象头占8个字。</li><li>⾮数组类型的对象头分两部分，Mark Word 和对象类型指针，数组类型对象会多⼀部分来存储数组的⻓度。⽽<em>synchronized</em>关键字的实现，就和对象头中的Mark Word密切相关。</li></ul><p>为了提⾼虚拟机空间的使⽤效率，Mark Word被设计成⼀个⾮固定的动态数据结构，以便存储 更多的信息。不同状态下对象头Mark Word存储的信息如下图</p><p><img src="/postImage/img-4.png"></p><h2 id="synchronized锁的状态"><a href="#synchronized锁的状态" class="headerlink" title="synchronized锁的状态"></a><em>synchronized</em>锁的状态</h2><p>synchronized锁的状态被分为4种，级别从低到⾼依次是：⽆锁、偏向锁、轻量级锁、重量级锁。  </p><p>我们此处讲解偏向锁，因为其他部分较难，有兴趣的朋友可以自行查找  </p><ul><li><p>偏向锁</p><ul><li>⼤多数情况下，锁不仅不存在多线程竞争，⽽且总是由同⼀线程多次获得，为了让线程获得锁的代价更低⽽引⼊了偏向锁。  </li><li>这个锁永远会偏向于获得它的线程，如果在获得锁之后并没有其他线程获取，则获得偏向锁的线程永远不需要同步，减少锁带来的时间消耗</li></ul></li><li><p>偏向锁的获取  </p><p>偏向锁对象头将不在存放Hash值，而在此位置上存放线程ID（23bit）+Epoch(2bit),⼀共25bit, 其他部分保持不变。Epoch是⼀个时间戳，⽤来判断线程ID是否过时。具体获得锁流程如下： 匿名偏向是偏向锁的初始状态，所以先判断锁标志，再判断偏向锁标志位，只有最后三位是 101才开始，否则直接⾛其他的锁。如果是匿名状态，线程ID为0，采⽤CAS去将当前线程写入，如果成功则获得锁，不成功表示存在竞争。线程ID不为0，此前已经有偏向，判断此值是 否和当前线程相同，若⼀致则表示线程之前就获得了锁，不⼀致就尝试CAS替换。同意，替换 成功获得锁，替换失败存在竞争。未获得锁时将会等待安全点（STW），安全点会进⾏偏向锁的撤销。</p><p>安全点是JVM在进⾏垃圾GC时为了保证引⽤关系不会发⽣变化⽽设置的安全状态（GC Roots 的确定就在此时），STW(STOP THE WORLD)此时将暂停所有线程的⼯作。</p><p>在STW会检测持有偏向锁的线程是否还存活，如果存活则升级轻量级锁，如果线程未存活或者已经退出来同步代码块，将会判断是否可重偏向，否则直接升级为轻量级锁。允许重偏向时，会先设置为匿名重偏向，再使⽤CAS偏向线程。</p><p>判断是否可重偏向需要⽤到Epoch,偏向锁中有⼀个Epoch，对应的Class类中也有⼀个 Epoch。在进⼊全局安全点之后，⾸先会对Class类中的Epoch进⾏增加，得到新的 Epoch_new，然后扫描所有持有Class类实例的线程，根据线程信息判断是否锁住了该对象。 如果锁住了说明此对象还在使⽤，将Epoch_new更新给它，如果未锁住则说明不需要加锁， 不进⾏更新。如果对象的Epoch和类的Epoch相同，则表示它是被更新过的，需要锁，不能重偏向。⽽如果不相同，则表示已经不需要加锁了，此对象可以重偏向到其他线程。  </p></li><li><p>偏向锁的释放 </p><p>从偏向锁的获取过程可以看到，等到竞争出现的时候才会释放。如果没有出现竞争，它不会去改变Mark Word的相关字段。就算是线程已经执⾏完同步代码块，不需要加锁了，也不会去修改对象头，那个锁依旧存在，依旧保持偏向。 </p><p>只是在其他线程需要偏向，出现了竞争的时候会进⾏判断，如果以前偏向的线程不需要了，那 么对象⾸先会被设置为匿名偏向，然后CAS替换尝试加锁。如果以前偏向的线程还需要加锁， 升级为轻量级锁。</p><p>所以线程不会主动的将偏向锁设置为匿名偏向状态，不会主动的去释放锁。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java输入输出流</title>
      <link href="/2022/06/05/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
      <url>/2022/06/05/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Java输入输出流"><a href="#Java输入输出流" class="headerlink" title="Java输入输出流"></a><em>Java</em>输入输出流</h1><hr> <h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>本文总结了上课<em>Java</em>老师的讲解，记录了一些经典的<em>java</em>用法</li><li>本文篇幅较长，没有耐心与兴趣的朋友勿入</li></ul><h3 id="I-x2F-O流的概念"><a href="#I-x2F-O流的概念" class="headerlink" title="I&#x2F;O流的概念"></a><em>I&#x2F;O</em>流的概念</h3><ul><li><h4 id="流（stream）"><a href="#流（stream）" class="headerlink" title="流（stream）"></a>流（<em>stream</em>）</h4></li></ul><p>  <em>Java</em>采用流的概念屏蔽了存储数据的起点和终点种类，文件、键盘、网络和其他设备都可以把它们抽象为流，通过流可以自由地控制文件、内存、<em>I&#x2F;O</em>设备等数据的流向</p><ul><li><h4 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h4><ul><li>根据<em>I&#x2F;O</em>流的流向可分为输入流（<em>inputstream</em>）和输出流（<em>outputsteam</em>）  </li><li>当程序<strong>读取</strong>数据时，开启了一个通向起点数据源的输入流，这个起点可以是文件、内存、网络连接。</li><li>当程序<strong>写入</strong>数据时，开启了一个通向目的地的输出流。</li></ul></li><li><h4 id="读写数据的方法基本遵循步骤"><a href="#读写数据的方法基本遵循步骤" class="headerlink" title="读写数据的方法基本遵循步骤"></a>读写数据的方法基本遵循步骤</h4><ol><li>打开一个流  （<em>I&#x2F;O</em>流一旦被创建后，就会<strong>自动打开</strong>）</li><li>读（写）信息  </li><li>关闭流</li></ol></li></ul><hr><h3 id="I-x2F-O流的种类"><a href="#I-x2F-O流的种类" class="headerlink" title="I&#x2F;O流的种类"></a><em>I&#x2F;O</em>流的种类</h3><ul><li><p>字节流（<em>byte oriented stream</em>）  </p><ul><li>字节流以8位的字节为基本处理单位 </li><li>字节流不能直接处理<em>Unicode</em>字符</li></ul></li><li><p>字符流（<em>byte oritented stream</em>)</p><ul><li>字符流以16位的字节为基本处理单位  </li><li>字符流处理的单元为16位的<em>Unicode</em>字符，由<em>Java</em>虚拟机将字节转化为16位的<em>Unicode</em>字符</li></ul></li></ul><hr>  <h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li>字节流</li></ul><ol><li>所有文件的存储都是字节（<em>byte</em>）的存储，因此字节流可用于<strong>任何类型</strong>的对象，如音频文件、图片、歌曲</li></ol><ul><li>字符流</li></ul><ol><li>处理多国语言，就得用字符流</li><li>字符流通常处理文本</li></ol><hr>  <h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><h3 id="一、文件File类"><a href="#一、文件File类" class="headerlink" title="一、文件File类"></a>一、文件File类</h3><ul><li><h4 id="文件类的方法"><a href="#文件类的方法" class="headerlink" title="文件类的方法"></a>文件类的方法</h4></li></ul><p>File 类是 java.io 包中唯一代表<strong>磁盘文件本身</strong>的对象，也就是说，如果希望在程序中操作文件和目录，则都可以通过 File 类来完成。</p><p>File 类定义了一些方法来操作文件，如新建、删除、重命名文件和目录等。File 类不能访问文件内容本身，如果需要访问文件内容本身，则需要使用输入&#x2F;输出流。</p><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>boolean canRead()</strong></td><td><strong>测试应用程序是否能从指定的文件中进行读取</strong></td></tr><tr><td><strong>boolean  canWrite()</strong></td><td><strong>测试应用程序是否能写当前文件</strong></td></tr><tr><td><strong>boolean delete()</strong></td><td><strong>删除当前对象指定的文件</strong></td></tr><tr><td><strong>boolean exists()</strong></td><td><strong>测试当前 File 是否存在</strong></td></tr><tr><td><strong>String  getAbsolutePath()</strong></td><td><strong>返回由该对象表示的文件的绝对路径名</strong></td></tr><tr><td><strong>String getName()</strong></td><td><strong>返回表示当前对象的文件名或路径名（如果是路径，则返回最后一级子路径名）</strong></td></tr><tr><td><strong>boolean</strong> <strong>createNewFile()</strong></td><td><strong>创建一个新的文件。</strong></td></tr><tr><td><strong>boolean  isAbsolute()</strong></td><td><strong>当前 File 对象表示的文件是否为一个绝对路径名。</strong></td></tr><tr><td><strong>boolean  isDirectory()</strong></td><td><strong>测试当前 File 对象表示的文件是否为一个路径</strong></td></tr><tr><td><strong>boolean isFile()</strong></td><td><strong>当前 File 对象表示的文件是否为一个“普通”文件</strong></td></tr><tr><td><strong>long  lastModified()</strong></td><td><strong>返回当前 File 对象表示的文件最后修改的时间</strong></td></tr><tr><td><strong>long length()</strong></td><td><strong>返回当前 File 对象表示的文件长度</strong></td></tr><tr><td><strong>String[] list()</strong></td><td><strong>返回当前 File 对象指定的路径文件列表</strong></td></tr><tr><td><strong>String[] list(FilenameFilter)</strong></td><td><strong>返回当前 File 对象指定的目录中满足指定过滤器的文件列表</strong></td></tr><tr><td><strong>boolean mkdir()</strong></td><td><strong>创建一个目录，它的路径名由当前 File 对象指定</strong></td></tr><tr><td><strong>boolean mkdirs()</strong></td><td><strong>创建一个目录，它的路径名由当前 File 对象指定</strong></td></tr><tr><td><strong>boolean  renameTo(File)</strong></td><td><strong>将当前 File 对象指定的文件更名为给定参数 File 指定的路径名</strong></td></tr></tbody></table><ul><li><h4 id="文件类举例"><a href="#文件类举例" class="headerlink" title="文件类举例"></a>文件类举例</h4></li></ul><p>（1）在磁盘上创建一个文件，先创建文件夹，再创建文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFileDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;d:&quot;</span>+File.separator+<span class="string">&quot;filetest&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filePath.exists()) &#123;</span><br><span class="line"></span><br><span class="line">      filePath.delete();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    filePath.mkdir();</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path+File.separator+<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line"></span><br><span class="line">      file.delete();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">      file.createNewFile();</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;创建文件成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">      e.printStackTrace();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）遍历一个文件夹</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListAllFile</span> &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;e://360Downloads&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line"></span><br><span class="line">    showAllFile(file);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showAllFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file.isDirectory()) &#123;<span class="comment">//如果是目录</span></span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;文件夹:&quot;</span> + file.getName());</span><br><span class="line"></span><br><span class="line">      File[] listFiles = file.listFiles();<span class="comment">//获取当前路径下的所有文件和目录,返回File对象数组</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (File f : listFiles) &#123;<span class="comment">//将目录内的内容对象化并遍历</span></span><br><span class="line"></span><br><span class="line">       showAllFile(f);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(file.isFile()) &#123;<span class="comment">//如果是文件</span></span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;文件:&quot;</span> + file.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、输入输出流"><a href="#二、输入输出流" class="headerlink" title="二、输入输出流"></a>二、输入输出流</h3><ul><li><h4 id="实例：用字节流把数据写入文件和读到内存中。"><a href="#实例：用字节流把数据写入文件和读到内存中。" class="headerlink" title="实例：用字节流把数据写入文件和读到内存中。"></a>实例：用字节流把数据写入文件和读到内存中。</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InptutAndOutDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String data=<span class="string">&quot;jiava计算机&quot;</span>;</span><br><span class="line">File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:&quot;</span>+File.separator+<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">writeDataToFile(file,data);</span><br><span class="line">readFromFile(file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFromFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">InputStream inputStream=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">flen</span> <span class="operator">=</span> (<span class="type">int</span>) file.length();</span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[flen];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             len = inputStream.read(b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e1)&#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">inputStream.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(len);</span><br><span class="line">        System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeDataToFile</span><span class="params">(File file, String data)</span>  &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">OutputStream outputStream=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">outputStream=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">outputStream.write(data.getBytes());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">outputStream.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三、字符输入输出流举例"><a href="#三、字符输入输出流举例" class="headerlink" title="三、字符输入输出流举例"></a>三、字符输入输出流举例</h3><p><strong>字符流只能操作文本文件，不能操作图片，视频等非文本文件（因为是二进制存储的，要用字节流）</strong></p><ul><li>字符输出流（Writer）</li></ul><p>public abstract class Writer是用于写出字符流的所有类的超类，是一个抽象类，它定义了字节输出流的基本共性能方法</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void write(int c)</td><td>写入单个字符</td></tr><tr><td>void write(char[] cbuf)</td><td>写入字符数组</td></tr><tr><td>abstract void write(char[] cbuf, int off, int len)</td><td>写入字符数组的某一部分</td></tr><tr><td>void write(String str)</td><td>写入字符串</td></tr><tr><td>void write(String str, int off, int len)</td><td>写入字符串的某一部分</td></tr><tr><td>void flush()</td><td>刷新该流的缓冲</td></tr></tbody></table><ul><li>FileWriter类是写字符到文件的类，构造时使用系统默认的字符编码和默认字节缓冲区。</li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>FileWriter(File file)</td><td>根据给定的 File 对象构造一个 FileWriter 对象</td></tr><tr><td>FileWriter(File file, boolean append)</td><td>根据给定的 File 对象构造一个 FileWriter 对象。其中append参数代表是否追加</td></tr><tr><td>FileWriter(String fileName)</td><td>根据给定的文件名构造一个 FileWriter 对象</td></tr><tr><td>FileWriter(String fileName, boolean append)</td><td>根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象</td></tr></tbody></table><hr><ul><li>字符输入流</li></ul><p>Reader 类是所有字符流输入类的父类，该类定义了许多方法，这些方法对所有子类都是有效的。</p><table><thead><tr><th><strong>方法名及返回值类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>int read()</td><td>从输入流中读取一个字符，并把它转换为 0~65535 的整数。如果返回 -1， 则表示   已经到了输入流的末尾。为了提高 I&#x2F;O 操作的效率，建议尽量使用下面两种 read()   方法</td></tr><tr><td>int read(char[] cbuf)</td><td>从输入流中读取若干个字符，并把它们保存到参数 cbuf 指定的字符数组中。 该方   法返回读取的字符数，如果返回 -1，则表示已经到了输入流的末尾</td></tr><tr><td>int read(char[] cbuf,int off,int len)</td><td>从输入流中读取若干个字符，并把它们保存到参数 cbuf 指定的字符数组中。其中，   off 指定在字符数组中开始保存数据的起始下标，len 指定读取的字符数。该方法返   回实际读取的字符数，如果返回 -1，则表示已经到了输入流的末尾</td></tr></tbody></table><p>Java 提供了用来读取字符文件的便捷类——FileReader。该类的构造方法有如下两种重载形式。</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>FileReader(File file)</td><td>在给定要读取数据的文件的情况下创建一个新的 FileReader 对象。其中，file 表示要从中读取数据的文件</td></tr><tr><td>FileReader(String fileName)</td><td>在给定从中读取数据的文件名的情况下创建一个新 FileReader 对象。其中，fileName 表示要从中读取数据的文件的名称，表示的是一个文件的完整路径</td></tr></tbody></table><p> 举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReaderAndWriterDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">String data=<span class="string">&quot;jiava计算机&quot;</span>;</span><br><span class="line">File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:&quot;</span>+File.separator+<span class="string">&quot;test1.txt&quot;</span>);</span><br><span class="line">Writer writer=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">true</span>);<span class="comment">//追加方式</span></span><br><span class="line">writer.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">writer.write(<span class="string">&quot;你好！\r\n&quot;</span>);</span><br><span class="line">writer.write(<span class="string">&quot;我在学习！\r\n&quot;</span>);</span><br><span class="line">writer.flush();</span><br><span class="line">writer.close();</span><br><span class="line"><span class="comment">//读数据</span></span><br><span class="line">Reader reader=<span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"><span class="type">int</span> len=(<span class="type">int</span>)file.length();</span><br><span class="line"><span class="type">char</span> myChar[]=<span class="keyword">new</span> <span class="title class_">char</span>[len];</span><br><span class="line"><span class="type">int</span> <span class="variable">rlen</span> <span class="operator">=</span> reader.read(myChar);</span><br><span class="line">    System.out.println(rlen);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(myChar));</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四、Java缓冲输入输出流"><a href="#四、Java缓冲输入输出流" class="headerlink" title="四、Java缓冲输入输出流"></a>四、Java缓冲输入输出流</h3><p>为什么要缓冲输入输出流？由于I&#x2F;O的速度和CPU的速度不匹配，导致文件的读取较慢。所以通过缓存，一次性将大量的数据刷入内存或者保存在本地上。提高文件的访问效率。</p><p>字节缓冲流： BufferedInputStream ， BufferedOutputStream</p><p>字符缓冲流： BufferedReader ， BufferedWriter</p><ul><li>字节缓冲流的使用（复制文件）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyFileByBuffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">File sourceFile=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span>+File.separator+<span class="string">&quot;filetest&quot;</span>+File.separator+<span class="string">&quot;xx.zip&quot;</span>);</span><br><span class="line">File targetFile=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span>+File.separator+<span class="string">&quot;movie&quot;</span>+File.separator+<span class="string">&quot;xx.zip&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">copyFileByBuffered(sourceFile,targetFile);</span><br><span class="line"><span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;缓冲流（默认缓冲区）复制时间:&quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileByBuffered</span><span class="params">(File sourceFile, File targetFile)</span> &#123;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourceFile),<span class="number">2048</span>);</span><br><span class="line">   BufferedOutputStream bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFile),<span class="number">2048</span>);</span><br><span class="line">   <span class="keyword">while</span>((b=bis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">   bos.write(b);</span><br><span class="line">   &#125;</span><br><span class="line">   bis.close();</span><br><span class="line">   bos.flush();</span><br><span class="line">   bos.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字节缓冲流的使用（高效复制文件）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyFileByBufferMore</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">File sourceFile=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span>+File.separator+<span class="string">&quot;filetest&quot;</span>+File.separator+<span class="string">&quot;xx.zip&quot;</span>);</span><br><span class="line">File targetFile=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span>+File.separator+<span class="string">&quot;movie&quot;</span>+File.separator+<span class="string">&quot;xx.zip&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">copyFileByBuffered(sourceFile,targetFile);</span><br><span class="line"><span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;缓冲流（默认缓冲区）复制时间:&quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileByBuffered</span><span class="params">(File sourceFile, File targetFile)</span> &#123;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">byte</span>[] bytes=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourceFile),<span class="number">2048</span>);</span><br><span class="line">   BufferedOutputStream bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFile),<span class="number">2048</span>);</span><br><span class="line">   <span class="keyword">while</span>((b=bis.read(bytes))!=-<span class="number">1</span>) &#123;</span><br><span class="line">   bos.write(bytes,<span class="number">0</span>,b);</span><br><span class="line">   &#125;</span><br><span class="line">   bis.close();</span><br><span class="line">   bos.flush();</span><br><span class="line">   bos.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用字符缓冲流逐行读取文件。创建Student类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadFileByBuffered</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">   List&lt;Student&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">       File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span>+File.separator+<span class="string">&quot;filetest&quot;</span>+File.separator+<span class="string">&quot;score.txt&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">BufferedReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">br.readLine();</span><br><span class="line">String score[]=<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">score=line.split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">Student st=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;score.length;i++) &#123;</span><br><span class="line">st.setId(score[<span class="number">0</span>]);</span><br><span class="line">st.setName(score[<span class="number">1</span>]);</span><br><span class="line">st.setMath(Integer.parseInt(score[<span class="number">2</span>]));</span><br><span class="line">st.setChinese(Integer.parseInt(score[<span class="number">3</span>]));</span><br><span class="line">st.setEnglish(Integer.parseInt(score[<span class="number">4</span>]));</span><br><span class="line">st.setTotal(st.getMath()+st.getChinese()+st.getEnglish());</span><br><span class="line">st.setAverage(st.getTotal()/<span class="number">3.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line">list.add(st);</span><br><span class="line">&#125;</span><br><span class="line">br.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">       <span class="keyword">for</span>(Student st:list) &#123;</span><br><span class="line">       System.out.println(st.getId()+<span class="string">&quot; &quot;</span>+<span class="string">&quot;\t&quot;</span>+st.getName());</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、对象序列化与对象输入输出流"><a href="#五、对象序列化与对象输入输出流" class="headerlink" title="五、对象序列化与对象输入输出流"></a>五、对象序列化与对象输入输出流</h3><p>Java中要实现将对象保存起来持久化，需要让对象实现<strong>Serializable接口</strong>，这样就能将java对象用二进制流保存并恢复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaveObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">File fileName=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\filetest\\obj.txt&quot;</span>) ;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ObjectOutputStream oos=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(fileName));</span><br><span class="line">User user=<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">oos.writeObject(user);</span><br><span class="line"> oos.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//读取对象流</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ObjectInputStream ois=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">User user1=(User)ois.readObject();</span><br><span class="line">System.out.println(user1.toString());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、RandomAccessFile-类"><a href="#六、RandomAccessFile-类" class="headerlink" title="六、RandomAccessFile 类"></a>六、RandomAccessFile 类</h2><p>RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来<strong>读、写文件。支持文件追加。</strong>RandomAccessFile 类支持字节和字符流。</p><table><thead><tr><th><strong>方法</strong></th><th><strong>功能描述</strong></th></tr></thead><tbody><tr><td>long length()</td><td>返回文件长度</td></tr><tr><td>void seek(long  pos)</td><td>移动文件位置指示器，pos 指定从文件开头的偏离字节数</td></tr><tr><td>int skipBytes(int  n)</td><td>跳过 n 个字节，返回数为实际跳过的字节数</td></tr><tr><td>int read()</td><td>从文件中读取一个字节，字节的高 24 位为 0，若遇到文件结尾，返回-1</td></tr><tr><td>final byte readByte()</td><td>从文件中读取带符号的字节值</td></tr><tr><td>final char readChar()</td><td>从文件中读取一个 Unicode 字符</td></tr><tr><td>final void writeChar(inte c)</td><td>写入一个字符，两个字节</td></tr><tr><td>final void writeBytes（String s）</td><td>写入个字符串</td></tr></tbody></table><p>实例<em>RandomAccessFile</em>读写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">RandomAccessFile raf=<span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">String line=<span class="literal">null</span>;</span><br><span class="line">raf.seek(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>((line=raf.readLine())!= <span class="literal">null</span>)&#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(line.getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>),<span class="string">&quot;gb2312&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">raf.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">RandomAccessFile raf=<span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">long</span> len=raf.length();</span><br><span class="line">raf.seek(len);<span class="comment">//在文件尾部写行</span></span><br><span class="line">raf.write((<span class="string">&quot;中午&quot;</span>+<span class="string">&quot;\r\n&quot;</span>).getBytes());;</span><br><span class="line">raf.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">RandomAccessFile so=<span class="literal">null</span>;</span><br><span class="line">RandomAccessFile ta=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">so=<span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;src\\myfile\\360qudong.exe&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">ta=<span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;src\\myfile\\360qudong1.exe&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">byte</span> b[]=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=so.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">ta.write(b,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;0k&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ta!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ta.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(so!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">so.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="七、URL对象与输入输出流"><a href="#七、URL对象与输入输出流" class="headerlink" title="七、URL对象与输入输出流"></a>七、URL对象与输入输出流</h3><p>URL全称是“统一资源定位”，表示的是网络上的某个文件。Java中URL类是用来操作网络中的资源文件。</p><ul><li>URL类的构造方法：</li></ul><table><thead><tr><th>序号</th><th><strong>方法描述</strong></th></tr></thead><tbody><tr><td>1</td><td><strong>public URL(String protocol, String host, int port,  String file) throws MalformedURLException.</strong>   通过给定的参数(协议、主机名、端口号、文件名)创建URL。</td></tr><tr><td>2</td><td><strong>public URL(String protocol, String host, String file)  throws MalformedURLException</strong>   使用指定的协议、主机名、文件名创建URL，端口使用协议的默认端口。</td></tr><tr><td>3</td><td><strong>public URL(String url) throws MalformedURLException</strong>   通过给定的URL字符串创建URL</td></tr><tr><td>4</td><td><strong>public URL(URL context, String url) throws  MalformedURLException</strong>   使用基地址和相对URL创建</td></tr></tbody></table><ul><li>URL类的方法</li></ul><p>​URL类的方法很多，这里介绍<strong>openConnection()方法：</strong></p><p>​public URLConnection openConnection() throws IOException:    打开一个URL连接，并返回一个HttpURLConnection对象。</p><ul><li>HttpURLConnection对象的方法</li></ul><p>​public InputStream getInputStream() throws IOException：返回URL的输入流，用于读取资源。</p><p>实例：程序下载网页中的图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">saveImage(<span class="string">&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveImage</span><span class="params">(String str)</span> &#123;</span><br><span class="line">URL url=<span class="literal">null</span>;</span><br><span class="line">HttpURLConnection conn=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">url=<span class="keyword">new</span> <span class="title class_">URL</span>(str);</span><br><span class="line">conn=(HttpURLConnection)url.openConnection();</span><br><span class="line">conn.connect();</span><br><span class="line">BufferedInputStream bis=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(conn.getInputStream());</span><br><span class="line">BufferedOutputStream bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\ddd.png&quot;</span>));</span><br><span class="line"><span class="type">byte</span> bt[]=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="keyword">while</span>((size=bis.read(bt))!=-<span class="number">1</span>) &#123;</span><br><span class="line">bos.write(bt,<span class="number">0</span>,size);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;finsh&quot;</span>);</span><br><span class="line">bos.flush();</span><br><span class="line">bos.close();</span><br><span class="line">bis.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法的运用</title>
      <link href="/2022/06/03/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E8%BF%90%E7%94%A8/"/>
      <url>/2022/06/03/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E8%BF%90%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="二分法的运用"><a href="#二分法的运用" class="headerlink" title="二分法的运用"></a>二分法的运用</h1><h4 id="二分法使用基本条件："><a href="#二分法使用基本条件：" class="headerlink" title="二分法使用基本条件："></a>二分法使用基本条件：</h4><p><strong>有序整数</strong>数组</p><p>通过<strong>循环</strong>，不断更新<strong>左边界</strong>（<em>LeftBorder</em>)与<strong>右边界</strong>(<em>RightBorder</em>)达到你需要的目的</p><ul><li><h4 id="二分法用于查询有序数组的某一个元素，若有，则返回序号，无，则返回-1"><a href="#二分法用于查询有序数组的某一个元素，若有，则返回序号，无，则返回-1" class="headerlink" title="二分法用于查询有序数组的某一个元素，若有，则返回序号，无，则返回-1"></a>二分法用于查询有序数组的某一个元素，若有，则返回序号，无，则返回-1</h4><p>​ 相关题目：给定一个 n 个元素的升序整型数组 nums 和一个目标值 target,写一个函数搜索 nums 中的 target,如果目标值存在则返回下标，否则返回-1</p><p>示例 1：</p><p>输入：nums &#x3D; [-1,0,3,5,9,12], target&#x3D;9</p><p>输出：4</p><p>解释：9 出现在 nums 中因此返回-1</p><p>示例 2：</p><p>输入：nums&#x3D;[-1,0,3,5,9,12], target&#x3D;2</p><p>输出：-1</p><p>解释：2 在 nums 中不存在，因此返回-1</p><ul><li><p>提示：</p><p>[^1.]: 你可以假设 nums 中的所有元素是不重复出现的。<br>[^2.]: n 将在[1,10000]之间<br>[^3.]: nums 中的每个元素都将在[-9999,9999]之间</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心代码模式</span></span><br><span class="line"><span class="comment">// Java版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 左边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;<span class="comment">// 右边界</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;<span class="comment">// 采用左闭右闭[]</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + (right -left)/<span class="number">2</span>;<span class="comment">// 求中位数的序号</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;<span class="comment">// 说明此时target在数组的左侧</span></span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[middle] == target) &#123;<span class="comment">// 如果相等，说明找到了target</span></span><br><span class="line">                    <span class="keyword">return</span> middle;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;<span class="comment">// 说明此时target在数组的右侧</span></span><br><span class="line">                    left = middle + <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">1</span><span class="comment">// 跳出while循环还没找到，说明没有！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><em>kotlin</em>版本</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">search</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = nums.size - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">var</span> middle = left + (right - left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[middle] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> middle</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = middle + <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2022/06/02/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/06/02/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-命令及-shell-编程浅谈"><a href="#Linux-命令及-shell-编程浅谈" class="headerlink" title="Linux 命令及 shell 编程浅谈"></a>Linux 命令及 shell 编程浅谈</h1><ul><li><h3 id="Linux文件系统结构"><a href="#Linux文件系统结构" class="headerlink" title="Linux文件系统结构"></a><em>Linux</em>文件系统结构</h3></li></ul><p><img src="/postImage/image-20220515190158467.png" alt="image-20220515190158467"></p><ul><li><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ul><li>*匹配<strong>任何字符</strong>或<strong>任何数目</strong>的字符</li><li>？匹配任何单字符</li><li>[…] 匹配任何包含在括号里的单字符</li><li>目录表示：. 指示当前目录，.. 表示当前目录的父目录</li></ul></li><li><h3 id="启动退出命令"><a href="#启动退出命令" class="headerlink" title="启动退出命令"></a>启动退出命令</h3><ul><li><em>logout</em> 注销</li><li><em>exit</em> 退出</li><li><em>reboot</em> 重启系统（需要管理员权限）</li><li><em>shutdown</em> 关机 （需要管理员权限 ）</li></ul></li><li><h3 id="目录操作命令"><a href="#目录操作命令" class="headerlink" title="目录操作命令"></a>目录操作命令</h3><ul><li><em>pwd</em> 显示出用户当前工作目录的全部路径(<em>print working directory</em>)</li><li><em>mkdir directory_name</em> 创建新目录(<em>make directory</em>)</li><li><em>cd directory_name</em> 改变当前工作目录</li><li><em>rmdir directory_name</em> 删除目录，但要求目录中<strong>不存在文件或子目录</strong></li></ul></li><li><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><em>ls [-a&#x2F;-R&#x2F;-l&#x2F;-lc&#x2F;-lu] [dir_name]</em> 显示目录命令</li></ul></li><li><p><em>cat filename</em> 显示出文件内容</p><ul><li><em>view filename</em> 只能读出文件内容</li></ul></li><li><p><em>head [-i] filename</em> 显示文件的<strong>开始 i 行</strong></p><ul><li><em>tail [-i] filename</em> 显示文件的<strong>末 i 行</strong></li></ul></li><li><p><em>pr filename</em> 显示格式化的文本内容(<em>print</em>)</p><ul><li><em>cp source_file target_file</em> 复制文件（新的文件可以同名）</li></ul></li><li><p><em>rm -i&#x2F;r&#x2F;f file_or_dir</em> 删除文件 (i 互动删除，删除前再确认一次，r 递归删除，强制删除)</p><ul><li><em>chmod pattern filename</em> 修改文件权限</li></ul></li><li><p><em>find pathname [option] expression</em> 寻找文件名</p><ul><li><em>diff filename1 filename2</em> 比较来两个文件的不同</li></ul></li><li><p><em>touch filename</em> 改变文件日期，不对文件内容改动，若文件不存在则创建新文件</p><ul><li><em>date</em> 显示或设置日期（只有 root 用户才有权设置日期）</li></ul></li><li><p><em>cal</em> [month] year 显示某年指定的日历</p><ul><li><em>time</em> [command] 计算程序或命令在其执行所消耗的时间</li></ul></li><li><p><em>history</em> 帮助用户回忆执行过的命令</p><ul><li><em>man [command_name]</em> 显示参考手册，提供联机帮助信息</li></ul></li><li><p><em>echo [-n] [arguments]</em> 将参数即字符串至标准输出即显示器</p></li><li><p>简单实例一</p><ol><li><p>设定变量 file 的值为*&#x2F;etc&#x2F;passwd*</p></li><li><p>使用循环变量读取文件*&#x2F;etc&#x2F;passwd*的第 2，4，6，10，13，15 行，并显示其内容</p></li><li><p>把这些行保存至&#x2F;tmp&#x2F;mypasswd 文件中</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">file=&quot;/etc/passwd&quot;       # 务必使用“”</span><br><span class="line">for i in 2 4 6 10 13 15</span><br><span class="line">do</span><br><span class="line">        head -$i $file   # 务必使用 $</span><br><span class="line">        head -$i $file&gt;&quot;/tmp/mypasswd&quot;</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>简单实例二</p><ol><li><p>传递两个整数给脚本，让脚本分别计算并显示这两个整数的和，差，积，商。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!bin/bash</span></span><br><span class="line">a=$1      # 执行脚本是应为 sh filename argument1 argument2</span><br><span class="line">b=$2</span><br><span class="line">var1=`expr $a + $b`   # 务必注意运算符与参数之间的空格</span><br><span class="line">var2=`expr $a - $b`</span><br><span class="line">var3=`expr $a \* $b`  # 注意 \*</span><br><span class="line">var4=`expr $a / $b`</span><br><span class="line">echo &quot;a+b=$var1&quot;</span><br><span class="line">echo &quot;a-b=$var2&quot;</span><br><span class="line">echo &quot;a*b=$var3&quot;</span><br><span class="line">echo &quot;a/b=$var4&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>简单实例三</p><ol><li><p>显示系统日期和时间，而后创建目录&#x2F;tmp&#x2F;lstest</p></li><li><p>切换工作目录至&#x2F;tmp&#x2F;lstest</p></li><li><p>创建目录 a1d,b56e,6test</p></li><li><p>创建空文件 xy,x2y,732</p></li><li><p>列出当前目录下以 a，x 或者 6 开头的文件或目录</p></li><li><p>列出当前目录下以字母开头，后跟一个任意数字，而后跟任意长度字符的文件或目录</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">date</span><br><span class="line">mkdir /tmp/lstest</span><br><span class="line">cd /tmp/lstest</span><br><span class="line">mkdir a1d b56e 6test  # 注意空格</span><br><span class="line">touch xy x2y 732      # 注意空格</span><br><span class="line">ls [ax6]*             # 注意正则表达式的运用</span><br><span class="line">ls [[:alpha:]][[:digit:]]*   # 注意[]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>简单实例四</p><ol><li><p>编写一个名为<em>myfirstshell.sh</em>的脚本</p></li><li><p>包含一段注释，列出您的姓名、脚本的名称和编写这个脚本的目的</p></li><li><p>问候用户</p></li><li><p>显示日期和时间</p></li><li><p>显示这个月的日历</p></li><li><p>显示您的机器名</p></li><li><p>显示当前这个操作系统的名称和版本</p></li><li><p>显示父目录中的所有文件的列表</p></li><li><p>显示<em>root</em>正在运行的所有进程</p></li><li><p>显示变量<em>TERM、PATH</em>和<em>HOME</em>的值</p></li><li><p>显示磁盘使用情况</p></li><li><p>用 id 命令打印出您的组 ID</p></li><li><p>跟用户说<em>“Good bye”</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">author:@Ezralin</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">name:myfirstshell</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pourpose: to improve myself</span></span><br><span class="line">user=`whoami`</span><br><span class="line">case $user in</span><br><span class="line">    root)</span><br><span class="line">        echo &quot;hello root&quot;;;</span><br><span class="line">    Ezralin)</span><br><span class="line">        echo &quot;hello Bin&quot;;;</span><br><span class="line">    *)</span><br><span class="line">        echo &quot;hello $user,welcome&quot;</span><br><span class="line">esac</span><br><span class="line">echo &quot;日期和时间：`date`&quot;</span><br><span class="line">echo &quot;本月的日历：`cal`&quot;</span><br><span class="line">echo &quot;本机的机器猫：`uname -n`&quot;</span><br><span class="line">echo &quot;当前这个操作系统的名称和版本：`uname -s;uname -r`&quot;</span><br><span class="line">echo &quot;父目录中的所有文件的列表：`ls ../`&quot;</span><br><span class="line">echo &quot;root正在运行的所有程序：`ps -u root`&quot;</span><br><span class="line">echo &quot;变量TERM的值：$TERM&quot;</span><br><span class="line">echo &quot;变量PATH的值：$PATH&quot;</span><br><span class="line">echo &quot;变量HOME的值：$HOME&quot;</span><br><span class="line">echo &quot;磁盘的使用情况：`df`&quot;</span><br><span class="line">echo &quot;用id命令打印出你的组ID：`id -g`&quot;</span><br><span class="line">echo &quot;Good bye!&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java与kotlin对比学习</title>
      <link href="/2022/06/02/java%E4%B8%8Ekotlin%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/06/02/java%E4%B8%8Ekotlin%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Java与kotlin对比学习一"><a href="#Java与kotlin对比学习一" class="headerlink" title="Java与kotlin对比学习一"></a><em>Java</em>与<em>kotlin</em>对比学习一</h1><ul><li><h3 id="构造函数、声明属性对比"><a href="#构造函数、声明属性对比" class="headerlink" title="构造函数、声明属性对比"></a>构造函数、声明属性对比</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Java</em>的构造函数非常直接，类型修饰符+类名+()，若有属性，则再（）中加入参数，与 C++语言有异曲同工之妙，而<em>Kotlin</em>胜在**精简 **</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span> </span>(aName: String, aAge: <span class="built_in">Int</span>) &#123;  <span class="comment">// 临时定义变量保存外部传过来的值</span></span><br><span class="line">    <span class="keyword">var</span> name: String = aName   <span class="comment">// aName, aAge是临时的，真正定义并完成初始化操作</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或在初始化块中调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span> </span>(aName: String, aAge: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        name = aName</span><br><span class="line">        age = aAge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>kotlin</em>还可以直接在<em>constructor</em>内部<strong>直接</strong>声明属性，与<em>Java</em>相比<strong>更加精简</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span> </span>(<span class="keyword">private</span> <span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123; <span class="comment">// 在主构造函数中直接声明属性</span></span><br><span class="line">    <span class="keyword">var</span> score = <span class="number">99</span>  <span class="comment">// 需要在创建对象时给予初始值的属性才放到主构造函数中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="定义函数对比"><a href="#定义函数对比" class="headerlink" title="定义函数对比"></a>定义函数对比</h3><ul><li><p>无参无返回值的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;  <span class="comment">// java</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun test(): Unit &#123;&#125;   // Kotlin</span><br></pre></td></tr></table></figure></li><li><p>有参无返回值的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;&#125;   <span class="comment">// java</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Unit</span>&#123;&#125;   <span class="comment">// kotlin</span></span><br></pre></td></tr></table></figure></li><li><p>有参有返回值的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;                  <span class="comment">// java</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b    <span class="comment">// kotlin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果函数只有一行，也可写为下述形式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = a + b</span><br><span class="line"><span class="comment">// 甚至返回值类型也可省略</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码运行深层原理</title>
      <link href="/2022/06/02/Java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E6%B7%B1%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2022/06/02/Java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E6%B7%B1%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM-浅谈"><a href="#JVM-浅谈" class="headerlink" title="JVM 浅谈"></a>JVM 浅谈</h1><ul><li><h3 id="Java-构造对象浅谈"><a href="#Java-构造对象浅谈" class="headerlink" title="Java 构造对象浅谈"></a>Java 构造对象浅谈</h3><p>​ 在日常编程中，我们不假思索地使用<em>new</em>去新建一个对象，但 <em>Java</em>是如何在底层进行对象的创建？如何在底层完成对象的创建并进行初始化？下面我们来探讨以下这个问题：</p><p><code><em>Animal animal=new Animal()</em></code></p><p>上行代码是对象实例化的过程，在程序中执行这行代码，将会经历以下过程：</p><ol><li><p>在<strong>方法区</strong>寻找 Animal 类的信息</p></li><li><p><strong>判断</strong> <em>Java</em>编译后的字节码里面是否有这个<em>Animal</em>类，如果没有，则类加载器会将当前这个类的<strong>字节码文件</strong>加载到文件中</p></li><li><p><code>new Animal()</code>创建对象时，对象在<strong>堆</strong>（_heap_）里面被分配内存空间</p></li><li><p>该被创建的对象在<strong>堆</strong>中的<strong>地址</strong>会被压入<strong>操作数栈</strong></p></li><li><p>在当前<strong>线程栈</strong>的方法栈帧的<strong>局部变量区域</strong>申请内存空间给<em>animal</em></p></li><li><p>从操作数帧中弹出顶部操作数（就是被创建对象在<strong>堆</strong>中的<strong>地址</strong>）赋值给<em>animal</em>，从而使<em>animal</em> <strong>指向</strong>新建的<em>Animal</em>对象</p></li></ol><hr></li><li><h3 id="JVM-理解"><a href="#JVM-理解" class="headerlink" title="JVM 理解"></a>JVM 理解</h3><p>我们将从下面这个简单的代码的<strong>反编译</strong>的*.class<em>文件，深度理解</em>Java*是如何在内存中被执行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPerson</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doSomething</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> a= <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (a+b)*<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TestPerson testPerson=<span class="keyword">new</span> <span class="title class_">TestPerson</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> testPerson.doSomething();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上述代码的class反编译文件"><a href="#上述代码的class反编译文件" class="headerlink" title=".上述代码的class反编译文件"></a>.上述代码的<em>class</em>反编译文件</h4><p>我们对一些可以<strong>见名知意</strong>的名词不做过多解释，不清楚的大家可以在简书中搜索，<strong>此处</strong>主要还是<strong>加深</strong>大家对代码的<strong>理解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;JVM_03.TestPerson.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVM_03</span>.TestPerson &#123;</span><br><span class="line">  <span class="keyword">public</span> JVM_03.TestPerson();               <span class="comment">// 这是默认构造函数</span></span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_1      <span class="comment">// 把常量1压入操作数栈</span></span><br><span class="line">       <span class="number">1</span>: istore_1      <span class="comment">// 从操作数栈中弹出刚刚入栈的常量1</span></span><br><span class="line">                        <span class="comment">// 并把它赋值给局部变量表中索引为1的变量</span></span><br><span class="line">                        <span class="comment">// 即赋值给a  (对应代码：int a=1)</span></span><br><span class="line">       <span class="number">2</span>: iconst_2</span><br><span class="line">       <span class="number">3</span>: istore_2            <span class="comment">// 同上</span></span><br><span class="line">       <span class="number">4</span>: iload_1             <span class="comment">// 将局部变量表中下标为1的int变量压入操作数栈</span></span><br><span class="line">       <span class="number">5</span>: iload_2             <span class="comment">// 同上</span></span><br><span class="line">       <span class="number">6</span>: iadd                <span class="comment">// 在操作数栈中完成两数相加</span></span><br><span class="line">       <span class="number">7</span>: iconst_5            <span class="comment">// 将常量5压入操作数栈</span></span><br><span class="line">       <span class="number">8</span>: imul                <span class="comment">//在操作数栈中完成乘法运算</span></span><br><span class="line">       <span class="number">9</span>: istore_3            <span class="comment">//弹出运算结果并且赋值给局部变量表中索引为3的变量</span></span><br><span class="line">      <span class="number">10</span>: iload_3</span><br><span class="line">      <span class="number">11</span>: ireturn             <span class="comment">// 返回int类型的值 (ireturn 语句中 i就表示int)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class JVM_03.TestPerson</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: aload_1</span><br><span class="line">       <span class="number">9</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method doSomething:()I</span></span><br><span class="line">      <span class="number">12</span>: istore_2</span><br><span class="line">      <span class="number">13</span>: getstatic     #<span class="number">5</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">16</span>: iload_2</span><br><span class="line">      <span class="number">17</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">      <span class="number">20</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​ 下面我们再挖深一些，进一步揭开 JVM 的面纱：</p><p>​ 我们先了解一下<em>Java</em>的<strong>运行时数据区</strong>(<em>Runtime Date Area</em>)，<em>Java</em>程序被运行时，内存中运行时数据区会被分为五部分，见下图。</p><p>​ <em>Java</em>程序运行是按线程来操作的，在线程栈中运行多个线程。每一个<strong>线程</strong>都有一个自己的<strong>栈帧</strong>，而每一个栈帧又包含局部变量、操作数栈、动态链接、方法出口四部分。上述就是在 main 线程里面的栈帧进行的。这里还要讲解一下，<strong>函数出口记录</strong>的问题。</p><p>​ 就上述<em>Java</em>代码而言，显然，程序需要从 main 函数进入<em>doSomething</em>函数，再返回 main 函数，为了不迷路，<em>Java</em>采用”<strong>标记</strong>“的方法记录出口，上述的*.class<em>文件中的#2 等等就是”标记“。当<code>new</code>一个新的对象时上述代码调用了默认构造函数，此时就需要进入该构造函数，</em>Java<em>离开 main 函数留下”标记“，java 进入函数时又留下”标记“，如此，进入不同函数，它就知道运行时如何返回</em>main*函数了。</p><ul><li><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><img src="/postImage/img-1.jpg" /></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型与Kotlin高阶语法糖</title>
      <link href="/2022/06/02/Java%E6%B3%9B%E5%9E%8B%E4%B8%8EKotlin%E9%AB%98%E9%98%B6%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
      <url>/2022/06/02/Java%E6%B3%9B%E5%9E%8B%E4%B8%8EKotlin%E9%AB%98%E9%98%B6%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Java泛型与Kotlin高阶函数语法糖"><a href="#Java泛型与Kotlin高阶函数语法糖" class="headerlink" title="Java泛型与Kotlin高阶函数语法糖"></a><em>Java</em>泛型与<em>Kotlin</em>高阶函数语法糖</h1><ul><li><h3 id="java泛型"><a href="#java泛型" class="headerlink" title="java泛型"></a><em>java</em>泛型</h3><ol><li><p>什么是泛型？ 泛指<strong>一切类型</strong></p><p> 常使用 <em>T</em> <em>R</em> <em>V</em> <em>K</em> <em>I</em> <em>O</em> 表示</p></li><li><p>协变与形变</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        List&lt;String&gt; b = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        a = b; <span class="comment">// 报错,为什么,a 需要 List&lt;Objects&gt;类型，而b 为List&lt;String&gt;类型</span></span><br><span class="line">        *****************</span><br><span class="line">        <span class="comment">// 此时需要使用协变</span></span><br><span class="line">        父类接收子类 协变 ? <span class="keyword">extends</span></span><br><span class="line">        <span class="title class_">List</span>&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// ? 为占位符，表示一个继承于Object的子类</span></span><br><span class="line">        List&lt;String&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        c = d;<span class="comment">// 正确!!!</span></span><br><span class="line">        *****************</span><br><span class="line">        List&lt;Object&gt; e = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        List&lt;String&gt; f = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        f = e;<span class="comment">// 报错，f需要List&lt;Object&gt;类型，而e为List&lt;String&gt;类型，类型不匹配</span></span><br><span class="line">        *****************</span><br><span class="line">        <span class="comment">// 此时需要使用形变</span></span><br><span class="line">        子类接收父类 形变 ? <span class="built_in">super</span></span><br><span class="line">        List&lt;Object&gt; g = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        List&lt;? <span class="built_in">super</span> String&gt; h = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        h = g;<span class="comment">// 正确！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>java</em>泛型类的使用</p><p> 注意：泛型类中的方法只是使用了泛型类类型作为参数的函数，不是泛型函数</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类</span></span><br><span class="line"><span class="comment">// T type</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bag</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T getValue &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// main</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 前面&lt;&gt; 和 后面&lt;&gt; 必须指定一处类型</span></span><br><span class="line">        Bag&lt;String&gt; schoolBag = <span class="keyword">new</span> <span class="title class_">Bag</span>&lt;&gt;();</span><br><span class="line">        schoolBag.setValue(<span class="string">&quot;语文书&quot;</span>);</span><br><span class="line">        System.out.println(schoolBag.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><h3 id="kotlin泛型类的使用"><a href="#kotlin泛型类的使用" class="headerlink" title="kotlin泛型类的使用"></a><em>kotlin</em>泛型类的使用</h3><ol><li><p><em>kotlin</em>泛型类的使用</p><p> <em>kotlin</em>: <em>out</em> 这个类型只能作为返回值 输出 生产</p><p> <em>kotln</em>: <em>in</em>只能作为参数 接受 消费</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bag</span>&lt;<span class="type">in I,out O</span>&gt;</span>(<span class="keyword">var</span> value: <span class="meta">@UnsafeVariance</span> I,<span class="keyword">var</span> result: <span class="meta">@UnsafeVariance</span> O) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(v1: <span class="type">I</span>)</span></span> &#123;</span><br><span class="line">        value = v1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">()</span></span>: O &#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><h3 id="Kotlin泛型函数的使用"><a href="#Kotlin泛型函数的使用" class="headerlink" title="Kotlin泛型函数的使用"></a><em>Kotlin</em>泛型函数的使用</h3><p>何为泛型函数？不确定参数或者返回值类型的函数就是泛型函数</p><ol><li><p>仅有一个泛型</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">test</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">test1</span><span class="params">()</span></span>: T &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">test2</span><span class="params">(v1: <span class="type">T</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>放回值和参数类型均需要自己指定</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T,R&gt;</span> <span class="title">test</span><span class="params">(v1: <span class="type">T</span>, v2: <span class="type">T</span>)</span></span>: R? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><h3 id="Kotlin高阶函数分析"><a href="#Kotlin高阶函数分析" class="headerlink" title="Kotlin高阶函数分析"></a><em>Kotlin</em>高阶函数分析</h3><ol><li><p>何为<strong>高阶函数</strong>与为什么需要使用**<em>inline</em>**?</p><p> 高阶函数是将<strong>函数</strong>用作<strong>参数或返回值</strong>的函数，实际开发过程中<strong>一般所有</strong>高阶函数都必须使用**<em>inline</em><strong>修饰，使之成为</strong>内联函数<strong>。不使用<em>inline</em>修饰高阶函数时，使用此类<a href="https://www.kotlincn.net/docs/reference/lambdas.html">高阶函数</a>会带来一些运行时的效率损失，因为编译时，每一个函数都是一个</strong>对象<strong>，</strong>内存分配<strong>（对于函数对象和类）和</strong>虚拟调用<strong>会引入</strong>运行时间开销<strong>，</strong>降低效率<strong>。当<em>inline</em>修饰了高阶函数时，此时编译时程序只是做了一个</strong>展开&#x2F;替换*<em>（类似于 C 语言的宏定义），所以在许多情况下我们通过使用</em>inline*内联化 lambda 表达式来消除这类的开销。</p></li><li><p>**<em>lambda</em>**表达式分析</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">show1</span><span class="params">(lambda: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// lamba表达式为String类型的形参，没有返回值</span></span><br><span class="line">    <span class="comment">// lambda 表达式里面是 it</span></span><br><span class="line">    lambda(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">show2</span><span class="params">(lambda: <span class="type">String</span>.() -&gt; <span class="type">Unit</span> )</span></span> &#123;</span><br><span class="line">    <span class="comment">// lambda 表达式里面是 this</span></span><br><span class="line">    <span class="keyword">this</span>.lambda()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="string">&quot;jack&quot;</span>.show1&#123;</span><br><span class="line">        println(<span class="string">&quot;hello <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">&quot;Merry&quot;</span>.show2&#123;</span><br><span class="line">        println(<span class="string">&quot;hello <span class="variable">$this</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>lambda</em>与泛型的综合运用</p><ul><li>给任意一个类型添加一个扩展函数，lambda 中使用 it 访问这个对象</li></ul> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">show1</span><span class="params">(lambda: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    lambda(<span class="keyword">this</span>) <span class="comment">// 在这个函数中this指代的是调用这个扩展函数类型为T的对象,并把它作为参数传递给lambda，</span></span><br><span class="line">    <span class="comment">//在lambda中使用it访问这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>给任意一个类型添加一个扩展函数，lambda 中使用 this 访问这个对象</li></ul> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">show2</span><span class="params">(lambda: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.lambda() <span class="comment">// this指代是调用这个扩展函数类型为T的对象，再将其作为调用lambda的对象</span></span><br><span class="line">     <span class="comment">// 在lambda中使用this访问这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>给任意一个类型添加一个扩展函数,并将这个对象传递给 lambda 表达式,lambda 返回值的类型由 lambda 最后一行的结果决定</li></ul> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T,R&gt;</span> T.<span class="title">show3</span><span class="params">(lambda: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">val</span> result = lambda(<span class="keyword">this</span>)</span><br><span class="line">println(result!!::<span class="keyword">class</span>.java.name)</span><br><span class="line"><span class="comment">// 上行可以打印出lambda表达式最后一行结果的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>运行效果如下</li></ul></li></ul><p>​ <img src="/postImage/image-20220529173006301.png" alt="image-20220529173006301"><img src="/postImage/image-20220529173058283.png" alt="image-20220529173058283"></p><ul><li><h3 id="Kotlin语法糖分析"><a href="#Kotlin语法糖分析" class="headerlink" title="Kotlin语法糖分析"></a><em>Kotlin</em>语法糖分析</h3><ul><li><p><em>apply</em>分析</p><p><em>apply</em>作用：使用 apply 可以进行初始化操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">myApply</span><span class="params">(lambda: <span class="type">T</span>.() -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">this</span>.lambda()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>also 分析</p><p><em>also</em>作用：使用 also 可以完成同时性的操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">myAlso</span><span class="params">(lambda: (<span class="type">T</span>) -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    lambda(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>run 分析</p><p><em>run</em>作用：使用 run 可以执行一段代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">myRun</span><span class="params">(lambda: () -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line"><span class="keyword">return</span> lambda()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T,R&gt;</span> T.<span class="title">myRun</span><span class="params">(lambda: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.lambda()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>with 分析</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T,R&gt;</span> <span class="title">myWith</span><span class="params">(value: <span class="type">T</span>,lambda: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">return</span> value.lambda()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>forEach 分析</p><p><em>forEach</em>作用：使用 forEach 可以遍历完成相关的操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">myForEach</span><span class="params">(lambda: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">lambda(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
