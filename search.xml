<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kotlin嵌套定义及扩展函数</title>
      <link href="/2022/06/26/Kotlin%E5%B5%8C%E5%A5%97%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0/"/>
      <url>/2022/06/26/Kotlin%E5%B5%8C%E5%A5%97%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin嵌套定义及扩展函数"><a href="#Kotlin嵌套定义及扩展函数" class="headerlink" title="Kotlin嵌套定义及扩展函数"></a><em>Kotlin</em>嵌套定义及扩展函数</h1><h2 id="函数嵌套定义"><a href="#函数嵌套定义" class="headerlink" title="函数嵌套定义"></a>函数嵌套定义</h2><p><strong>为什么有这个特性</strong>？</p><p> 让一些代码块独立，不让外部和类内部的其他方法访问</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">input</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> <span class="comment">//输入</span></span><br><span class="line">input()</span><br><span class="line"><span class="comment">//检测</span></span><br><span class="line">validate()</span><br><span class="line"><span class="comment">//服务器发起请求-&gt; 验证</span></span><br><span class="line">request()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>如果嵌套函数内部想访问其他嵌套函数，必须是在定义之后</li><li>嵌套函数可以访问外部的属性和方法</li></ol><hr><h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h2><p><strong>系统库默认的类无法通过继承添加属性和方法，为final修饰，无法继承</strong></p><p>例如：系统库默认的String类被final修饰（看源码）</p><p>如何在<strong>已有类基础</strong>上添加属性或者方法？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">getNumberCount</span><span class="params">()</span></span>:<span class="built_in">Int</span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="string">&quot;I will win in the end!&quot;</span>.getNumberCount()</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li><p>扩展函数并没有真正在扩展类中添加对应的方法</p></li><li><p>扩展函数通常定义在外部(顶层函数)</p></li><li><p>只有这个类或者子类可以访问对应的扩展函数</p><p>示例如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Father.<span class="title">checkAbility</span><span class="params">()</span></span>&#123;</span><br><span class="line">println(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:<span class="type">Father</span></span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span>:<span class="type">Father</span></span>()</span><br><span class="line">Child().checkAbility()</span><br><span class="line">Child2().checkAbility()</span><br></pre></td></tr></table></figure></li><li><p>如果扩展函数和原有类中的函数重名，原有函数的优先级更高</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Father.<span class="title">checkAbility</span><span class="params">()</span></span>&#123;</span><br><span class="line">println(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:<span class="type">Father</span></span>()&#123;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkAbility</span><span class="params">()</span></span>&#123;</span><br><span class="line">println(<span class="string">&quot;in child&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">Child().checkAbility()</span><br><span class="line">输出结果为：<span class="keyword">in</span> child</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>扩展类方法&#x2F;静态方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Father.Companion.<span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">Father.test()</span><br></pre></td></tr></table></figure><hr></li></ol><h2 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h2><h3 id="为什么要扩展属性？"><a href="#为什么要扩展属性？" class="headerlink" title="为什么要扩展属性？"></a>为什么要扩展属性？</h3><p>通过这个属性触发特定的任务</p><h3 id="什么时候要用扩展函数或者扩展属性？"><a href="#什么时候要用扩展函数或者扩展属性？" class="headerlink" title="什么时候要用扩展函数或者扩展属性？"></a>什么时候要用扩展函数或者扩展属性？</h3><p>不想改变原有代码(系统类、三方库、别人写的、自己写的)的基础上</p><ul><li>添加新的功能</li><li>封装</li></ul><p><strong>注意</strong> </p><ol><li><p>扩展属性不提供默认的field变量，无法存值。其实现的本质为：在里面创建对应get和set静态方法</p></li><li><p>扩展属性和类内部的属性重复，类内部的属性优先级最高</p></li><li><p>本质上扩展属性就是两个扩展函数的集合(<em>var val</em>)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin属性</title>
      <link href="/2022/06/24/Kotlin%E5%B1%9E%E6%80%A7/"/>
      <url>/2022/06/24/Kotlin%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin属性"><a href="#Kotlin属性" class="headerlink" title="Kotlin属性"></a><em>Kotlin</em>属性</h1><h2 id="属性的setter和getter方法"><a href="#属性的setter和getter方法" class="headerlink" title="属性的setter和getter方法"></a>属性的<em>setter</em>和<em>getter</em>方法</h2><h3 id="什么时候需要重写setter和getter方法"><a href="#什么时候需要重写setter和getter方法" class="headerlink" title="什么时候需要重写setter和getter方法"></a>什么时候需要重写<em>setter</em>和<em>getter</em>方法</h3><h4 id="setter"><a href="#setter" class="headerlink" title="setter"></a><em>setter</em></h4><ol><li>外部给我值时，需要做额外的处理</li><li>捕获外部<strong>给值</strong>的时机</li></ol><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a><em>getter</em></h4><ol><li>外部获取值时，需要做额外的处理</li><li>捕获外部<strong>需要</strong>的时机</li><li>懒加载</li></ol><h4 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a><em>Kotlin</em></h4><ol><li><code>field </code>是用来存值的</li><li>提供<code>setter</code>方法</li><li>提供<code>getter</code>方法</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">var</span> age:<span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"> <span class="keyword">set</span>(value) &#123;</span><br><span class="line"> tag = <span class="keyword">if</span> (age <span class="keyword">in</span> <span class="number">1.</span><span class="number">.18</span>) &#123;</span><br><span class="line"> <span class="string">&quot;未成年人&quot;</span></span><br><span class="line"> &#125; </span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="string">&quot;成年人&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line"> field = value</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age:<span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">get</span>() &#123;<span class="comment">// 死循环</span></span><br><span class="line"><span class="keyword">return</span> age <span class="comment">//错误 age在默认调用age的get方法</span></span><br><span class="line"><span class="comment">// 本身又在get方法中 出现死循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age:<span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">set</span>(value) &#123;</span><br><span class="line">age = <span class="number">20</span> <span class="comment">//报错 set方法中 调用set方法</span></span><br><span class="line">field = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更改访问权限</span></span><br><span class="line"><span class="keyword">var</span> age:<span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">set</span> <span class="comment">//内部可以改变(赋值) 外部无法赋值 只能访问</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="延迟初始化-lateinit"><a href="#延迟初始化-lateinit" class="headerlink" title="延迟初始化 (lateinit)"></a>延迟初始化 (<em>lateinit</em>)</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> name: String</span><br></pre></td></tr></table></figure><p><strong>为什么使用</strong>：一个变量必须有值 但是定义时不知道给什么值,后续再赋值 </p><p><strong>注意</strong>：在使用之前必须给值，而且<code>lateinit </code>只能修饰<code>var</code>类型变量</p><hr><h2 id="懒加载-by-lazy"><a href="#懒加载-by-lazy" class="headerlink" title="懒加载 (by lazy)"></a>懒加载 (<em>by lazy</em>)</h2><p>懒加载只会调用一次， 后面访问的是变量的值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">val</span> name:String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">println(<span class="string">&quot;在调用lazy&quot;</span>)</span><br><span class="line">    <span class="string">&quot;jack&quot;</span><span class="comment">// 最后一行作为name的值</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>by lazy</code>只能使用<code>val</code><strong>不能</strong>使用<code>var</code>这个变量，且<strong>只能初始化一次</strong></p><hr><h2 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将属性对象的创建过程交给其他类去完成(代理给外部类完成创建)</span></span><br><span class="line"><span class="comment">// 外部类必须满足：getValue() -&gt; 创建对应的对象</span></span><br><span class="line"><span class="comment">// setValue() 可选 看val var</span></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(obj: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: Car &#123;</span><br><span class="line"><span class="comment">//对象的创建就在这里完成</span></span><br><span class="line">println(<span class="string">&quot;property: <span class="variable">$property</span>&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> Car(<span class="string">&quot;马自达&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(obj: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, car: <span class="type">Car</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> bmw:Car <span class="keyword">by</span> CarFactory()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="静态属性、静态方法与成员属性和方法"><a href="#静态属性、静态方法与成员属性和方法" class="headerlink" title="静态属性、静态方法与成员属性和方法"></a>静态属性、静态方法与成员属性和方法</h2><ol><li><p>实例&#x2F;对象方法，必须有这个类的对象，才能调用它的方法  </p><p>缺点：必须要创建对象 </p><p>优点：有这个对象，就可以操作这个对象的数据 </p></li><li><p>什么情况需要静态方法？ </p><ol><li>如果一个方法 不访问这个类的数据 和 这个类的实例方法</li><li>在项目的多个模块、多个类中，不希望创建对象就能使用某个类的方法</li></ol></li><li><p>静态的特点 </p><ol><li>当类被加载到内存中时，静态的属性或者方法同时被加载 </li><li>此时类和静态属性、静态方法同时存在，就可以直接使用类名访问</li></ol></li><li><p>静态方法中是否可以访问类的属性或者实例方法？</p><p><strong>不可以，静态方法被加载时，对象不存在，所以无法访问对象的属性和方法</strong></p></li><li><p>实例方法中是否可以访问静态方法或者静态属性？</p><ul><li>可以</li><li>当类加载时，静态方法和静态属性已经被加载了， 创建对象之后，就可以在对象方法中访问已经存在的静态内容</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>真正的兴趣</title>
      <link href="/2022/06/22/%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%85%B4%E8%B6%A3/"/>
      <url>/2022/06/22/%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%85%B4%E8%B6%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="真正的兴趣"><a href="#真正的兴趣" class="headerlink" title="真正的兴趣"></a>真正的兴趣</h1><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul><li><h3 id="此文作者为知心冰冰，此文仅为转载，可见《冰冰成长心语集》"><a href="#此文作者为知心冰冰，此文仅为转载，可见《冰冰成长心语集》" class="headerlink" title="此文作者为知心冰冰，此文仅为转载，可见《冰冰成长心语集》"></a>此文作者为知心冰冰，此文仅为转载，可见《冰冰成长心语集》</h3></li><li><h3 id="本博客仅因为此文写的确实不错，触动人心，特此转载"><a href="#本博客仅因为此文写的确实不错，触动人心，特此转载" class="headerlink" title="本博客仅因为此文写的确实不错，触动人心，特此转载"></a>本博客仅因为此文写的确实不错，触动人心，特此转载</h3></li></ul><h3 id="一-“-听你讲得这么灵动，我倒是感‘兴趣’了！”"><a href="#一-“-听你讲得这么灵动，我倒是感‘兴趣’了！”" class="headerlink" title="一 “ 听你讲得这么灵动，我倒是感‘兴趣’了！”"></a><strong>一</strong> <strong>“</strong> <strong>听你讲得这么灵动，我倒是感‘兴趣’了！”</strong></h3><p>大一的时候，我曾经跟几个小伙伴一起向校方递交过一份技术社团申请书，数日之后，校方领导就技术社团的申请问题找我洽谈，在洽谈之中，他们一致提议把我们即将创办的社团与另外一个社团合并到一起，说起来，起初我是坚决不同意这种做法的，因为我很清楚，一旦合并，就意味着我们将失去主控权，但是当时摆在我们面前的有这样使我们不得不认真思索的几个问题——–一来是学校不会选择给我们配备资源，因为他们觉得是在消耗资源，二来是我们还是学生，没有这么大的财力去建设属于自己的资源，三来是另外一个社团有着丰富的资源，并入其中，原来我们考虑的资源问题就迎刃而解了！在综合各种因素的考虑之后，我带着我的团队并入了另外一个社团，我也成为了他们社团的其中一个技术讲师，负责日常的教学活动！</p><p>就这样，我们成了那个社团的其中一员，穿上了由那个社团量身定制的会服和会卡，然后出席着由该社团举办的各项活动……一切看似悄无声息地进行着，但其实有一种叫做矛盾的东西，从一开始就穿插在我们的生活之间，只是我们都没有察觉罢了，日子一天天地过，这样的矛盾也在不断加剧，终于有一天，它忍不住爆发了———-“老大，都怪你，把我们并进来”，“老大，我们想退出了”，“老大，我知道你很用心，可这东西学起来太难了，我们不是这块料！”，“老大，对不起，我们不学了”…….”我能够理解你们，可是当初我不是一早就跟你们说过这东西不好学的吗？你们还异口同声地跟我说你们对这很感兴趣，再难也会学下去！”，“老大，你之前的一些公开课，我们有听过，<strong>当时我们觉得你讲得那么灵动，那么有趣，于是就起了兴趣</strong>，想学这个，只是没想到这个定西这么难学，所以就打算放弃了，老大，对不起，我们真的学不下去了，而且自从进了这个社团，每天破事那么多，我们有点累”，“你们…哎，算了，你们走吧！强留你们也没意思”，“谢谢老大”，“走走走，我们走，我王者还等着上铂金呢？”……他们走了之后，我一个人对着黑板，发呆了很久很久，从那一刻起，我瞬间明白了，<strong>别人嘴里说出来的喜欢和兴趣是靠不住的，这样简单的一句喜欢，简单的一句兴趣，任谁都可以随口而出，并不需要费很大的劲！</strong></p><p>忽然想起这样一首歌：《走着走着就散了》，有些人因为一句兴趣，一句喜欢走到了一起，匆匆地凑合，却因一句“对不起，我不感兴趣了，我不喜欢了”一拍而散，匆匆地离场，来也匆匆，去也匆匆，因兴趣和喜欢结了缘，本该是一件好事，可世事总难料，<strong>有些人走着走着，注定是散场，他们所谓的兴趣，所谓的爱好，从一开始，早就失去了应有的灵魂</strong>，<strong>你不是真正的喜欢和感兴趣，自然你也不会有真正的快乐！因此散了也罢，勉强地扯在一起，徒增烦恼而已，又何必纠结于此……</strong></p><hr><h3 id="二-“喜欢便是享受”"><a href="#二-“喜欢便是享受”" class="headerlink" title="二 “喜欢便是享受”"></a><strong>二</strong> <strong>“喜欢便是享受”</strong></h3><h3 id="“你喜欢读书写文章呀！我也很‘喜欢’耶！”"><a href="#“你喜欢读书写文章呀！我也很‘喜欢’耶！”" class="headerlink" title="“你喜欢读书写文章呀！我也很‘喜欢’耶！”"></a><strong>“你喜欢读书写文章呀！我也很‘喜欢’耶！”</strong></h3><p>前段时间，我曾应朋友之邀，去他家做客，看到我来了，他很是热情，先是招呼我到合适的位置坐下，给我倒了一杯热茶，上了些许点心过后，便跑去厨房施展他的厨艺去了，说起来，他这人还真有一点趣头，千辛万苦把我邀请过来，其实不为别的，就为了让我品尝一下他最近做的几款新菜！</p><p>许久过后，他兴高采烈地端出他的佳作，小心翼翼地放在我面前,一股诱人的芳香瞬间扑鼻而来，“发呆干啥，赶快试试我的手艺如何？”，我迟疑了一下，方才拿起筷子，夹了一块放在嘴里，“哇，你近来手艺增长了不少耶，很好吃，真的！”，他噗嗤一笑道：“那是，你不看看我是谁，快吃，好吃就多吃点”，“咦，看把你嘚瑟得什么样，啧啧啧！”话音刚落，他拿起了另外一个筷子，便把菜往我碗里夹，“行了，行了，我自己来，我自己来，你也辛苦了，你坐下一起吃吧！”他点了点头，然后拉了下凳子，坐了下来，拿起筷子，夹了几口菜，放在自己的碗里，见我吃得津津有味，他开始滔滔不绝跟我分享他的做菜故事，我顿然有点享受这样的惬意，一边是美味的食物，一边是精彩的故事，更重要的是，还有这样一位“中看又中用”的厨师帅哥的陪伴，突然间想感慨这样一句———“此曲只应天上有，人间能得几回闻”，自从出来工作，已经很久没有这么享受过生活了，我说我甚是羡慕他懂得如此享受生活，他却摸了摸头，傻傻地笑了，回道：“其实只要你愿意，你也可以这么去享受生活的，<strong>你记住我的一句话——喜欢便是享受，</strong>你看我，虽然谈不上有什么爱好啥的。但我唯独喜欢做菜，当然有空的时候，我也会写写菜谱之类的！”,”对，你说得太对了，<strong>喜欢便是享受！</strong>”……</p><p>那日，他翻出了他撰写的菜谱给我看，身同感受，是的，<strong>他是真的喜欢做菜</strong>，<strong>这才是真正的喜欢，真正的感兴趣，</strong>我不禁意间想起另外一个朋友来，一次，他在微信给我发信息，问道：“近来可好？现在在做什么呢？”，我礼貌性地回了一句：“谢谢你的问候，我近来一切都好着呢？我现在的话，正坐在书桌前，喝着一杯小茶，读着一本书，等会心血来潮。估计又要落笔成文了，哈哈哈”，过了一会，手机叮咚了下，我打开微信，只见他回道：“哇塞，这么优雅惬意的生活，佩服佩服！，<strong>你这么喜欢读书，这么喜欢写文章</strong>，那有没有人告诉你，<strong>我也喜欢这样的生活耶！</strong>”，微信的这头，我噗嗤一笑，顺道灰锴了一下他，道：“得了吧你，我又不是没去过你家，难道你忘记了吗？你家一本书都没有，连笔也不一定找得到，所以你是在逗我，我们认识了那么久，上学那会。每次老师布置作文作业，有哪次不是你让我帮你写的，本来我都不想帮你写的，要不是你苦苦哀求，又是这样那样的，我才懒得理你，而且你要知道，每次写两个作业有多累，哈哈哈！”，信息发出的时候，当时我在想，微信那头，看到信息的他，脸到底有多黑？许久过后，他才发来信息，哈哈一番道：“陈年旧事，不值得一提了啦！你忙吧！不能耽误你工作！”。就这样，我跟他匆匆结束了话题！其实想来也颇有一番顿悟，他是个浪荡不羁的人，注定按捺不住自己的心，无法平静下来，他朋友圈总是晒着一堆旅游照，今天在一个地方，明天又在另一个地方，生活很是潇洒，但回到当我说我喜欢读书写文章，他附和说自己也喜欢和感兴趣的这个问题上，我想我顿然明白了一个道理：所谓的喜欢和感兴趣有时已经沦为别人套近乎，拉近距离，博取共鸣之感的手段，<strong>人生在世，谁不希望有几个志同道合之人为友呢？这样子自己不显得过于孤单，那是一种来自内心强烈的渴望</strong>，在这样一种渴望的驱动之下，你喜欢的和感兴趣的东西，他说他也喜欢和感兴趣的时候，自然，你便有了巴不得跟他立马成为好朋友的一丝瞎想！<strong>他所谓的感兴趣，所谓的喜欢，从一开始便失去了应有的灵魂，这也就注定了有一天你们不会在一个频道上前进！</strong></p><p><strong>真正的感兴趣，真正的喜欢，就像我那位厨师朋友那样，是发自内心真真切切的渴望，不是形式上的美好，也不是让别人摸不着边际的套路，它是有自己灵魂的，缺了灵魂的兴趣和喜欢，注定不是真正的兴趣，真正的喜欢！</strong></p><hr><h3 id="三-“我一直喜欢……”"><a href="#三-“我一直喜欢……”" class="headerlink" title="三 “我一直喜欢……”"></a><strong>三</strong> <strong>“我一直喜欢……”</strong></h3><p>一次活动，我偶然认识了小A，相互加了微信，也聊了一段时间，她告诉我说：“冰冰姐，<strong>其实我一直很喜欢画画</strong>，于是读了设计专业，但是毕业出来的时候，在机缘巧合之下，却做了销售！”，我问她说：“那你为什么不考虑去从事设计相关的工作呢？”，她说：“刚开始的时候，我确实挺想从事这一行的，但是面试了很多家公司，都没有通过，那时我很沮丧，偶然间看到一家公司在招销售岗位，我觉得自己口才还不错，于是就去面试了，结果没想到通过了，自此我便做了销售，与设计再也无缘了”，听到这里，我叹了一口气，安慰道：“哎，可惜了，不过我现在抛开你的职业不说，只想问你这样的一个问题，你必须特别认真地回答，先不急着回答我，你考虑清楚之后，再告诉我答案！”。</p><p>几天之后，她回复了我说：“冰冰姐，我想清楚了，我还是那一句话，<strong>我一直很喜欢画画</strong>！”，我有点开心，回复道：“很好啊！其实我想听到是你这样的回答，坚持初心，才能方得始终！当然我还有一个问题，需要你认认真真的回答我，你有自己的作品集吗？”，大概了过了一会，她回复我说：“啊，冰冰姐，我没有作品集哟！而且我已经很久没有画过了，更别说作品集了……”,我皱了下眉头，忽然有点丧，回道说：“那你收回你那句’一直很喜欢’的话吧！因为你不是真的喜欢画画，你不是真的对画画感兴趣！”,“为什么呀！<strong>我是真的一直很喜欢画画</strong>，就是工作忙了点，没时间画，当然还有别的因素，我平常也有关注一些画画的论坛，公众号之类的，看别人的一些作品，如果我不是喜欢的话，那又如何解释呢？要不然冰冰姐，你给我说说什么才是真正的喜欢，真正的感兴趣！”,“等你画了几幅画之后，自然就会明白了！”,“好！那冰冰姐，到时我还是不懂的话，我再请教你，哈哈哈！”。</p><p>2个月后，她用手机拍了她画的几幅画，发了给我，我定是惊喜，回道：“不错啊，怎么样，你领悟到了什么才是真正的喜欢和感兴趣了吗？”“哈哈哈，我好像明白了，<strong>真正的喜欢和感兴趣，不是形式上的美好，也不是靠嘴巴说出来的，是靠行动和实践出来的，对一个喜欢画画的人来说，如果没有自己的作品集，其实并谈不上什么喜欢，更谈不上什么感兴趣！</strong>”，“正解，这就是我要让你领悟的东西！<strong>真正的兴趣和喜欢，需要配以极强的行动力才能称得上是真正的，它是有灵魂的，倘若一个人对一件事很感兴趣，很喜欢，那么他心里更渴望的是在这件事有所建树</strong>，<strong>而要有建树，就必须有强大的行动力！当然，也请你记住这样一句话：越是逆境，越是能够坚持的东西，才配得上叫兴趣，叫做喜欢！</strong>”，”明白了，谢谢冰冰姐，我知道怎么做了！”。</p><p>数月之后，她开心地跟我说她转型做了设计师，并完成了属于自己人生的第一本画集！人生有时往往这样，<strong>你不逼自己一把，你永远不知道自己有多优秀！</strong></p><hr><h3 id="四-“我发现我对你突然很感‘兴趣’，我‘喜欢’上你怎么办？”"><a href="#四-“我发现我对你突然很感‘兴趣’，我‘喜欢’上你怎么办？”" class="headerlink" title="四 “我发现我对你突然很感‘兴趣’，我‘喜欢’上你怎么办？”"></a><strong>四</strong> <strong>“我发现我对你突然很感‘兴趣’，我‘喜欢’上你怎么办？”</strong></h3><p>微友小B，是我在一个社群上加的，那时加他，纯粹只是为了业务需要，空闲时，我会跟他聊天，我很乐意跟他分享一些东西，当然他也很乐意跟我分享关于他的，有时觉得互联网最强大的一个地方，就是让两个素未谋面的人相逢于线上，这也许就是缘分吧！</p><p>我跟他聊了大概有一个月左右，本以为会一直以聊友的关系保持着联系，可是有一天，情况终于变了，他忽然给我发了一句这样的信息：“<strong>我发现我对你突然很感兴趣，我喜欢上你了怎么办？</strong>”，起初看到这样的信息，我并不太想回复，但是出于礼貌，我还是选择了回复，道：“这样子啊，很好，那我问你几个问题！，你必须认真回答我”，“可以啊，是不是要考验我啊！哈哈，那你快点问！”，“好，第一个问题就是你知道我平常都喜欢吃什么，穿什么颜色的衣服吗？”，“不知道”，“第二个问题就是你知道我平常都喜欢去哪些地方玩吗？”“不知道”，“第三个问题就是你知道我最喜欢做的事是什么吗？”，“不知道”，“第四个问题就是你知道我的梦想是什么吗？”，“不知道”……”好了，我问完了，你出局了！”，“为啥呀，你连机会都不给我，那我怎么了解你！”，“不不不，因为你不是一个用心之人，我刚刚问你的好几个问题，其实在我朋友圈都有过一丝痕迹，只是你缺了耐心去翻罢了，真正对一个人感兴趣，真正喜欢一个人并不是这样子的……因为感兴趣，因为喜欢，才会主动去了解！”“这样子啊，那我现在去翻下，看一下可以吗？”，“不了，你出局了，你不是真的对我感兴趣，也不是真的喜欢我，你只是想摆脱单身的状态罢了！”，“好吧，不好意思，打扰了！”……自此，他再也没找我聊过天！</p><p>这个世界上，总有一种让你特别揪心的生物，聊着聊着就说对你感兴趣，聊着聊着就说喜欢你，聊着聊着就说爱上你，没错，这种生物就是那些忽然给你发微信说<strong>“我发现我对你突然很感兴趣，我喜欢上你怎么办？”的人！</strong>微信式的告白，抛开那个自己真的喜欢的人不说，倒是显得有些浮躁，你到底了解对方多少，喜欢对方什么，可能连你自己都不清楚，你是为了摆脱脱单的状态？还是真的感兴趣？真的喜欢？<strong>感情就是一个特别微妙的东西，本就来不得一丝马虎，因为谁都不希望跟着一个感情敷衍的人过一辈子，谁也不愿意冒着风险在感情上做赌注，爱对了，就是爱情，爱错了，就是青春</strong>，真的喜欢一个人，真的对一个人感兴趣，就会迫不及待地想去了解，而不是等着对方来告诉你，当对方愿意告诉你的时候，是因为信任……</p><p><strong>终有一天，当你明白真正的喜欢，真正的感兴趣，是有自己的灵魂的</strong>，也许你就真真正正地，透彻地懂得了自己的心！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin构造函数与单例</title>
      <link href="/2022/06/21/Kotlin%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8D%95%E4%BE%8B/"/>
      <url>/2022/06/21/Kotlin%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8D%95%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin构造函数与单例"><a href="#Kotlin构造函数与单例" class="headerlink" title="Kotlin构造函数与单例"></a><em>Kotlin</em>构造函数与单例</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>类是同一类事物的高度抽象的，不实际存在的（不会占内存）的概念</li><li>对象是类的实例化，现实化（具体存在，完成具体任务&lt;存值，执行&gt;）</li><li>存值：成员变量，属性变量</li><li>执行：行为，方法</li></ul><hr><h2 id="为什么要有构造函数？"><a href="#为什么要有构造函数？" class="headerlink" title="为什么要有构造函数？"></a>为什么要有构造函数？</h2><ol><li><p>默认的无参构造函数  </p><p>类本身不知道如何创建⾃⼰的对象，对象本身是由顶层类来构建，再由当前这个类来初始化那个对象</p></li><li><p>重载的有参构造⽅法  </p><ol><li>为了⽅便给初始化值  </li><li>在创建对象的同时给予某些需要的数据(时机)</li></ol></li></ol><hr><h2 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h2><h3 id="单例对象概念"><a href="#单例对象概念" class="headerlink" title="单例对象概念"></a>单例对象概念</h3><p>当我们巧妙使⽤private来私有化构造⽅法，给外部提供⼀个单例对象(整个程序运⾏中这个类只有⼀个对象)</p><h3 id="如何得到单例对象"><a href="#如何得到单例对象" class="headerlink" title="如何得到单例对象"></a>如何得到单例对象</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a><em>Java</em></h4><ol><li><p><strong>私有化</strong>构造⽅法 -&gt; 使<strong>外部⽆法</strong>创建这个类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Animal</span><span class="params">()</span>&#123;&#125; </span><br></pre></td></tr></table></figure></li><li><p>在<strong>类内部</strong>提供⼀个<strong>静态</strong>的成员属性 -&gt; 静态变量只会初始化<strong>⼀次</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Animal</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br></pre></td></tr></table></figure></li><li><p>给外部提供⼀个<strong>静态⽅法</strong> -&gt; 获取这个对象</p><p><strong>注意</strong>: 此处未考虑内存消耗和线程安全 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title function_">getInstance</span><span class="params">()</span>&#123; <span class="keyword">return</span> instance; &#125;</span><br></pre></td></tr></table></figure></li><li><p>外部获取这个对象 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal.getInstance();</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意</strong>：系统类库中以下开头的⽅法通常都是提供<strong>单例</strong></p><ul><li><strong>instance</strong></li><li><strong>shared</strong></li><li><strong>default</strong></li></ul><hr><h4 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a><em>Kotlin</em></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()&#123;<span class="comment">// kotlin单例不完善版本</span></span><br><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">val</span> defaultInstance = Animal()</span><br><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: Animal &#123;</span><br><span class="line"> <span class="keyword">return</span> defaultInstance</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;<span class="comment">// kotlin单例一般写法</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> sharedAnimal: Animal <span class="keyword">by</span> lazy(LazyThreadSafetyMode.SYNCHRONIZED) &#123;</span><br><span class="line">            Animal()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Kotlin构造函数"><a href="#Kotlin构造函数" class="headerlink" title="Kotlin构造函数"></a>Kotlin构造函数</h2><ol><li><p>主构造函数 </p><ul><li><p>创建⼀个没有主体的类 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span></span><br></pre></td></tr></table></figure></li><li><p>显示指定构造⽅法 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> <span class="keyword">constructor</span></span>() </span><br></pre></td></tr></table></figure></li><li><p>主构造函数需要传递⼀个字符串对象 constructor不能省略</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person3</span> <span class="keyword">constructor</span></span>(<span class="keyword">var</span> name:String) </span><br></pre></td></tr></table></figure></li><li><p>有修饰符限定构造函数权限时 constructor不能省略 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person4</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() </span><br></pre></td></tr></table></figure></li><li><p>如果有⽗类，必须直接调⽤⽗类的构造函数 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person5</span> : <span class="type">Father</span></span>() </span><br></pre></td></tr></table></figure></li><li><p>如果⽗类有参数 ⼦类必须提供相应有参的构造函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Father2</span> <span class="keyword">constructor</span></span>(name: String) </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person6</span> <span class="keyword">constructor</span></span>(name: String) : Father2(name) </span><br></pre></td></tr></table></figure></li></ul><hr></li><li><p>次构造函数 </p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(name:String) : <span class="keyword">this</span>()&#123;&#125; </span><br><span class="line"><span class="comment">// 注意：</span></span><br><span class="line"><span class="comment">//     a.次构造函数必须直接调⽤主构造函数 </span></span><br><span class="line"><span class="comment">//     b.如果有⽗类，必须调⽤⽗类的构造函数 </span></span><br></pre></td></tr></table></figure><ul><li><p>次构造函数必须继承主构造函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person7</span></span>(name: String) &#123; </span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>): <span class="keyword">this</span>(name)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>次构造函数只需要考虑和主构函数的关系</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Father3</span> <span class="keyword">constructor</span></span>(name: String)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person8</span> <span class="keyword">constructor</span></span>(name: String) : Father3(name)&#123; </span><br><span class="line"><span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>):<span class="keyword">this</span>(name) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的equals()和==</title>
      <link href="/2022/06/18/Java%E7%9A%84equals-%E5%92%8C/"/>
      <url>/2022/06/18/Java%E7%9A%84equals-%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Java的equals-与-x3D-x3D"><a href="#Java的equals-与-x3D-x3D" class="headerlink" title="Java的equals()与&#x3D;&#x3D;"></a><em>Java</em>的equals()与&#x3D;&#x3D;</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><em>java</em>中的<code>euqals()</code>是<strong>成员方法</strong></li><li>而<code>==</code>是<strong>运算符</strong></li></ol><p>切记、切记、切记！！！</p><hr><h2 id="x3D-x3D"><a href="#x3D-x3D" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h2><ol><li>如果等号两边比较的对象为基本数据类型，则比较是变量存储内容的值（<em>value</em>)，即比较等号两边<strong>数值</strong>是否相等</li><li>如果等号两边比较的是引用类型，则比较的是<strong>其存储的对象内存地址</strong>是否相等</li></ol><p><strong>注意</strong>：</p><ul><li><em>Java</em>只有值传递（<em>call by value</em>）</li><li>String类型以及你自己创建的对象都是引用类型</li><li>引用类型变量存储的是<strong>对象</strong>在堆中的<strong>地址</strong></li><li>因为<em>Java</em>只有值传递，所以对于<code>==</code>，无论&#x3D;&#x3D;两边比较的是什么，其本质比较的都是值（<em>value</em>)</li></ul><hr><h2 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h2><h3 id="equals-方法没有被覆盖"><a href="#equals-方法没有被覆盖" class="headerlink" title="equals()方法没有被覆盖"></a>equals()方法没有被覆盖</h3><ul><li><p>通过<code>equals()</code>比较类的两个对象是，相当于通过<code>==</code>比较对象，使用的是<em>Object</em>类的<code>equals()</code></p><p>Object类的equals方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="equals-方法被类覆盖"><a href="#equals-方法被类覆盖" class="headerlink" title="equals()方法被类覆盖"></a>equals()方法被类覆盖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;s1==s2: &quot;</span> + (s1 == s2));</span><br><span class="line">        System.out.println(<span class="string">&quot;a==b: &quot;</span> + (a == b));</span><br><span class="line">        System.out.println(<span class="string">&quot;a.equals(b): &quot;</span> + (a.equals(b)));</span><br><span class="line">        System.out.println(<span class="string">&quot;42 == 42.0 : &quot;</span> + (<span class="number">42</span> == <span class="number">42.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果</span><br><span class="line">s1==s2: true</span><br><span class="line">a==b: false</span><br><span class="line">a.equals(b): true</span><br><span class="line">42 == 42.0 : true</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li><em><strong>String中的 equals方法是被重写过的，因为 Object的 equals方法是比较的对象的内存地址，而 String的 equals方法比较的是对象的值</strong></em></li><li><em><strong>当创建 String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String对象</strong></em></li></ul><h3 id="String类中的equals方法源码："><a href="#String类中的equals方法源码：" class="headerlink" title="String类中的equals方法源码："></a>String类中的equals方法源码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li><em>equals</em>方法不能用于判断基本数据类型的变量，如只能用来判断两个对象是否相等</li><li>如果没有对equals方法进行<a href="https://so.csdn.net/so/search?q=%E9%87%8D%E5%86%99&spm=1001.2101.3001.7020">重写</a>，则比较的是引用类型的变量所指向的对象的地址。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2022/06/17/JDBC/"/>
      <url>/2022/06/17/JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a><em>JDBC</em></h1><h2 id="JDBC简介"><a href="#JDBC简介" class="headerlink" title="JDBC简介"></a><em>JDBC</em>简介</h2><p><em>JDBC</em>（<em>Java Data Base Connectivity</em>）是一套基于<em>Java</em>语言实现的、执行<em>SQL</em>语句的<em>Java</em> API（Application Programming Interface），它屏蔽了于数据库通信的细节，使<em>Java</em>应用程序调用<em>JDBC</em> API ，即可发送<em>SQL</em>语句访问数据库</p><hr><h2 id="JDBC框架"><a href="#JDBC框架" class="headerlink" title="JDBC框架"></a><em>JDBC</em>框架</h2><ol><li><em>JDBC API</em>：提供应用程序与JDBC驱动管理器之间的连接</li><li><em>JDBC</em> 驱动管理器（<em>JDBC Driver Manager</em>)：装载并管理数据库驱动器，建立与数据库之间的连接  </li><li><em>JDBC</em> 驱动器API（<em>JDBC Driver API</em>)：负责JDBC驱动管理器与驱动器的连接</li><li><em>JDBC</em> 驱动器（<em>JDBC Driver</em>)：负责与数据库连接</li></ol><img src="https://ezralinblogpicture-1311676448.cos.ap-chongqing.myqcloud.com/blogPicture/ JDBC.jpg"/><hr><h2 id="编写JDBC-API应用程序"><a href="#编写JDBC-API应用程序" class="headerlink" title="编写JDBC API应用程序"></a>编写<em>JDBC API</em>应用程序</h2><ol><li><p>选择并加载一个合适的JDBC驱动程序</p></li><li><p>创建一个Connection对象，建立与数据库的连接</p></li><li><p>创建一个Statement对象或PreparedStatement对象（普遍采用）</p></li><li><p>通过Statement对象或PreparedStatement对象执行SQL语句，进行数据库操作</p></li><li><p>返回ResultSet结果集，并通过返回的ResultSet对象获取相应的数据</p></li><li><p>关闭相关连接，清理对象</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConnection</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;<span class="comment">//选择并加载一个合适的JDBC驱动程序</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;驱动程序无法加载!&quot;</span>);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//创建一个Connection对象，建立与数据库的连接</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/javahomework?characterEncoding=utf8&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">userPassword</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn = DriverManager.getConnection(url, userName, userPassword);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;]()</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">findStudentByName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">List&lt;Student&gt;list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseConnection.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from student where name like ?&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个Statement对象或PreparedStatement对象</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;%&quot;</span>+name+<span class="string">&quot;%&quot;</span>);</span><br><span class="line">            <span class="comment">//返回ResultSet结果集，并通过返回的ResultSet对象获取相应的数据</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">stu.setNumber(rs.getString(<span class="string">&quot;number&quot;</span>));</span><br><span class="line">stu.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">stu.setGender(rs.getString(<span class="string">&quot;gender&quot;</span>));</span><br><span class="line">stu.setProfession(rs.getString(<span class="string">&quot;profession&quot;</span>));</span><br><span class="line">stu.setMath(rs.getInt(<span class="string">&quot;math&quot;</span>));</span><br><span class="line">stu.setChinese(rs.getInt(<span class="string">&quot;chinese&quot;</span>));</span><br><span class="line">stu.setComputer(rs.getInt(<span class="string">&quot;computer&quot;</span>));</span><br><span class="line">stu.setTotal(rs.getInt(<span class="string">&quot;total&quot;</span>));</span><br><span class="line">list.add(stu);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//关闭相关连接，清理对象</span></span><br><span class="line">rs.close();</span><br><span class="line">ps.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>具体语法太简单，在此不做说明，如有需要请阅读：<a href="https://www.runoob.com/java/java-mysql-connect.html">Java MySQL 连接 | 菜鸟教程 (runoob.com)</a></p><p>主要是理清<em>JDBC</em>的框架，这样编写程序就没有太大问题</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内部类</title>
      <link href="/2022/06/16/Java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2022/06/16/Java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内部类"><a href="#Java内部类" class="headerlink" title="Java内部类"></a><em>Java</em>内部类</h1><h2 id="内部类的概念"><a href="#内部类的概念" class="headerlink" title="内部类的概念"></a>内部类的概念</h2><ul><li>内部类是在另一个类或方法的定义中定义的一个类，即在其他类或方法内部定义的类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">StoneVillage</span> &#123;<span class="comment">//内部类——石村</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部类作用"><a href="#内部类作用" class="headerlink" title="内部类作用"></a>内部类作用</h2><ol><li><p>实现类的重用功能</p><ul><li>把一个类的定义全部放入类体中，使其可以被直接使用，不必通过创建对象来使用，实现类的重用</li></ul></li><li><p>实现多重继承</p><ul><li>如果一个类已经继承与另一个类，此时这个类的内部类可以再继承于另一个类，就相当于继承两个类</li></ul></li><li><p>增强封装</p><ul><li>可以把一些数据隐藏在内部类中，使用时，不必声明该内部类的具体对象，而通过外部类对象调用内部类数据</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 内部类的所有属性和方法外部均可调用,无论其访问权限如何</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawWater</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StoneVillage</span> <span class="variable">stoneVillage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StoneVillage</span>();</span><br><span class="line">        stoneVillage.machine = <span class="string">&quot;Water pump&quot;</span>;</span><br><span class="line">        stoneVillage.use();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">StoneVillage</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String machine;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The water pump was used&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// main函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.drawWater();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><ul><li>如果不希望通过外部类使用内部类，可以把内部类声明为<em>static</em>,这样内部类就可以在类外直接访问</li><li>静态内部类因为已经声明为static，所以它只能访问外部类的静态属性和静态方法</li><li>静态内部类若想访问外部类的非静态属性和方法，可以先实例化一个外部类对象访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span> &#123;</span><br><span class="line">            o.i = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="匿名内部类-anonymous-inner-class"><a href="#匿名内部类-anonymous-inner-class" class="headerlink" title="匿名内部类(anonymous inner class)"></a>匿名内部类(<em>anonymous inner class</em>)</h2><ul><li>当内部类名字被省略时，我们称此时的内部类为匿名内部类</li><li>通常在方法中使用，即方法中定义的省略了名字的内部类</li><li>匿名内部类可以访问所有的外部类的方法变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Paper <span class="title function_">pp</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 从内部类定义开始</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Paper</span>() &#123;</span><br><span class="line">            <span class="keyword">private</span> String line;</span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">mark</span><span class="params">()</span> &#123;</span><br><span class="line">                line = s;</span><br><span class="line">                <span class="keyword">return</span> line;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; <span class="comment">// return 语句结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Paper</span> <span class="variable">c</span> <span class="operator">=</span> test.pp(<span class="string">&quot;I will win in the end!&quot;</span>);</span><br><span class="line">        System.out.println(c.mark());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java接口与多态</title>
      <link href="/2022/06/16/Java%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
      <url>/2022/06/16/Java%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Java接口与多态"><a href="#Java接口与多态" class="headerlink" title="Java接口与多态"></a><em>Java</em>接口与多态</h1><hr><h2 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（<em>interface</em>）</h2><ul><li><p>接口概念</p><ul><li>接口类似于一种“插件”，只要“接上”就能使用，但这种“插件”需要自己具体实现</li><li>接口是类与类之间连接的通道，不同类之间可以通过接口互通信息，从而实现类与类之间的资源交互</li></ul></li><li><p>接口用途</p><ol><li>实现多重继承</li><li>统一规范</li></ol></li></ul><hr>### 接口的声明及实现  <h4 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h4><ul><li><p>接口使用关键字<em><strong>interface</strong></em></p></li><li><p>在接口中，所有定义的常量默认修饰为<em>public static final</em>  </p></li><li><p>在接口中，所有定义的方法默认修饰为<em>public abstract</em> ,当然可以自己显示修饰</p></li></ul><p><strong>注意</strong>：</p><ul><li>接口没有构造方法，不能被实例化，<em>JDK8</em>之后允许在接口中使用默认方法和静态方法</li><li>接口中的静态方法可以具体实现，默认方法不要求实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">driverCar</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">required</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;default method&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">route</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;a static function is defined&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><ul><li>接口通过具体类来实现，即通过类实现接口，不能采用new运算符创建对象方式生成，接口只是”插件“，不能离开具体的类  </li><li>接口使用关键字<em><strong>implements</strong></em>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnlineShopping</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addToShoppingCart</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">food</span> <span class="keyword">implements</span> <span class="title class_">OnlineShopping</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToShoppingCart</span><span class="params">()</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h4><p>接口可以实现多继承，如同*C++*里面的一般。但是继承后，<strong>实现接口时，需要将父类的抽象方法一同实现</strong>。</p><p>就如同斗罗大陆里面的双生武魂，同时拥有其父母的武魂，后天需要给两个武魂分别配置魂环</p><p><strong>注意</strong>：<em>Java</em>不支持多继承，但是支持实现多个接口（而且接口可以多继承）这样就达到了多继承的目的以便于完成相应的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HaoTianHammer</span> &#123;<span class="comment">// 昊天锤</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hit</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlueGrass</span> &#123;<span class="comment">// 蓝银草</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">entangle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TwinMartialSoul</span> <span class="keyword">extends</span> <span class="title class_">HaoTianHammer</span>, BlueGrass &#123;<span class="comment">// 双生武魂</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">TwinMartialSoul</span> &#123; <span class="comment">// 实现多继承的接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hit</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">entangle</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="多态（polymorphism"><a href="#多态（polymorphism" class="headerlink" title="多态（polymorphism)"></a>多态（<em>polymorphism</em>)</h2><h3 id="多态实质"><a href="#多态实质" class="headerlink" title="多态实质"></a>多态实质</h3><ul><li>多态实质上是由向上转型（<em>upcasting</em>）和动态绑定（dynamic binding）机制结合完成</li><li>多态就是对于同一个消息，不同对象做出不同的行为</li><li>多态需要和<strong>继承</strong>配合使用，需要重写方法</li><li>多态是一种继承关系下，基于动态绑定机制的接口实例</li></ul><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>子类对象赋值给父类对象，子类舍弃自己的特征——“返祖”</li><li>子类向上转型后，只能调用父类定义的方法，不能调用父类没有而子类有的方法</li></ul><p><strong>注意</strong>：当子类与父类含有<strong>同名</strong>的方法时，子类对象向上转型而生成的父类对象能<strong>自动调用子类的方法</strong>，此种用法运用广泛</p><hr><h3 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h3><h4 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h4><ul><li><p>将一个方法调用同一个方法所在的类关联在一起就是<strong>绑定</strong></p></li><li><p>绑定分为静态绑定和动态绑定  </p><ul><li><p>静态绑定  </p><p>在编译前，编译器就能确定应该调用哪个方法，此时绑定在运行前完成，也称为<strong>前期绑定</strong>。</p><p>一般来说，静态绑定的代码写法是<strong>写死的</strong>，也可以根据此判断是否为静态绑定</p></li><li><p>动态绑定</p><p>程序在<strong>运行期间</strong>由<em>JVM</em>根据对象的类型自动判断应该调用哪个方法，也称为<strong>后期绑定</strong> 。</p><p>也就是说，在运行时才能把方法调用与方法所属类关联在一起</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态绑定</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">tangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        tangsan.play();<span class="comment">//通过对象调用方法，属于静态绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多态绑定</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person[] persons = <span class="keyword">new</span> <span class="title class_">Person</span>[<span class="number">7</span>];<span class="comment">// 生成对象数组，史莱克七怪</span></span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; persons.length; i++) &#123;</span><br><span class="line">            n = r.nextInt(<span class="number">7</span>)</span><br><span class="line">            <span class="keyword">switch</span>(n) &#123;<span class="comment">//Person1,Person2均为Person的子类</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: persons[i] = <span class="keyword">new</span> <span class="title class_">Person1</span>(); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: persons[i] = <span class="keyword">new</span> <span class="title class_">Person2</span>(); <span class="keyword">break</span>;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; persons.length; i++) &#123;</span><br><span class="line">                persons[i].play();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上实例可以看出，编译时，persons[i].play()无法确定调用的是Perosn的哪一个子类的方法，只有运行时，才能确定，这就是动态关联</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2022/06/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/06/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a><em>Java</em>多线程</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul><li>进程是一个可运行的程序，启动一个程序就启动了一个进程</li><li>一个线程内可以启动多个程序，线程也称为轻量级进程（<em>light-weight process</em>)</li><li>每个进程各自独自一份内存空间，一个进程内的多个线程属于同一个进程</li><li>多个线程共同处于一个内存空间的优势在于能直接共享数据和资源</li></ul><hr>  <h2 id="多线程创建方式"><a href="#多线程创建方式" class="headerlink" title="多线程创建方式"></a>多线程创建方式</h2><ul><li>生成一个<em>Thread</em>类的对象来创建线程</li><li>编写一个类，实现<em>Runnable</em>接口，然后在<em>Thread</em>类的构造方法中启动它</li><li>太过于简单，此处不举例</li></ul><hr><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><table><thead><tr><th>线程基本状态</th><th>调用方法</th><th>说明</th></tr></thead><tbody><tr><td>新建状态</td><td>new Thread()</td><td>用new创建一个新线程对象</td></tr><tr><td>就绪状态</td><td>start()</td><td>调用start()，启动线程</td></tr><tr><td>运行状态</td><td>run()</td><td>线程活动CPU时间，执行run方法</td></tr><tr><td>休眠状态</td><td>sleep()</td><td>进入休眠，不占用CPU</td></tr><tr><td>等待状态</td><td>wait()</td><td>线程等待某种请求完成，始终在等待，期间不允许执行其他操作</td></tr><tr><td>死亡状态</td><td>interrupt()</td><td>线程已完成任务正常退出，或阻塞状态被中断运行，需捕获异常后退出</td></tr></tbody></table><hr><h2 id="java锁"><a href="#java锁" class="headerlink" title="java锁"></a><em>java</em>锁</h2><ul><li><p>Java中的锁分为显示锁和隐式锁。隐式锁由synchronized关键字实现，⽽显示锁是由实现了 Lock接⼝和AQS框架等等类来实现。</p></li><li><p>锁的分类  </p><p>​从宏观上看，锁的分类有多种不同划分。可以分为乐观锁和悲观锁，可以分为共享锁和排他锁，还可以分为可重⼊锁和不可重⼊锁等等。  </p><ul><li><p>乐观锁</p><p>乐观锁就是对数据冲突保持乐观态度的锁，它认为不会有其他线程同时修改数据。因此乐观锁不会上锁，只是在更新数据的时候判断是否有其他线程更新，如果没有其他线程修改，它则更新数据， 有其他线程修改，它则放弃数据，重新读取数据处理。  </p></li><li><p>悲观锁</p><p>悲观锁对数据冲突持悲观的态度，认为总是发⽣数据冲突。因此它以⼀种预防的态度，先⾏把数据锁住，知道操作完成才释放锁，在此期间其他线程⽆法操作数据。</p></li></ul></li></ul><hr>  <h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a><em>synchronized</em>关键字</h2><p><em>java</em>中每一个对象都可以作为锁，有三种加锁方式：</p><ul><li>对于普通同步⽅法，锁是当前实例对象  </li><li>对于静态同步⽅法，锁是当前类的 Class 对象</li><li>对于同步⽅法块，锁是 Synchonized 括号⾥配置的对象</li></ul><hr>  <h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>synchronized关键字的实现，依赖于<em>Java</em>的对象头</p><ul><li>⼀个对象由三部分组成：对象头、实体数据、对⻬填充。对象头的⻓度不是固定的，如果是数据类型则对象头占12个字节，⾮数组类型对象头占8个字。</li><li>⾮数组类型的对象头分两部分，Mark Word 和对象类型指针，数组类型对象会多⼀部分来存储数组的⻓度。⽽<em>synchronized</em>关键字的实现，就和对象头中的Mark Word密切相关。</li></ul><p>为了提⾼虚拟机空间的使⽤效率，Mark Word被设计成⼀个⾮固定的动态数据结构，以便存储 更多的信息。不同状态下对象头Mark Word存储的信息如下图</p><p><img src="/postImage/img-4.png"></p><h2 id="synchronized锁的状态"><a href="#synchronized锁的状态" class="headerlink" title="synchronized锁的状态"></a><em>synchronized</em>锁的状态</h2><p>synchronized锁的状态被分为4种，级别从低到⾼依次是：⽆锁、偏向锁、轻量级锁、重量级锁。  </p><p>我们此处讲解偏向锁，因为其他部分较难，有兴趣的朋友可以自行查找  </p><ul><li><p>偏向锁</p><ul><li>⼤多数情况下，锁不仅不存在多线程竞争，⽽且总是由同⼀线程多次获得，为了让线程获得锁的代价更低⽽引⼊了偏向锁。  </li><li>这个锁永远会偏向于获得它的线程，如果在获得锁之后并没有其他线程获取，则获得偏向锁的线程永远不需要同步，减少锁带来的时间消耗</li></ul></li><li><p>偏向锁的获取  </p><p>偏向锁对象头将不在存放Hash值，而在此位置上存放线程ID（23bit）+Epoch(2bit),⼀共25bit, 其他部分保持不变。Epoch是⼀个时间戳，⽤来判断线程ID是否过时。具体获得锁流程如下： 匿名偏向是偏向锁的初始状态，所以先判断锁标志，再判断偏向锁标志位，只有最后三位是 101才开始，否则直接⾛其他的锁。如果是匿名状态，线程ID为0，采⽤CAS去将当前线程写入，如果成功则获得锁，不成功表示存在竞争。线程ID不为0，此前已经有偏向，判断此值是 否和当前线程相同，若⼀致则表示线程之前就获得了锁，不⼀致就尝试CAS替换。同意，替换 成功获得锁，替换失败存在竞争。未获得锁时将会等待安全点（STW），安全点会进⾏偏向锁的撤销。</p><p>安全点是JVM在进⾏垃圾GC时为了保证引⽤关系不会发⽣变化⽽设置的安全状态（GC Roots 的确定就在此时），STW(STOP THE WORLD)此时将暂停所有线程的⼯作。</p><p>在STW会检测持有偏向锁的线程是否还存活，如果存活则升级轻量级锁，如果线程未存活或者已经退出来同步代码块，将会判断是否可重偏向，否则直接升级为轻量级锁。允许重偏向时，会先设置为匿名重偏向，再使⽤CAS偏向线程。</p><p>判断是否可重偏向需要⽤到Epoch,偏向锁中有⼀个Epoch，对应的Class类中也有⼀个 Epoch。在进⼊全局安全点之后，⾸先会对Class类中的Epoch进⾏增加，得到新的 Epoch_new，然后扫描所有持有Class类实例的线程，根据线程信息判断是否锁住了该对象。 如果锁住了说明此对象还在使⽤，将Epoch_new更新给它，如果未锁住则说明不需要加锁， 不进⾏更新。如果对象的Epoch和类的Epoch相同，则表示它是被更新过的，需要锁，不能重偏向。⽽如果不相同，则表示已经不需要加锁了，此对象可以重偏向到其他线程。  </p></li><li><p>偏向锁的释放 </p><p>从偏向锁的获取过程可以看到，等到竞争出现的时候才会释放。如果没有出现竞争，它不会去改变Mark Word的相关字段。就算是线程已经执⾏完同步代码块，不需要加锁了，也不会去修改对象头，那个锁依旧存在，依旧保持偏向。 </p><p>只是在其他线程需要偏向，出现了竞争的时候会进⾏判断，如果以前偏向的线程不需要了，那 么对象⾸先会被设置为匿名偏向，然后CAS替换尝试加锁。如果以前偏向的线程还需要加锁， 升级为轻量级锁。</p><p>所以线程不会主动的将偏向锁设置为匿名偏向状态，不会主动的去释放锁。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java输入输出流</title>
      <link href="/2022/06/05/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
      <url>/2022/06/05/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Java输入输出流"><a href="#Java输入输出流" class="headerlink" title="Java输入输出流"></a><em>Java</em>输入输出流</h1><hr> <h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>本文总结了上课<em>Java</em>老师的讲解，记录了一些经典的<em>java</em>用法</li><li>本文篇幅较长，没有耐心与兴趣的朋友勿入</li></ul><h3 id="I-x2F-O流的概念"><a href="#I-x2F-O流的概念" class="headerlink" title="I&#x2F;O流的概念"></a><em>I&#x2F;O</em>流的概念</h3><ul><li><h4 id="流（stream）"><a href="#流（stream）" class="headerlink" title="流（stream）"></a>流（<em>stream</em>）</h4></li></ul><p>  <em>Java</em>采用流的概念屏蔽了存储数据的起点和终点种类，文件、键盘、网络和其他设备都可以把它们抽象为流，通过流可以自由地控制文件、内存、<em>I&#x2F;O</em>设备等数据的流向</p><ul><li><h4 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h4><ul><li>根据<em>I&#x2F;O</em>流的流向可分为输入流（<em>inputstream</em>）和输出流（<em>outputsteam</em>）  </li><li>当程序<strong>读取</strong>数据时，开启了一个通向起点数据源的输入流，这个起点可以是文件、内存、网络连接。</li><li>当程序<strong>写入</strong>数据时，开启了一个通向目的地的输出流。</li></ul></li><li><h4 id="读写数据的方法基本遵循步骤"><a href="#读写数据的方法基本遵循步骤" class="headerlink" title="读写数据的方法基本遵循步骤"></a>读写数据的方法基本遵循步骤</h4><ol><li>打开一个流  （<em>I&#x2F;O</em>流一旦被创建后，就会<strong>自动打开</strong>）</li><li>读（写）信息  </li><li>关闭流</li></ol></li></ul><hr><h3 id="I-x2F-O流的种类"><a href="#I-x2F-O流的种类" class="headerlink" title="I&#x2F;O流的种类"></a><em>I&#x2F;O</em>流的种类</h3><ul><li><p>字节流（<em>byte oriented stream</em>）  </p><ul><li>字节流以8位的字节为基本处理单位 </li><li>字节流不能直接处理<em>Unicode</em>字符</li></ul></li><li><p>字符流（<em>byte oritented stream</em>)</p><ul><li>字符流以16位的字节为基本处理单位  </li><li>字符流处理的单元为16位的<em>Unicode</em>字符，由<em>Java</em>虚拟机将字节转化为16位的<em>Unicode</em>字符</li></ul></li></ul><hr>  <h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li>字节流</li></ul><ol><li>所有文件的存储都是字节（<em>byte</em>）的存储，因此字节流可用于<strong>任何类型</strong>的对象，如音频文件、图片、歌曲</li></ol><ul><li>字符流</li></ul><ol><li>处理多国语言，就得用字符流</li><li>字符流通常处理文本</li></ol><hr>  <h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><h3 id="一、文件File类"><a href="#一、文件File类" class="headerlink" title="一、文件File类"></a>一、文件File类</h3><ul><li><h4 id="文件类的方法"><a href="#文件类的方法" class="headerlink" title="文件类的方法"></a>文件类的方法</h4></li></ul><p>File 类是 java.io 包中唯一代表<strong>磁盘文件本身</strong>的对象，也就是说，如果希望在程序中操作文件和目录，则都可以通过 File 类来完成。</p><p>File 类定义了一些方法来操作文件，如新建、删除、重命名文件和目录等。File 类不能访问文件内容本身，如果需要访问文件内容本身，则需要使用输入&#x2F;输出流。</p><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>boolean canRead()</strong></td><td><strong>测试应用程序是否能从指定的文件中进行读取</strong></td></tr><tr><td><strong>boolean  canWrite()</strong></td><td><strong>测试应用程序是否能写当前文件</strong></td></tr><tr><td><strong>boolean delete()</strong></td><td><strong>删除当前对象指定的文件</strong></td></tr><tr><td><strong>boolean exists()</strong></td><td><strong>测试当前 File 是否存在</strong></td></tr><tr><td><strong>String  getAbsolutePath()</strong></td><td><strong>返回由该对象表示的文件的绝对路径名</strong></td></tr><tr><td><strong>String getName()</strong></td><td><strong>返回表示当前对象的文件名或路径名（如果是路径，则返回最后一级子路径名）</strong></td></tr><tr><td><strong>boolean</strong> <strong>createNewFile()</strong></td><td><strong>创建一个新的文件。</strong></td></tr><tr><td><strong>boolean  isAbsolute()</strong></td><td><strong>当前 File 对象表示的文件是否为一个绝对路径名。</strong></td></tr><tr><td><strong>boolean  isDirectory()</strong></td><td><strong>测试当前 File 对象表示的文件是否为一个路径</strong></td></tr><tr><td><strong>boolean isFile()</strong></td><td><strong>当前 File 对象表示的文件是否为一个“普通”文件</strong></td></tr><tr><td><strong>long  lastModified()</strong></td><td><strong>返回当前 File 对象表示的文件最后修改的时间</strong></td></tr><tr><td><strong>long length()</strong></td><td><strong>返回当前 File 对象表示的文件长度</strong></td></tr><tr><td><strong>String[] list()</strong></td><td><strong>返回当前 File 对象指定的路径文件列表</strong></td></tr><tr><td><strong>String[] list(FilenameFilter)</strong></td><td><strong>返回当前 File 对象指定的目录中满足指定过滤器的文件列表</strong></td></tr><tr><td><strong>boolean mkdir()</strong></td><td><strong>创建一个目录，它的路径名由当前 File 对象指定</strong></td></tr><tr><td><strong>boolean mkdirs()</strong></td><td><strong>创建一个目录，它的路径名由当前 File 对象指定</strong></td></tr><tr><td><strong>boolean  renameTo(File)</strong></td><td><strong>将当前 File 对象指定的文件更名为给定参数 File 指定的路径名</strong></td></tr></tbody></table><ul><li><h4 id="文件类举例"><a href="#文件类举例" class="headerlink" title="文件类举例"></a>文件类举例</h4></li></ul><p>（1）在磁盘上创建一个文件，先创建文件夹，再创建文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFileDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;d:&quot;</span>+File.separator+<span class="string">&quot;filetest&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filePath.exists()) &#123;</span><br><span class="line"></span><br><span class="line">      filePath.delete();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    filePath.mkdir();</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path+File.separator+<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line"></span><br><span class="line">      file.delete();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">      file.createNewFile();</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;创建文件成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">      e.printStackTrace();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）遍历一个文件夹</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListAllFile</span> &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;e://360Downloads&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line"></span><br><span class="line">    showAllFile(file);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showAllFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file.isDirectory()) &#123;<span class="comment">//如果是目录</span></span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;文件夹:&quot;</span> + file.getName());</span><br><span class="line"></span><br><span class="line">      File[] listFiles = file.listFiles();<span class="comment">//获取当前路径下的所有文件和目录,返回File对象数组</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (File f : listFiles) &#123;<span class="comment">//将目录内的内容对象化并遍历</span></span><br><span class="line"></span><br><span class="line">       showAllFile(f);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(file.isFile()) &#123;<span class="comment">//如果是文件</span></span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;文件:&quot;</span> + file.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、输入输出流"><a href="#二、输入输出流" class="headerlink" title="二、输入输出流"></a>二、输入输出流</h3><ul><li><h4 id="实例：用字节流把数据写入文件和读到内存中。"><a href="#实例：用字节流把数据写入文件和读到内存中。" class="headerlink" title="实例：用字节流把数据写入文件和读到内存中。"></a>实例：用字节流把数据写入文件和读到内存中。</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InptutAndOutDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String data=<span class="string">&quot;jiava计算机&quot;</span>;</span><br><span class="line">File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:&quot;</span>+File.separator+<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">writeDataToFile(file,data);</span><br><span class="line">readFromFile(file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFromFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">InputStream inputStream=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">flen</span> <span class="operator">=</span> (<span class="type">int</span>) file.length();</span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[flen];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             len = inputStream.read(b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e1)&#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">inputStream.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(len);</span><br><span class="line">        System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeDataToFile</span><span class="params">(File file, String data)</span>  &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">OutputStream outputStream=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">outputStream=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">outputStream.write(data.getBytes());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">outputStream.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三、字符输入输出流举例"><a href="#三、字符输入输出流举例" class="headerlink" title="三、字符输入输出流举例"></a>三、字符输入输出流举例</h3><p><strong>字符流只能操作文本文件，不能操作图片，视频等非文本文件（因为是二进制存储的，要用字节流）</strong></p><ul><li>字符输出流（Writer）</li></ul><p>public abstract class Writer是用于写出字符流的所有类的超类，是一个抽象类，它定义了字节输出流的基本共性能方法</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void write(int c)</td><td>写入单个字符</td></tr><tr><td>void write(char[] cbuf)</td><td>写入字符数组</td></tr><tr><td>abstract void write(char[] cbuf, int off, int len)</td><td>写入字符数组的某一部分</td></tr><tr><td>void write(String str)</td><td>写入字符串</td></tr><tr><td>void write(String str, int off, int len)</td><td>写入字符串的某一部分</td></tr><tr><td>void flush()</td><td>刷新该流的缓冲</td></tr></tbody></table><ul><li>FileWriter类是写字符到文件的类，构造时使用系统默认的字符编码和默认字节缓冲区。</li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>FileWriter(File file)</td><td>根据给定的 File 对象构造一个 FileWriter 对象</td></tr><tr><td>FileWriter(File file, boolean append)</td><td>根据给定的 File 对象构造一个 FileWriter 对象。其中append参数代表是否追加</td></tr><tr><td>FileWriter(String fileName)</td><td>根据给定的文件名构造一个 FileWriter 对象</td></tr><tr><td>FileWriter(String fileName, boolean append)</td><td>根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象</td></tr></tbody></table><hr><ul><li>字符输入流</li></ul><p>Reader 类是所有字符流输入类的父类，该类定义了许多方法，这些方法对所有子类都是有效的。</p><table><thead><tr><th><strong>方法名及返回值类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>int read()</td><td>从输入流中读取一个字符，并把它转换为 0~65535 的整数。如果返回 -1， 则表示   已经到了输入流的末尾。为了提高 I&#x2F;O 操作的效率，建议尽量使用下面两种 read()   方法</td></tr><tr><td>int read(char[] cbuf)</td><td>从输入流中读取若干个字符，并把它们保存到参数 cbuf 指定的字符数组中。 该方   法返回读取的字符数，如果返回 -1，则表示已经到了输入流的末尾</td></tr><tr><td>int read(char[] cbuf,int off,int len)</td><td>从输入流中读取若干个字符，并把它们保存到参数 cbuf 指定的字符数组中。其中，   off 指定在字符数组中开始保存数据的起始下标，len 指定读取的字符数。该方法返   回实际读取的字符数，如果返回 -1，则表示已经到了输入流的末尾</td></tr></tbody></table><p>Java 提供了用来读取字符文件的便捷类——FileReader。该类的构造方法有如下两种重载形式。</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>FileReader(File file)</td><td>在给定要读取数据的文件的情况下创建一个新的 FileReader 对象。其中，file 表示要从中读取数据的文件</td></tr><tr><td>FileReader(String fileName)</td><td>在给定从中读取数据的文件名的情况下创建一个新 FileReader 对象。其中，fileName 表示要从中读取数据的文件的名称，表示的是一个文件的完整路径</td></tr></tbody></table><p> 举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReaderAndWriterDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">String data=<span class="string">&quot;jiava计算机&quot;</span>;</span><br><span class="line">File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:&quot;</span>+File.separator+<span class="string">&quot;test1.txt&quot;</span>);</span><br><span class="line">Writer writer=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">true</span>);<span class="comment">//追加方式</span></span><br><span class="line">writer.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">writer.write(<span class="string">&quot;你好！\r\n&quot;</span>);</span><br><span class="line">writer.write(<span class="string">&quot;我在学习！\r\n&quot;</span>);</span><br><span class="line">writer.flush();</span><br><span class="line">writer.close();</span><br><span class="line"><span class="comment">//读数据</span></span><br><span class="line">Reader reader=<span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"><span class="type">int</span> len=(<span class="type">int</span>)file.length();</span><br><span class="line"><span class="type">char</span> myChar[]=<span class="keyword">new</span> <span class="title class_">char</span>[len];</span><br><span class="line"><span class="type">int</span> <span class="variable">rlen</span> <span class="operator">=</span> reader.read(myChar);</span><br><span class="line">    System.out.println(rlen);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(myChar));</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四、Java缓冲输入输出流"><a href="#四、Java缓冲输入输出流" class="headerlink" title="四、Java缓冲输入输出流"></a>四、Java缓冲输入输出流</h3><p>为什么要缓冲输入输出流？由于I&#x2F;O的速度和CPU的速度不匹配，导致文件的读取较慢。所以通过缓存，一次性将大量的数据刷入内存或者保存在本地上。提高文件的访问效率。</p><p>字节缓冲流： BufferedInputStream ， BufferedOutputStream</p><p>字符缓冲流： BufferedReader ， BufferedWriter</p><ul><li>字节缓冲流的使用（复制文件）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyFileByBuffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">File sourceFile=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span>+File.separator+<span class="string">&quot;filetest&quot;</span>+File.separator+<span class="string">&quot;xx.zip&quot;</span>);</span><br><span class="line">File targetFile=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span>+File.separator+<span class="string">&quot;movie&quot;</span>+File.separator+<span class="string">&quot;xx.zip&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">copyFileByBuffered(sourceFile,targetFile);</span><br><span class="line"><span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;缓冲流（默认缓冲区）复制时间:&quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileByBuffered</span><span class="params">(File sourceFile, File targetFile)</span> &#123;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourceFile),<span class="number">2048</span>);</span><br><span class="line">   BufferedOutputStream bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFile),<span class="number">2048</span>);</span><br><span class="line">   <span class="keyword">while</span>((b=bis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">   bos.write(b);</span><br><span class="line">   &#125;</span><br><span class="line">   bis.close();</span><br><span class="line">   bos.flush();</span><br><span class="line">   bos.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字节缓冲流的使用（高效复制文件）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyFileByBufferMore</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">File sourceFile=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span>+File.separator+<span class="string">&quot;filetest&quot;</span>+File.separator+<span class="string">&quot;xx.zip&quot;</span>);</span><br><span class="line">File targetFile=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span>+File.separator+<span class="string">&quot;movie&quot;</span>+File.separator+<span class="string">&quot;xx.zip&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">copyFileByBuffered(sourceFile,targetFile);</span><br><span class="line"><span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;缓冲流（默认缓冲区）复制时间:&quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileByBuffered</span><span class="params">(File sourceFile, File targetFile)</span> &#123;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">byte</span>[] bytes=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourceFile),<span class="number">2048</span>);</span><br><span class="line">   BufferedOutputStream bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFile),<span class="number">2048</span>);</span><br><span class="line">   <span class="keyword">while</span>((b=bis.read(bytes))!=-<span class="number">1</span>) &#123;</span><br><span class="line">   bos.write(bytes,<span class="number">0</span>,b);</span><br><span class="line">   &#125;</span><br><span class="line">   bis.close();</span><br><span class="line">   bos.flush();</span><br><span class="line">   bos.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用字符缓冲流逐行读取文件。创建Student类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadFileByBuffered</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">   List&lt;Student&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">       File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span>+File.separator+<span class="string">&quot;filetest&quot;</span>+File.separator+<span class="string">&quot;score.txt&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">BufferedReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">br.readLine();</span><br><span class="line">String score[]=<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">score=line.split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">Student st=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;score.length;i++) &#123;</span><br><span class="line">st.setId(score[<span class="number">0</span>]);</span><br><span class="line">st.setName(score[<span class="number">1</span>]);</span><br><span class="line">st.setMath(Integer.parseInt(score[<span class="number">2</span>]));</span><br><span class="line">st.setChinese(Integer.parseInt(score[<span class="number">3</span>]));</span><br><span class="line">st.setEnglish(Integer.parseInt(score[<span class="number">4</span>]));</span><br><span class="line">st.setTotal(st.getMath()+st.getChinese()+st.getEnglish());</span><br><span class="line">st.setAverage(st.getTotal()/<span class="number">3.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line">list.add(st);</span><br><span class="line">&#125;</span><br><span class="line">br.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">       <span class="keyword">for</span>(Student st:list) &#123;</span><br><span class="line">       System.out.println(st.getId()+<span class="string">&quot; &quot;</span>+<span class="string">&quot;\t&quot;</span>+st.getName());</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、对象序列化与对象输入输出流"><a href="#五、对象序列化与对象输入输出流" class="headerlink" title="五、对象序列化与对象输入输出流"></a>五、对象序列化与对象输入输出流</h3><p>Java中要实现将对象保存起来持久化，需要让对象实现<strong>Serializable接口</strong>，这样就能将java对象用二进制流保存并恢复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaveObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">File fileName=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\filetest\\obj.txt&quot;</span>) ;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ObjectOutputStream oos=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(fileName));</span><br><span class="line">User user=<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">oos.writeObject(user);</span><br><span class="line"> oos.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//读取对象流</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ObjectInputStream ois=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">User user1=(User)ois.readObject();</span><br><span class="line">System.out.println(user1.toString());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、RandomAccessFile-类"><a href="#六、RandomAccessFile-类" class="headerlink" title="六、RandomAccessFile 类"></a>六、RandomAccessFile 类</h2><p>RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来<strong>读、写文件。支持文件追加。</strong>RandomAccessFile 类支持字节和字符流。</p><table><thead><tr><th><strong>方法</strong></th><th><strong>功能描述</strong></th></tr></thead><tbody><tr><td>long length()</td><td>返回文件长度</td></tr><tr><td>void seek(long  pos)</td><td>移动文件位置指示器，pos 指定从文件开头的偏离字节数</td></tr><tr><td>int skipBytes(int  n)</td><td>跳过 n 个字节，返回数为实际跳过的字节数</td></tr><tr><td>int read()</td><td>从文件中读取一个字节，字节的高 24 位为 0，若遇到文件结尾，返回-1</td></tr><tr><td>final byte readByte()</td><td>从文件中读取带符号的字节值</td></tr><tr><td>final char readChar()</td><td>从文件中读取一个 Unicode 字符</td></tr><tr><td>final void writeChar(inte c)</td><td>写入一个字符，两个字节</td></tr><tr><td>final void writeBytes（String s）</td><td>写入个字符串</td></tr></tbody></table><p>实例<em>RandomAccessFile</em>读写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">RandomAccessFile raf=<span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">String line=<span class="literal">null</span>;</span><br><span class="line">raf.seek(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>((line=raf.readLine())!= <span class="literal">null</span>)&#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(line.getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>),<span class="string">&quot;gb2312&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">raf.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">RandomAccessFile raf=<span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">long</span> len=raf.length();</span><br><span class="line">raf.seek(len);<span class="comment">//在文件尾部写行</span></span><br><span class="line">raf.write((<span class="string">&quot;中午&quot;</span>+<span class="string">&quot;\r\n&quot;</span>).getBytes());;</span><br><span class="line">raf.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">RandomAccessFile so=<span class="literal">null</span>;</span><br><span class="line">RandomAccessFile ta=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">so=<span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;src\\myfile\\360qudong.exe&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">ta=<span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;src\\myfile\\360qudong1.exe&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">byte</span> b[]=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=so.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">ta.write(b,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;0k&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ta!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ta.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(so!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">so.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="七、URL对象与输入输出流"><a href="#七、URL对象与输入输出流" class="headerlink" title="七、URL对象与输入输出流"></a>七、URL对象与输入输出流</h3><p>URL全称是“统一资源定位”，表示的是网络上的某个文件。Java中URL类是用来操作网络中的资源文件。</p><ul><li>URL类的构造方法：</li></ul><table><thead><tr><th>序号</th><th><strong>方法描述</strong></th></tr></thead><tbody><tr><td>1</td><td><strong>public URL(String protocol, String host, int port,  String file) throws MalformedURLException.</strong>   通过给定的参数(协议、主机名、端口号、文件名)创建URL。</td></tr><tr><td>2</td><td><strong>public URL(String protocol, String host, String file)  throws MalformedURLException</strong>   使用指定的协议、主机名、文件名创建URL，端口使用协议的默认端口。</td></tr><tr><td>3</td><td><strong>public URL(String url) throws MalformedURLException</strong>   通过给定的URL字符串创建URL</td></tr><tr><td>4</td><td><strong>public URL(URL context, String url) throws  MalformedURLException</strong>   使用基地址和相对URL创建</td></tr></tbody></table><ul><li>URL类的方法</li></ul><p>​URL类的方法很多，这里介绍<strong>openConnection()方法：</strong></p><p>​public URLConnection openConnection() throws IOException:    打开一个URL连接，并返回一个HttpURLConnection对象。</p><ul><li>HttpURLConnection对象的方法</li></ul><p>​public InputStream getInputStream() throws IOException：返回URL的输入流，用于读取资源。</p><p>实例：程序下载网页中的图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">saveImage(<span class="string">&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveImage</span><span class="params">(String str)</span> &#123;</span><br><span class="line">URL url=<span class="literal">null</span>;</span><br><span class="line">HttpURLConnection conn=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">url=<span class="keyword">new</span> <span class="title class_">URL</span>(str);</span><br><span class="line">conn=(HttpURLConnection)url.openConnection();</span><br><span class="line">conn.connect();</span><br><span class="line">BufferedInputStream bis=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(conn.getInputStream());</span><br><span class="line">BufferedOutputStream bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\ddd.png&quot;</span>));</span><br><span class="line"><span class="type">byte</span> bt[]=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="keyword">while</span>((size=bis.read(bt))!=-<span class="number">1</span>) &#123;</span><br><span class="line">bos.write(bt,<span class="number">0</span>,size);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;finsh&quot;</span>);</span><br><span class="line">bos.flush();</span><br><span class="line">bos.close();</span><br><span class="line">bis.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法的运用</title>
      <link href="/2022/06/03/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E8%BF%90%E7%94%A8/"/>
      <url>/2022/06/03/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E8%BF%90%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="二分法的运用"><a href="#二分法的运用" class="headerlink" title="二分法的运用"></a>二分法的运用</h1><h4 id="二分法使用基本条件："><a href="#二分法使用基本条件：" class="headerlink" title="二分法使用基本条件："></a>二分法使用基本条件：</h4><p><strong>有序整数</strong>数组</p><p>通过<strong>循环</strong>，不断更新<strong>左边界</strong>（<em>LeftBorder</em>)与<strong>右边界</strong>(<em>RightBorder</em>)达到你需要的目的</p><ul><li><h4 id="二分法用于查询有序数组的某一个元素，若有，则返回序号，无，则返回-1"><a href="#二分法用于查询有序数组的某一个元素，若有，则返回序号，无，则返回-1" class="headerlink" title="二分法用于查询有序数组的某一个元素，若有，则返回序号，无，则返回-1"></a>二分法用于查询有序数组的某一个元素，若有，则返回序号，无，则返回-1</h4><p>​ 相关题目：给定一个 n 个元素的升序整型数组 nums 和一个目标值 target,写一个函数搜索 nums 中的 target,如果目标值存在则返回下标，否则返回-1</p><p>示例 1：</p><p>输入：nums &#x3D; [-1,0,3,5,9,12], target&#x3D;9</p><p>输出：4</p><p>解释：9 出现在 nums 中因此返回-1</p><p>示例 2：</p><p>输入：nums&#x3D;[-1,0,3,5,9,12], target&#x3D;2</p><p>输出：-1</p><p>解释：2 在 nums 中不存在，因此返回-1</p><ul><li><p>提示：</p><p>[^1.]: 你可以假设 nums 中的所有元素是不重复出现的。<br>[^2.]: n 将在[1,10000]之间<br>[^3.]: nums 中的每个元素都将在[-9999,9999]之间</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心代码模式</span></span><br><span class="line"><span class="comment">// Java版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 左边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;<span class="comment">// 右边界</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;<span class="comment">// 采用左闭右闭[]</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + (right -left)/<span class="number">2</span>;<span class="comment">// 求中位数的序号</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;<span class="comment">// 说明此时target在数组的左侧</span></span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[middle] == target) &#123;<span class="comment">// 如果相等，说明找到了target</span></span><br><span class="line">                    <span class="keyword">return</span> middle;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;<span class="comment">// 说明此时target在数组的右侧</span></span><br><span class="line">                    left = middle + <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">1</span><span class="comment">// 跳出while循环还没找到，说明没有！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><em>kotlin</em>版本</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">search</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = nums.size - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">var</span> middle = left + (right - left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[middle] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> middle</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = middle + <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2022/06/02/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/06/02/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-命令及-shell-编程浅谈"><a href="#Linux-命令及-shell-编程浅谈" class="headerlink" title="Linux 命令及 shell 编程浅谈"></a>Linux 命令及 shell 编程浅谈</h1><ul><li><h3 id="Linux文件系统结构"><a href="#Linux文件系统结构" class="headerlink" title="Linux文件系统结构"></a><em>Linux</em>文件系统结构</h3></li></ul><p><img src="/postImage/image-20220515190158467.png" alt="image-20220515190158467"></p><ul><li><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ul><li>*匹配<strong>任何字符</strong>或<strong>任何数目</strong>的字符</li><li>？匹配任何单字符</li><li>[…] 匹配任何包含在括号里的单字符</li><li>目录表示：. 指示当前目录，.. 表示当前目录的父目录</li></ul></li><li><h3 id="启动退出命令"><a href="#启动退出命令" class="headerlink" title="启动退出命令"></a>启动退出命令</h3><ul><li><em>logout</em> 注销</li><li><em>exit</em> 退出</li><li><em>reboot</em> 重启系统（需要管理员权限）</li><li><em>shutdown</em> 关机 （需要管理员权限 ）</li></ul></li><li><h3 id="目录操作命令"><a href="#目录操作命令" class="headerlink" title="目录操作命令"></a>目录操作命令</h3><ul><li><em>pwd</em> 显示出用户当前工作目录的全部路径(<em>print working directory</em>)</li><li><em>mkdir directory_name</em> 创建新目录(<em>make directory</em>)</li><li><em>cd directory_name</em> 改变当前工作目录</li><li><em>rmdir directory_name</em> 删除目录，但要求目录中<strong>不存在文件或子目录</strong></li></ul></li><li><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><em>ls [-a&#x2F;-R&#x2F;-l&#x2F;-lc&#x2F;-lu] [dir_name]</em> 显示目录命令</li></ul></li><li><p><em>cat filename</em> 显示出文件内容</p><ul><li><em>view filename</em> 只能读出文件内容</li></ul></li><li><p><em>head [-i] filename</em> 显示文件的<strong>开始 i 行</strong></p><ul><li><em>tail [-i] filename</em> 显示文件的<strong>末 i 行</strong></li></ul></li><li><p><em>pr filename</em> 显示格式化的文本内容(<em>print</em>)</p><ul><li><em>cp source_file target_file</em> 复制文件（新的文件可以同名）</li></ul></li><li><p><em>rm -i&#x2F;r&#x2F;f file_or_dir</em> 删除文件 (i 互动删除，删除前再确认一次，r 递归删除，强制删除)</p><ul><li><em>chmod pattern filename</em> 修改文件权限</li></ul></li><li><p><em>find pathname [option] expression</em> 寻找文件名</p><ul><li><em>diff filename1 filename2</em> 比较来两个文件的不同</li></ul></li><li><p><em>touch filename</em> 改变文件日期，不对文件内容改动，若文件不存在则创建新文件</p><ul><li><em>date</em> 显示或设置日期（只有 root 用户才有权设置日期）</li></ul></li><li><p><em>cal</em> [month] year 显示某年指定的日历</p><ul><li><em>time</em> [command] 计算程序或命令在其执行所消耗的时间</li></ul></li><li><p><em>history</em> 帮助用户回忆执行过的命令</p><ul><li><em>man [command_name]</em> 显示参考手册，提供联机帮助信息</li></ul></li><li><p><em>echo [-n] [arguments]</em> 将参数即字符串至标准输出即显示器</p></li><li><p>简单实例一</p><ol><li><p>设定变量 file 的值为*&#x2F;etc&#x2F;passwd*</p></li><li><p>使用循环变量读取文件*&#x2F;etc&#x2F;passwd*的第 2，4，6，10，13，15 行，并显示其内容</p></li><li><p>把这些行保存至&#x2F;tmp&#x2F;mypasswd 文件中</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">file=&quot;/etc/passwd&quot;       # 务必使用“”</span><br><span class="line">for i in 2 4 6 10 13 15</span><br><span class="line">do</span><br><span class="line">        head -$i $file   # 务必使用 $</span><br><span class="line">        head -$i $file&gt;&quot;/tmp/mypasswd&quot;</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>简单实例二</p><ol><li><p>传递两个整数给脚本，让脚本分别计算并显示这两个整数的和，差，积，商。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!bin/bash</span></span><br><span class="line">a=$1      # 执行脚本是应为 sh filename argument1 argument2</span><br><span class="line">b=$2</span><br><span class="line">var1=`expr $a + $b`   # 务必注意运算符与参数之间的空格</span><br><span class="line">var2=`expr $a - $b`</span><br><span class="line">var3=`expr $a \* $b`  # 注意 \*</span><br><span class="line">var4=`expr $a / $b`</span><br><span class="line">echo &quot;a+b=$var1&quot;</span><br><span class="line">echo &quot;a-b=$var2&quot;</span><br><span class="line">echo &quot;a*b=$var3&quot;</span><br><span class="line">echo &quot;a/b=$var4&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>简单实例三</p><ol><li><p>显示系统日期和时间，而后创建目录&#x2F;tmp&#x2F;lstest</p></li><li><p>切换工作目录至&#x2F;tmp&#x2F;lstest</p></li><li><p>创建目录 a1d,b56e,6test</p></li><li><p>创建空文件 xy,x2y,732</p></li><li><p>列出当前目录下以 a，x 或者 6 开头的文件或目录</p></li><li><p>列出当前目录下以字母开头，后跟一个任意数字，而后跟任意长度字符的文件或目录</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">date</span><br><span class="line">mkdir /tmp/lstest</span><br><span class="line">cd /tmp/lstest</span><br><span class="line">mkdir a1d b56e 6test  # 注意空格</span><br><span class="line">touch xy x2y 732      # 注意空格</span><br><span class="line">ls [ax6]*             # 注意正则表达式的运用</span><br><span class="line">ls [[:alpha:]][[:digit:]]*   # 注意[]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>简单实例四</p><ol><li><p>编写一个名为<em>myfirstshell.sh</em>的脚本</p></li><li><p>包含一段注释，列出您的姓名、脚本的名称和编写这个脚本的目的</p></li><li><p>问候用户</p></li><li><p>显示日期和时间</p></li><li><p>显示这个月的日历</p></li><li><p>显示您的机器名</p></li><li><p>显示当前这个操作系统的名称和版本</p></li><li><p>显示父目录中的所有文件的列表</p></li><li><p>显示<em>root</em>正在运行的所有进程</p></li><li><p>显示变量<em>TERM、PATH</em>和<em>HOME</em>的值</p></li><li><p>显示磁盘使用情况</p></li><li><p>用 id 命令打印出您的组 ID</p></li><li><p>跟用户说<em>“Good bye”</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">author:@Ezralin</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">name:myfirstshell</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pourpose: to improve myself</span></span><br><span class="line">user=`whoami`</span><br><span class="line">case $user in</span><br><span class="line">    root)</span><br><span class="line">        echo &quot;hello root&quot;;;</span><br><span class="line">    Ezralin)</span><br><span class="line">        echo &quot;hello Bin&quot;;;</span><br><span class="line">    *)</span><br><span class="line">        echo &quot;hello $user,welcome&quot;</span><br><span class="line">esac</span><br><span class="line">echo &quot;日期和时间：`date`&quot;</span><br><span class="line">echo &quot;本月的日历：`cal`&quot;</span><br><span class="line">echo &quot;本机的机器猫：`uname -n`&quot;</span><br><span class="line">echo &quot;当前这个操作系统的名称和版本：`uname -s;uname -r`&quot;</span><br><span class="line">echo &quot;父目录中的所有文件的列表：`ls ../`&quot;</span><br><span class="line">echo &quot;root正在运行的所有程序：`ps -u root`&quot;</span><br><span class="line">echo &quot;变量TERM的值：$TERM&quot;</span><br><span class="line">echo &quot;变量PATH的值：$PATH&quot;</span><br><span class="line">echo &quot;变量HOME的值：$HOME&quot;</span><br><span class="line">echo &quot;磁盘的使用情况：`df`&quot;</span><br><span class="line">echo &quot;用id命令打印出你的组ID：`id -g`&quot;</span><br><span class="line">echo &quot;Good bye!&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java与kotlin对比学习</title>
      <link href="/2022/06/02/java%E4%B8%8Ekotlin%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/06/02/java%E4%B8%8Ekotlin%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Java与kotlin对比学习一"><a href="#Java与kotlin对比学习一" class="headerlink" title="Java与kotlin对比学习一"></a><em>Java</em>与<em>kotlin</em>对比学习一</h1><ul><li><h3 id="构造函数、声明属性对比"><a href="#构造函数、声明属性对比" class="headerlink" title="构造函数、声明属性对比"></a>构造函数、声明属性对比</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Java</em>的构造函数非常直接，类型修饰符+类名+()，若有属性，则再（）中加入参数，与 C++语言有异曲同工之妙，而<em>Kotlin</em>胜在**精简 **</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span> </span>(aName: String, aAge: <span class="built_in">Int</span>) &#123;  <span class="comment">// 临时定义变量保存外部传过来的值</span></span><br><span class="line">    <span class="keyword">var</span> name: String = aName   <span class="comment">// aName, aAge是临时的，真正定义并完成初始化操作</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或在初始化块中调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span> </span>(aName: String, aAge: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        name = aName</span><br><span class="line">        age = aAge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>kotlin</em>还可以直接在<em>constructor</em>内部<strong>直接</strong>声明属性，与<em>Java</em>相比<strong>更加精简</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span> </span>(<span class="keyword">private</span> <span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123; <span class="comment">// 在主构造函数中直接声明属性</span></span><br><span class="line">    <span class="keyword">var</span> score = <span class="number">99</span>  <span class="comment">// 需要在创建对象时给予初始值的属性才放到主构造函数中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="定义函数对比"><a href="#定义函数对比" class="headerlink" title="定义函数对比"></a>定义函数对比</h3><ul><li><p>无参无返回值的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;  <span class="comment">// java</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun test(): Unit &#123;&#125;   // Kotlin</span><br></pre></td></tr></table></figure></li><li><p>有参无返回值的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;&#125;   <span class="comment">// java</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Unit</span>&#123;&#125;   <span class="comment">// kotlin</span></span><br></pre></td></tr></table></figure></li><li><p>有参有返回值的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;                  <span class="comment">// java</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b    <span class="comment">// kotlin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果函数只有一行，也可写为下述形式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = a + b</span><br><span class="line"><span class="comment">// 甚至返回值类型也可省略</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码运行深层原理</title>
      <link href="/2022/06/02/Java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E6%B7%B1%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2022/06/02/Java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E6%B7%B1%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM-浅谈"><a href="#JVM-浅谈" class="headerlink" title="JVM 浅谈"></a>JVM 浅谈</h1><ul><li><h3 id="Java-构造对象浅谈"><a href="#Java-构造对象浅谈" class="headerlink" title="Java 构造对象浅谈"></a>Java 构造对象浅谈</h3><p>​ 在日常编程中，我们不假思索地使用<em>new</em>去新建一个对象，但 <em>Java</em>是如何在底层进行对象的创建？如何在底层完成对象的创建并进行初始化？下面我们来探讨以下这个问题：</p><p><code><em>Animal animal=new Animal()</em></code></p><p>上行代码是对象实例化的过程，在程序中执行这行代码，将会经历以下过程：</p><ol><li><p>在<strong>方法区</strong>寻找 Animal 类的信息</p></li><li><p><strong>判断</strong> <em>Java</em>编译后的字节码里面是否有这个<em>Animal</em>类，如果没有，则类加载器会将当前这个类的<strong>字节码文件</strong>加载到文件中</p></li><li><p><code>new Animal()</code>创建对象时，对象在<strong>堆</strong>（_heap_）里面被分配内存空间</p></li><li><p>该被创建的对象在<strong>堆</strong>中的<strong>地址</strong>会被压入<strong>操作数栈</strong></p></li><li><p>在当前<strong>线程栈</strong>的方法栈帧的<strong>局部变量区域</strong>申请内存空间给<em>animal</em></p></li><li><p>从操作数帧中弹出顶部操作数（就是被创建对象在<strong>堆</strong>中的<strong>地址</strong>）赋值给<em>animal</em>，从而使<em>animal</em> <strong>指向</strong>新建的<em>Animal</em>对象</p></li></ol><hr></li><li><h3 id="JVM-理解"><a href="#JVM-理解" class="headerlink" title="JVM 理解"></a>JVM 理解</h3><p>我们将从下面这个简单的代码的<strong>反编译</strong>的*.class<em>文件，深度理解</em>Java*是如何在内存中被执行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPerson</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doSomething</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> a= <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (a+b)*<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TestPerson testPerson=<span class="keyword">new</span> <span class="title class_">TestPerson</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> testPerson.doSomething();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上述代码的class反编译文件"><a href="#上述代码的class反编译文件" class="headerlink" title=".上述代码的class反编译文件"></a>.上述代码的<em>class</em>反编译文件</h4><p>我们对一些可以<strong>见名知意</strong>的名词不做过多解释，不清楚的大家可以在简书中搜索，<strong>此处</strong>主要还是<strong>加深</strong>大家对代码的<strong>理解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;JVM_03.TestPerson.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVM_03</span>.TestPerson &#123;</span><br><span class="line">  <span class="keyword">public</span> JVM_03.TestPerson();               <span class="comment">// 这是默认构造函数</span></span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_1      <span class="comment">// 把常量1压入操作数栈</span></span><br><span class="line">       <span class="number">1</span>: istore_1      <span class="comment">// 从操作数栈中弹出刚刚入栈的常量1</span></span><br><span class="line">                        <span class="comment">// 并把它赋值给局部变量表中索引为1的变量</span></span><br><span class="line">                        <span class="comment">// 即赋值给a  (对应代码：int a=1)</span></span><br><span class="line">       <span class="number">2</span>: iconst_2</span><br><span class="line">       <span class="number">3</span>: istore_2            <span class="comment">// 同上</span></span><br><span class="line">       <span class="number">4</span>: iload_1             <span class="comment">// 将局部变量表中下标为1的int变量压入操作数栈</span></span><br><span class="line">       <span class="number">5</span>: iload_2             <span class="comment">// 同上</span></span><br><span class="line">       <span class="number">6</span>: iadd                <span class="comment">// 在操作数栈中完成两数相加</span></span><br><span class="line">       <span class="number">7</span>: iconst_5            <span class="comment">// 将常量5压入操作数栈</span></span><br><span class="line">       <span class="number">8</span>: imul                <span class="comment">//在操作数栈中完成乘法运算</span></span><br><span class="line">       <span class="number">9</span>: istore_3            <span class="comment">//弹出运算结果并且赋值给局部变量表中索引为3的变量</span></span><br><span class="line">      <span class="number">10</span>: iload_3</span><br><span class="line">      <span class="number">11</span>: ireturn             <span class="comment">// 返回int类型的值 (ireturn 语句中 i就表示int)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class JVM_03.TestPerson</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: aload_1</span><br><span class="line">       <span class="number">9</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method doSomething:()I</span></span><br><span class="line">      <span class="number">12</span>: istore_2</span><br><span class="line">      <span class="number">13</span>: getstatic     #<span class="number">5</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">16</span>: iload_2</span><br><span class="line">      <span class="number">17</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">      <span class="number">20</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​ 下面我们再挖深一些，进一步揭开 JVM 的面纱：</p><p>​ 我们先了解一下<em>Java</em>的<strong>运行时数据区</strong>(<em>Runtime Date Area</em>)，<em>Java</em>程序被运行时，内存中运行时数据区会被分为五部分，见下图。</p><p>​ <em>Java</em>程序运行是按线程来操作的，在线程栈中运行多个线程。每一个<strong>线程</strong>都有一个自己的<strong>栈帧</strong>，而每一个栈帧又包含局部变量、操作数栈、动态链接、方法出口四部分。上述就是在 main 线程里面的栈帧进行的。这里还要讲解一下，<strong>函数出口记录</strong>的问题。</p><p>​ 就上述<em>Java</em>代码而言，显然，程序需要从 main 函数进入<em>doSomething</em>函数，再返回 main 函数，为了不迷路，<em>Java</em>采用”<strong>标记</strong>“的方法记录出口，上述的*.class<em>文件中的#2 等等就是”标记“。当<code>new</code>一个新的对象时上述代码调用了默认构造函数，此时就需要进入该构造函数，</em>Java<em>离开 main 函数留下”标记“，java 进入函数时又留下”标记“，如此，进入不同函数，它就知道运行时如何返回</em>main*函数了。</p><ul><li><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><img src="/postImage/img-1.jpg" /></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型与Kotlin高阶语法糖</title>
      <link href="/2022/06/02/Java%E6%B3%9B%E5%9E%8B%E4%B8%8EKotlin%E9%AB%98%E9%98%B6%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
      <url>/2022/06/02/Java%E6%B3%9B%E5%9E%8B%E4%B8%8EKotlin%E9%AB%98%E9%98%B6%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Java泛型与Kotlin高阶函数语法糖"><a href="#Java泛型与Kotlin高阶函数语法糖" class="headerlink" title="Java泛型与Kotlin高阶函数语法糖"></a><em>Java</em>泛型与<em>Kotlin</em>高阶函数语法糖</h1><ul><li><h3 id="java泛型"><a href="#java泛型" class="headerlink" title="java泛型"></a><em>java</em>泛型</h3><ol><li><p>什么是泛型？ 泛指<strong>一切类型</strong></p><p> 常使用 <em>T</em> <em>R</em> <em>V</em> <em>K</em> <em>I</em> <em>O</em> 表示</p></li><li><p>协变与形变</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        List&lt;String&gt; b = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        a = b; <span class="comment">// 报错,为什么,a 需要 List&lt;Objects&gt;类型，而b 为List&lt;String&gt;类型</span></span><br><span class="line">        *****************</span><br><span class="line">        <span class="comment">// 此时需要使用协变</span></span><br><span class="line">        父类接收子类 协变 ? <span class="keyword">extends</span></span><br><span class="line">        <span class="title class_">List</span>&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// ? 为占位符，表示一个继承于Object的子类</span></span><br><span class="line">        List&lt;String&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        c = d;<span class="comment">// 正确!!!</span></span><br><span class="line">        *****************</span><br><span class="line">        List&lt;Object&gt; e = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        List&lt;String&gt; f = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        f = e;<span class="comment">// 报错，f需要List&lt;Object&gt;类型，而e为List&lt;String&gt;类型，类型不匹配</span></span><br><span class="line">        *****************</span><br><span class="line">        <span class="comment">// 此时需要使用形变</span></span><br><span class="line">        子类接收父类 形变 ? <span class="built_in">super</span></span><br><span class="line">        List&lt;Object&gt; g = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        List&lt;? <span class="built_in">super</span> String&gt; h = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        h = g;<span class="comment">// 正确！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>java</em>泛型类的使用</p><p> 注意：泛型类中的方法只是使用了泛型类类型作为参数的函数，不是泛型函数</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类</span></span><br><span class="line"><span class="comment">// T type</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bag</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T getValue &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// main</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 前面&lt;&gt; 和 后面&lt;&gt; 必须指定一处类型</span></span><br><span class="line">        Bag&lt;String&gt; schoolBag = <span class="keyword">new</span> <span class="title class_">Bag</span>&lt;&gt;();</span><br><span class="line">        schoolBag.setValue(<span class="string">&quot;语文书&quot;</span>);</span><br><span class="line">        System.out.println(schoolBag.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><h3 id="kotlin泛型类的使用"><a href="#kotlin泛型类的使用" class="headerlink" title="kotlin泛型类的使用"></a><em>kotlin</em>泛型类的使用</h3><ol><li><p><em>kotlin</em>泛型类的使用</p><p> <em>kotlin</em>: <em>out</em> 这个类型只能作为返回值 输出 生产</p><p> <em>kotln</em>: <em>in</em>只能作为参数 接受 消费</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bag</span>&lt;<span class="type">in I,out O</span>&gt;</span>(<span class="keyword">var</span> value: <span class="meta">@UnsafeVariance</span> I,<span class="keyword">var</span> result: <span class="meta">@UnsafeVariance</span> O) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(v1: <span class="type">I</span>)</span></span> &#123;</span><br><span class="line">        value = v1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">()</span></span>: O &#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><h3 id="Kotlin泛型函数的使用"><a href="#Kotlin泛型函数的使用" class="headerlink" title="Kotlin泛型函数的使用"></a><em>Kotlin</em>泛型函数的使用</h3><p>何为泛型函数？不确定参数或者返回值类型的函数就是泛型函数</p><ol><li><p>仅有一个泛型</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">test</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">test1</span><span class="params">()</span></span>: T &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">test2</span><span class="params">(v1: <span class="type">T</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>放回值和参数类型均需要自己指定</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T,R&gt;</span> <span class="title">test</span><span class="params">(v1: <span class="type">T</span>, v2: <span class="type">T</span>)</span></span>: R? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><h3 id="Kotlin高阶函数分析"><a href="#Kotlin高阶函数分析" class="headerlink" title="Kotlin高阶函数分析"></a><em>Kotlin</em>高阶函数分析</h3><ol><li><p>何为<strong>高阶函数</strong>与为什么需要使用**<em>inline</em>**?</p><p> 高阶函数是将<strong>函数</strong>用作<strong>参数或返回值</strong>的函数，实际开发过程中<strong>一般所有</strong>高阶函数都必须使用**<em>inline</em><strong>修饰，使之成为</strong>内联函数<strong>。不使用<em>inline</em>修饰高阶函数时，使用此类<a href="https://www.kotlincn.net/docs/reference/lambdas.html">高阶函数</a>会带来一些运行时的效率损失，因为编译时，每一个函数都是一个</strong>对象<strong>，</strong>内存分配<strong>（对于函数对象和类）和</strong>虚拟调用<strong>会引入</strong>运行时间开销<strong>，</strong>降低效率<strong>。当<em>inline</em>修饰了高阶函数时，此时编译时程序只是做了一个</strong>展开&#x2F;替换*<em>（类似于 C 语言的宏定义），所以在许多情况下我们通过使用</em>inline*内联化 lambda 表达式来消除这类的开销。</p></li><li><p>**<em>lambda</em>**表达式分析</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">show1</span><span class="params">(lambda: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// lamba表达式为String类型的形参，没有返回值</span></span><br><span class="line">    <span class="comment">// lambda 表达式里面是 it</span></span><br><span class="line">    lambda(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">show2</span><span class="params">(lambda: <span class="type">String</span>.() -&gt; <span class="type">Unit</span> )</span></span> &#123;</span><br><span class="line">    <span class="comment">// lambda 表达式里面是 this</span></span><br><span class="line">    <span class="keyword">this</span>.lambda()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="string">&quot;jack&quot;</span>.show1&#123;</span><br><span class="line">        println(<span class="string">&quot;hello <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">&quot;Merry&quot;</span>.show2&#123;</span><br><span class="line">        println(<span class="string">&quot;hello <span class="variable">$this</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>lambda</em>与泛型的综合运用</p><ul><li>给任意一个类型添加一个扩展函数，lambda 中使用 it 访问这个对象</li></ul> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">show1</span><span class="params">(lambda: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    lambda(<span class="keyword">this</span>) <span class="comment">// 在这个函数中this指代的是调用这个扩展函数类型为T的对象,并把它作为参数传递给lambda，</span></span><br><span class="line">    <span class="comment">//在lambda中使用it访问这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>给任意一个类型添加一个扩展函数，lambda 中使用 this 访问这个对象</li></ul> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">show2</span><span class="params">(lambda: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.lambda() <span class="comment">// this指代是调用这个扩展函数类型为T的对象，再将其作为调用lambda的对象</span></span><br><span class="line">     <span class="comment">// 在lambda中使用this访问这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>给任意一个类型添加一个扩展函数,并将这个对象传递给 lambda 表达式,lambda 返回值的类型由 lambda 最后一行的结果决定</li></ul> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T,R&gt;</span> T.<span class="title">show3</span><span class="params">(lambda: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">val</span> result = lambda(<span class="keyword">this</span>)</span><br><span class="line">println(result!!::<span class="keyword">class</span>.java.name)</span><br><span class="line"><span class="comment">// 上行可以打印出lambda表达式最后一行结果的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>运行效果如下</li></ul></li></ul><p>​ <img src="/postImage/image-20220529173006301.png" alt="image-20220529173006301"><img src="/postImage/image-20220529173058283.png" alt="image-20220529173058283"></p><ul><li><h3 id="Kotlin语法糖分析"><a href="#Kotlin语法糖分析" class="headerlink" title="Kotlin语法糖分析"></a><em>Kotlin</em>语法糖分析</h3><ul><li><p><em>apply</em>分析</p><p><em>apply</em>作用：使用 apply 可以进行初始化操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">myApply</span><span class="params">(lambda: <span class="type">T</span>.() -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">this</span>.lambda()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>also 分析</p><p><em>also</em>作用：使用 also 可以完成同时性的操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">myAlso</span><span class="params">(lambda: (<span class="type">T</span>) -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    lambda(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>run 分析</p><p><em>run</em>作用：使用 run 可以执行一段代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">myRun</span><span class="params">(lambda: () -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line"><span class="keyword">return</span> lambda()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T,R&gt;</span> T.<span class="title">myRun</span><span class="params">(lambda: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.lambda()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>with 分析</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T,R&gt;</span> <span class="title">myWith</span><span class="params">(value: <span class="type">T</span>,lambda: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">return</span> value.lambda()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>forEach 分析</p><p><em>forEach</em>作用：使用 forEach 可以遍历完成相关的操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">myForEach</span><span class="params">(lambda: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">lambda(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
