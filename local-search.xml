<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java代码运行深层原理</title>
    <link href="/2022/06/02/Java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E6%B7%B1%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <url>/2022/06/02/Java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E6%B7%B1%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM-浅谈"><a href="#JVM-浅谈" class="headerlink" title="JVM 浅谈"></a>JVM 浅谈</h1><ul><li><h3 id="Java-构造对象浅谈"><a href="#Java-构造对象浅谈" class="headerlink" title="Java 构造对象浅谈"></a>Java 构造对象浅谈</h3><p>​ 在日常编程中，我们不假思索地使用<em>new</em>去新建一个对象，但 <em>Java</em>是如何在底层进行对象的创建？如何在底层完成对象的创建并进行初始化？下面我们来探讨以下这个问题：</p><p><code><em>Animal animal=new Animal()</em></code></p><p>上行代码是对象实例化的过程，在程序中执行这行代码，将会经历以下过程：</p><ol><li><p>在<strong>方法区</strong>寻找 Animal 类的信息</p></li><li><p><strong>判断</strong> <em>Java</em>编译后的字节码里面是否有这个<em>Animal</em>类，如果没有，则类加载器会将当前这个类的<strong>字节码文件</strong>加载到文件中</p></li><li><p><code>new Animal()</code>创建对象时，对象在<strong>堆</strong>（_heap_）里面被分配内存空间</p></li><li><p>该被创建的对象在<strong>堆</strong>中的<strong>地址</strong>会被压入<strong>操作数栈</strong></p></li><li><p>在当前<strong>线程栈</strong>的方法栈帧的<strong>局部变量区域</strong>申请内存空间给<em>animal</em></p></li><li><p>从操作数帧中弹出顶部操作数（就是被创建对象在<strong>堆</strong>中的<strong>地址</strong>）赋值给<em>animal</em>，从而使<em>animal</em> <strong>指向</strong>新建的<em>Animal</em>对象</p></li></ol><hr></li><li><h3 id="JVM-理解"><a href="#JVM-理解" class="headerlink" title="JVM 理解"></a>JVM 理解</h3><p>我们将从下面这个简单的代码的<strong>反编译</strong>的*.class<em>文件，深度理解</em>Java*是如何在内存中被执行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPerson</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> a= <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (a+b)*<span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        TestPerson testPerson=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestPerson</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> testPerson.doSomething();<br>        System.out.println(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="上述代码的class反编译文件"><a href="#上述代码的class反编译文件" class="headerlink" title=".上述代码的class反编译文件"></a>.上述代码的<em>class</em>反编译文件</h4><p>我们对一些可以<strong>见名知意</strong>的名词不做过多解释，不清楚的大家可以在简书中搜索，<strong>此处</strong>主要还是<strong>加深</strong>大家对代码的<strong>理解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java">Compiled from <span class="hljs-string">&quot;JVM_03.TestPerson.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JVM_03</span>.TestPerson &#123;<br>  <span class="hljs-keyword">public</span> JVM_03.TestPerson();               <span class="hljs-comment">// 这是默认构造函数</span><br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>    Code:<br>       <span class="hljs-number">0</span>: iconst_1      <span class="hljs-comment">// 把常量1压入操作数栈</span><br>       <span class="hljs-number">1</span>: istore_1      <span class="hljs-comment">// 从操作数栈中弹出刚刚入栈的常量1</span><br>                        <span class="hljs-comment">// 并把它赋值给局部变量表中索引为1的变量</span><br>                        <span class="hljs-comment">// 即赋值给a  (对应代码：int a=1)</span><br>       <span class="hljs-number">2</span>: iconst_2<br>       <span class="hljs-number">3</span>: istore_2            <span class="hljs-comment">// 同上</span><br>       <span class="hljs-number">4</span>: iload_1             <span class="hljs-comment">// 将局部变量表中下标为1的int变量压入操作数栈</span><br>       <span class="hljs-number">5</span>: iload_2             <span class="hljs-comment">// 同上</span><br>       <span class="hljs-number">6</span>: iadd                <span class="hljs-comment">// 在操作数栈中完成两数相加</span><br>       <span class="hljs-number">7</span>: iconst_5            <span class="hljs-comment">// 将常量5压入操作数栈</span><br>       <span class="hljs-number">8</span>: imul                <span class="hljs-comment">//在操作数栈中完成乘法运算</span><br>       <span class="hljs-number">9</span>: istore_3            <span class="hljs-comment">//弹出运算结果并且赋值给局部变量表中索引为3的变量</span><br>      <span class="hljs-number">10</span>: iload_3<br>      <span class="hljs-number">11</span>: ireturn             <span class="hljs-comment">// 返回int类型的值 (ireturn 语句中 i就表示int)</span><br><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;<br>    Code:<br>       <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class JVM_03.TestPerson</span><br>       <span class="hljs-number">3</span>: dup<br>       <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">7</span>: astore_1<br>       <span class="hljs-number">8</span>: aload_1<br>       <span class="hljs-number">9</span>: invokevirtual #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method doSomething:()I</span><br>      <span class="hljs-number">12</span>: istore_2<br>      <span class="hljs-number">13</span>: getstatic     #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>      <span class="hljs-number">16</span>: iload_2<br>      <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(I)V</span><br>      <span class="hljs-number">20</span>: <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>​ 下面我们再挖深一些，进一步揭开 JVM 的面纱：</p><p>​ 我们先了解一下<em>Java</em>的<strong>运行时数据区</strong>(<em>Runtime Date Area</em>)，<em>Java</em>程序被运行时，内存中运行时数据区会被分为五部分，见下图。</p><p>​ <em>Java</em>程序运行是按线程来操作的，在线程栈中运行多个线程。每一个<strong>线程</strong>都有一个自己的<strong>栈帧</strong>，而每一个栈帧又包含局部变量、操作数栈、动态链接、方法出口四部分。上述就是在 main 线程里面的栈帧进行的。这里还要讲解一下，<strong>函数出口记录</strong>的问题。</p><p>​ 就上述<em>Java</em>代码而言，显然，程序需要从 main 函数进入<em>doSomething</em>函数，再返回 main 函数，为了不迷路，<em>Java</em>采用”<strong>标记</strong>“的方法记录出口，上述的*.class<em>文件中的#2 等等就是”标记“。当<code>new</code>一个新的对象时上述代码调用了默认构造函数，此时就需要进入该构造函数，</em>Java<em>离开 main 函数留下”标记“，java 进入函数时又留下”标记“，如此，进入不同函数，它就知道运行时如何返回</em>main*函数了。</p><ul><li><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><img src="/postImage/img-1.jpg" /></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java泛型与Kotlin高阶语法糖</title>
    <link href="/2022/06/02/Java%E6%B3%9B%E5%9E%8B%E4%B8%8EKotlin%E9%AB%98%E9%98%B6%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <url>/2022/06/02/Java%E6%B3%9B%E5%9E%8B%E4%B8%8EKotlin%E9%AB%98%E9%98%B6%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Java泛型与Kotlin高阶函数语法糖"><a href="#Java泛型与Kotlin高阶函数语法糖" class="headerlink" title="Java泛型与Kotlin高阶函数语法糖"></a><em>Java</em>泛型与<em>Kotlin</em>高阶函数语法糖</h1><ul><li><h3 id="java泛型"><a href="#java泛型" class="headerlink" title="java泛型"></a><em>java</em>泛型</h3><ol><li><p>什么是泛型？ 泛指<strong>一切类型</strong></p><p> 常使用 <em>T</em> <em>R</em> <em>V</em> <em>K</em> <em>I</em> <em>O</em> 表示</p></li><li><p>协变与形变</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Object&gt; a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        List&lt;String&gt; b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        a = b; <span class="hljs-comment">// 报错,为什么,a 需要 List&lt;Objects&gt;类型，而b 为List&lt;String&gt;类型</span><br>        *****************<br>        <span class="hljs-comment">// 此时需要使用协变</span><br>        父类接收子类 协变 ? <span class="hljs-keyword">extends</span><br>        <span class="hljs-title class_">List</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span>&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(); <span class="hljs-comment">// ? 为占位符，表示一个继承于Object的子类</span><br>        List&lt;String&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        c = d;<span class="hljs-comment">// 正确!!!</span><br>        *****************<br>        List&lt;Object&gt; e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        List&lt;String&gt; f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        f = e;<span class="hljs-comment">// 报错，f需要List&lt;Object&gt;类型，而e为List&lt;String&gt;类型，类型不匹配</span><br>        *****************<br>        <span class="hljs-comment">// 此时需要使用形变</span><br>        子类接收父类 形变 ? <span class="hljs-built_in">super</span><br>        List&lt;Object&gt; g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        List&lt;? <span class="hljs-built_in">super</span> String&gt; h = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        h = g;<span class="hljs-comment">// 正确！</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><em>java</em>泛型类的使用</p><p> 注意：泛型类中的方法只是使用了泛型类类型作为参数的函数，不是泛型函数</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 泛型类</span><br><span class="hljs-comment">// T type</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bag</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T value;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T getValue &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value;<br>    &#125;<br>    <span class="hljs-comment">// main</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 前面&lt;&gt; 和 后面&lt;&gt; 必须指定一处类型</span><br>        Bag&lt;String&gt; schoolBag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bag</span>&lt;&gt;();<br>        schoolBag.setValue(<span class="hljs-string">&quot;语文书&quot;</span>);<br>        System.out.println(schoolBag.getValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><h3 id="kotlin泛型类的使用"><a href="#kotlin泛型类的使用" class="headerlink" title="kotlin泛型类的使用"></a><em>kotlin</em>泛型类的使用</h3><ol><li><p><em>kotlin</em>泛型类的使用</p><p> <em>kotlin</em>: <em>out</em> 这个类型只能作为返回值 输出 生产</p><p> <em>kotln</em>: <em>in</em>只能作为参数 接受 消费</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bag</span>&lt;<span class="hljs-type">in I,out O</span>&gt;</span>(<span class="hljs-keyword">var</span> value: <span class="hljs-meta">@UnsafeVariance</span> I,<span class="hljs-keyword">var</span> result: <span class="hljs-meta">@UnsafeVariance</span> O) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(v1: <span class="hljs-type">I</span>)</span></span> &#123;<br>        value = v1<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>: O &#123;<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><h3 id="Kotlin泛型函数的使用"><a href="#Kotlin泛型函数的使用" class="headerlink" title="Kotlin泛型函数的使用"></a><em>Kotlin</em>泛型函数的使用</h3><p>何为泛型函数？不确定参数或者返回值类型的函数就是泛型函数</p><ol><li><p>仅有一个泛型</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>: T &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">test2</span><span class="hljs-params">(v1: <span class="hljs-type">T</span>)</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>放回值和参数类型均需要自己指定</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T,R&gt;</span> <span class="hljs-title">test</span><span class="hljs-params">(v1: <span class="hljs-type">T</span>, v2: <span class="hljs-type">T</span>)</span></span>: R? &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><h3 id="Kotlin高阶函数分析"><a href="#Kotlin高阶函数分析" class="headerlink" title="Kotlin高阶函数分析"></a><em>Kotlin</em>高阶函数分析</h3><ol><li><p>何为<strong>高阶函数</strong>与为什么需要使用**<em>inline</em>**?</p><p> 高阶函数是将<strong>函数</strong>用作<strong>参数或返回值</strong>的函数，实际开发过程中<strong>一般所有</strong>高阶函数都必须使用**<em>inline</em><strong>修饰，使之成为</strong>内联函数<strong>。不使用<em>inline</em>修饰高阶函数时，使用此类<a href="https://www.kotlincn.net/docs/reference/lambdas.html">高阶函数</a>会带来一些运行时的效率损失，因为编译时，每一个函数都是一个</strong>对象<strong>，</strong>内存分配<strong>（对于函数对象和类）和</strong>虚拟调用<strong>会引入</strong>运行时间开销<strong>，</strong>降低效率<strong>。当<em>inline</em>修饰了高阶函数时，此时编译时程序只是做了一个</strong>展开&#x2F;替换*<em>（类似于 C 语言的宏定义），所以在许多情况下我们通过使用</em>inline*内联化 lambda 表达式来消除这类的开销。</p></li><li><p>**<em>lambda</em>**表达式分析</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">show1</span><span class="hljs-params">(lambda: (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-comment">// lamba表达式为String类型的形参，没有返回值</span><br>    <span class="hljs-comment">// lambda 表达式里面是 it</span><br>    lambda(<span class="hljs-keyword">this</span>)<br>&#125;<br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">show2</span><span class="hljs-params">(lambda: <span class="hljs-type">String</span>.() -&gt; <span class="hljs-type">Unit</span> )</span></span> &#123;<br>    <span class="hljs-comment">// lambda 表达式里面是 this</span><br>    <span class="hljs-keyword">this</span>.lambda()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-string">&quot;jack&quot;</span>.show1&#123;<br>        println(<span class="hljs-string">&quot;hello <span class="hljs-variable">$it</span>&quot;</span>)<br>    &#125;<br>    <span class="hljs-string">&quot;Merry&quot;</span>.show2&#123;<br>        println(<span class="hljs-string">&quot;hello <span class="hljs-variable">$this</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><em>lambda</em>与泛型的综合运用</p><ul><li>给任意一个类型添加一个扩展函数，lambda 中使用 it 访问这个对象</li></ul> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">show1</span><span class="hljs-params">(lambda: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    lambda(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// 在这个函数中this指代的是调用这个扩展函数类型为T的对象,并把它作为参数传递给lambda，</span><br>    <span class="hljs-comment">//在lambda中使用it访问这个对象</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>给任意一个类型添加一个扩展函数，lambda 中使用 this 访问这个对象</li></ul> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">show2</span><span class="hljs-params">(lambda: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-keyword">this</span>.lambda() <span class="hljs-comment">// this指代是调用这个扩展函数类型为T的对象，再将其作为调用lambda的对象</span><br>     <span class="hljs-comment">// 在lambda中使用this访问这个对象</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>给任意一个类型添加一个扩展函数,并将这个对象传递给 lambda 表达式,lambda 返回值的类型由 lambda 最后一行的结果决定</li></ul> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T,R&gt;</span> T.<span class="hljs-title">show3</span><span class="hljs-params">(lambda: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>)</span></span> &#123;<br><span class="hljs-keyword">val</span> result = lambda(<span class="hljs-keyword">this</span>)<br>println(result!!::<span class="hljs-keyword">class</span>.java.name)<br><span class="hljs-comment">// 上行可以打印出lambda表达式最后一行结果的值</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li>运行效果如下</li></ul></li></ul><p>​ <img src="C:\Users\绝心\AppData\Roaming\Typora\typora-user-images\image-20220529173006301.png" alt="image-20220529173006301"><img src="C:\Users\绝心\AppData\Roaming\Typora\typora-user-images\image-20220529173058283.png" alt="image-20220529173058283"></p><ul><li><h3 id="Kotlin语法糖分析"><a href="#Kotlin语法糖分析" class="headerlink" title="Kotlin语法糖分析"></a><em>Kotlin</em>语法糖分析</h3><ul><li><p><em>apply</em>分析</p><p><em>apply</em>作用：使用 apply 可以进行初始化操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">myApply</span><span class="hljs-params">(lambda: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">T</span>)</span></span>: T &#123;<br>    <span class="hljs-keyword">this</span>.lambda()<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>also 分析</p><p><em>also</em>作用：使用 also 可以完成同时性的操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">myAlso</span><span class="hljs-params">(lambda: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">T</span>)</span></span>: T &#123;<br>    lambda(<span class="hljs-keyword">this</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>run 分析</p><p><em>run</em>作用：使用 run 可以执行一段代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">myRun</span><span class="hljs-params">(lambda: () -&gt; <span class="hljs-type">R</span>)</span></span>: R &#123;<br><span class="hljs-keyword">return</span> lambda()<br>&#125;<br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T,R&gt;</span> T.<span class="hljs-title">myRun</span><span class="hljs-params">(lambda: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.lambda()<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>with 分析</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T,R&gt;</span> <span class="hljs-title">myWith</span><span class="hljs-params">(value: <span class="hljs-type">T</span>,lambda: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R &#123;<br>    <span class="hljs-keyword">return</span> value.lambda()<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>forEach 分析</p><p><em>forEach</em>作用：使用 forEach 可以遍历完成相关的操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Iterable<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">myForEach</span><span class="hljs-params">(lambda: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: <span class="hljs-built_in">Unit</span> &#123;<br><span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) &#123;<br>lambda(item)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Kotlin高阶函数运用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
